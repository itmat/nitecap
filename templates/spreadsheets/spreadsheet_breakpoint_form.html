{% extends "base.html" %}
{% block content %}
<script>
    var toFixed = function(num, i) {
        // Call num.toFixed unless num is undefined (eg: null)
        if (typeof num === 'number') {
            return num.toFixed(i);
        }
        return num;
    };

    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    });

    var clusterized_rows = undefined;

    $(document).ready(function () {

        labels = {{ ids | safe }};
        x_values = {{ x_values | safe }};
        x_labels = {{ x_labels | safe }};
        x_label_values = {{ x_label_values | safe }};
        data = {{ data | safe }};
        column_pairs = {{ column_pairs | safe }};
        breakpoint = {{ breakpoint | safe }};
        qs = {{ qs | safe }};
        ps = {{ ps | safe }};
        amplitudes = {{ amplitudes | safe }};
        anovas = {{ anovas | safe }};
        peak_times = {{ peak_times | safe }};
        saved_max_value_filter = {{ max_value_filter | safe }};

        // List of whether each feature has been filtered out or not, starting with no filtering
        filtered = labels.map(function(x) {return false;});
        // List of the number of significant (non-filtered) features that are at or below a given index
        num_significant_below = labels.map(function(x,i) { return i+1;} );

        // Currently selected row from slider
        selected_row = breakpoint;

        y_values = [];
        trace_name = 'Nothing selected';
        marker_settings = {size: 12, symbol: 'circle-open', color: '#FF00FF'};

        var scatter_plot = document.getElementById('scatter_plot');

        var values = [{
            x: x_values,
            y: x_values.map(function(x) {return 0;}),
            name: trace_name,
            type: 'scatter',
            mode: 'lines+markers',
            marker: marker_settings
        }];

        var layout = {
            xaxis: {
                title: labels[breakpoint],
                ticktext: x_labels,
                tickvals: x_label_values,
                automargin: true
            }
        };

        // This empty plot should be quickly replaced since we trigger a select change event once everything is
        // set up.
        Plotly.newPlot(scatter_plot, values, layout);

        $("#coarse_slider").slider({
            orientation: "horizontal",
            min: 0,
            value: breakpoint,
            step: 1,
            max: labels.length - 1,
            slide: function (event, ui) {
                console.log("Slider is sliding to " + ui.value);
                selected_row = ui.value;

                //$("#row_selector").val(ui.value);
                $('#significant_items').html(num_significant_below[ui.value]);
                $('#q_value').html(toFixed(qs[ui.value], 3));
                $('#p_value').html(toFixed(ps[ui.value], 3));
                $('#amplitude').html(toFixed(amplitudes[ui.value], 3));
                $('#anova').html(toFixed(anovas[ui.value], 3));
                $('#peak_time').html(toFixed(peak_times[ui.value], 3));

                var row_selector = $('#row_selector')[0];
                selectRowAndScroll(ui.value);

                raw_y_values = data[ui.value];
                paired_y_values = [];
                paired_y_values = [];
                for( var i in column_pairs ) {
                    paired_y_values.push( raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null );
                }
                paired_x_values = [];
                for( var i in column_pairs ) {
                    paired_x_values.push( x_values[column_pairs[i][0]], x_values[column_pairs[i][1]], null );
                }
                $('input[name="row_index"]').val(ui.value);
                values = [{
                    x: paired_x_values, y: paired_y_values,
                    mode: 'lines+markers',
                    marker: marker_settings,
                    name: labels[ui.value],
                    type: 'scatter'
                }];
                var layout = {
                    title: labels[ui.value],
                    xaxis: {
                        ticktext: x_labels,
                        tickvals: x_label_values,
                        automargin: true
                    }
                };
                Plotly.react(scatter_plot, values, layout);
            }
        });

        $('#row_selector').change(function () {
            row = this.value;
            console.log("Selector changed: " + labels[row] + " Value:" + this.value + " Row " + row + " scrollTop:" + this.scrollTop + " .");
            if (row === "") {
                // Trying to change to a row that doesn't exist (eg: because of clusterization, it's not currently loaded)
                // so don't do anything!
                console.log("\tRow does not exist. No plot updates.");
                return;
            }

            $("#coarse_slider").slider("option", "value", row);

            raw_y_values = data[row];
            if (raw_y_values === undefined) {
                console.log("Could not find the y-values for row " + row);
                return;
            }

            paired_y_values = [];
            for( var i in column_pairs ) {
                paired_y_values.push( raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null );
            }
            paired_x_values = [];
            for( var i in column_pairs ) {
                paired_x_values.push( x_values[column_pairs[i][0]], x_values[column_pairs[i][1]], null );
            }

            $('input[name="row_index"]').val(row);
            $('#significant_items').html(num_significant_below[row]);
            $('#q_value').html(toFixed(qs[row], 3));
            $('#p_value').html(toFixed(ps[row], 3));
            $('#amplitude').html(toFixed(amplitudes[row], 3));
            $('#anova').html(toFixed(anovas[row], 3));
            $('#peak_time').html(toFixed(peak_times[row], 3));
            values = [{
                x: paired_x_values, y: paired_y_values,
                mode: 'lines+markers',
                marker: marker_settings,
                name: labels[row],
                type: 'scatter'
            }];
            var layout = {
                title: labels[row],
                xaxis: {
                    ticktext: x_labels,
                    tickvals: x_label_values,
                    automargin: true
                }
            };
            Plotly.react(scatter_plot, values, layout);
        });

        // Use "clusterize.js" to add these options without slowing everything down too much
        // only the options that are visible are kept as DOM objects versus having tens of thousands of DOM objects
        // which makes everything slow down
        // First make the list of our option elements
        var max_label_length = Math.max.apply(0, labels.map( function (x) {return x.length;}));
        var nonbreakingspace = "\u00A0";
        var option_rows = labels.map( function(label, i) {
            return '<option value="'+i+'">' + String(label).padEnd(max_label_length, nonbreakingspace) + ' Q: ' + toFixed(qs[i], 2) +  '</option>';
        } );

        var recluster = function(progress) {
            // Whenever the cluster of rows kept active changes, we need to update the selection
            // since we might have previously been trying to select something that wasn't in the current cluster
            // but now is in the cluster
            var row_selector = $('#row_selector')[0];
            if (clusterized_rows) {
                console.log("Reclustering to " + clusterized_rows.getClusterNum() + " row:" + selected_row);
                console.log("\tScroll top:" + clusterized_rows.scroll_elem.scrollTop);
                console.log("\tFirst option:" + $('#row_selector option')[1].value);
                console.log("\tSecond option:" + $('#row_selector option')[2].value);
            }

            var target_row = $('#row_selector option[value="' + selected_row + '"]');
            if (target_row.length > 0) {
                row_selector.scrollTop = target_row[0].offsetTop - row_selector.offsetTop - row_selector.clientHeight/2;
            } else {
                // Selected row not currently in view
                return;
            }

            $('#row_selector').val(selected_row).trigger('change');

            // Now filter out options, since the new options will need filter
            $('#row_selector option').each( function () {
                if (filtered[this.value]) {
                    this.setAttribute('disabled', 'disabled');
                } else {
                    this.removeAttribute('disabled');
                }
            } );
        };

        // Create the actual clusterization object
        clusterized_rows = new Clusterize({
            rows: option_rows,
            scrollId: "row_selector",
            contentId: "row_selector",
            callbacks: {
                "clusterChanged" : recluster,
            }
        });

        var selectRowAndScroll = function(row) {
            // Sets #row_selector to the desired row, taking into account the clusterization
            console.log("selectRowAndScroll to row " + row);
            selected_row = row;

            // First check if the desired row is already in the cluster
            var target_row = $('#row_selector option[value="' + row + '"]');
            var row_selector = $('#row_selector')[0];
            if (target_row.length > 0) {
                // If the target row is already in our cluster, then we can immediately scroll to the correct spot
                $('#row_selector').val(row).trigger("focus");
                row_selector.scrollTop = target_row[0].offsetTop - row_selector.offsetTop - row_selector.clientHeight/2;
            } else {
                // If the target row is not in our current cluster, then we have to scroll to the approximate location
                // and then the clusterChanged handler recluster() will later give the exact scroll position
                var option_height = row_selector.scrollHeight / clusterized_rows.getRowsAmount();
                row_selector.scrollTop = row * option_height - row_selector.offsetTop  - row_selector.clientHeight/2;
            }
        };

        $('#row_selector option[0]').attr('disable','disable');

        $('#set_breakpoint').click(function() {
            $('#heatmap_block').hide();
            $('#download_heatmap').hide();
            $('#toggle_replicates').hide();
            row_index = parseInt($('#row_index').val()) + 1;
            $('#cutoff').html(num_significant_below[row_index-1]);
            $.ajax({
                url: "{{url_for('spreadsheets.display_heatmap')}}",
                data: JSON.stringify({'row_index': row_index}),
                dataType: "json",
                contentType: "application/json",
                type: 'POST',
                success: function(response) {

                    var heatmap_layout = {
                        height: 700,
                        width: 900,
                        margin: {
                            l: 200,
                            r: 5,
                            b: 175,
                            t: 20
                        },
                        pad: 4
                    };

                    var heatmap_options = {
                        modeBarButtonsToAdd: [{
                            name: 'download in SVG format',
                            icon: Plotly.Icons.camera,
                            click: function (gd) {
                                Plotly.downloadImage(gd, {format: 'svg'})
                            }
                        }]
                    };

                    var heatmap_x_values = response['heatmap_x_values'];
                    var heatmap_labels = response['heatmap_labels'];
                    var heatmap_data = response['heatmap_data'];

                    var maxRow = heatmap_data.map(function(row){ return Math.max.apply(Math, row); });
                    var minRow = heatmap_data.map(function(row){ return Math.min.apply(Math, row); });

                    var max = Math.max.apply(null, maxRow);
                    var min = Math.min.apply(null, minRow);
                    var limit = Math.max(Math.abs(min), max);



                    var heatmap_values = [{
                        x: heatmap_x_values,
                        y: heatmap_labels,
                        z: heatmap_data,
                        type: 'heatmap',
                        zmin: -1 * limit,
                        zmax: limit,
                        colorbar: {
                            title: 'Z Scale',
                            titleside: 'right'
                        }
                    }];

                    Plotly.newPlot('heatmap', heatmap_values, heatmap_layout, heatmap_options);
                    $('#heatmap_block').show();
                    $('#download_heatmap').show();
                    $('#toggle_replicates').show();
                },
                error: function(error) {
                    console.log(error);
                }
            });
        });

        selectRowAndScroll(breakpoint);
        $('#row_selector').trigger("change");

        $('#download_heatmap').click(function() {
            var gd = document.getElementById('heatmap');
            Plotly.downloadImage(gd, {format: 'svg', filename: 'heatmap_' + row_index});
        });

        // Setup of filters card on page load
        if(saved_max_value_filter) {
            $('#max_value_filter').val(saved_max_value_filter)
        }
        else {
            $('#EmptyFiltersList').css({"visibility":"visible"});
        }

        $('#applyFilters').click(function() {
            row_index = $('input[name="row_index"]').val();
            $('#row_selector option').removeAttr('disabled');
            if($('#max_value_filter').val().length == 0) {
                $('#EmptyFiltersList').css({"visibility":"visible"});
                $('#significant_items').html(row_index);
                return
            }
            var max_value_filter = parseInt($('#max_value_filter').val());
            $('#EmptyFiltersList').css({"visibility":"hidden"});

            ctr = 0;
            set_significant_items = false;
            var options = $('#row_selector option');
            var significant_items = $('#significant_items');
            $.each(data, function(index, row) {
                var filter_out = row.every(function(item) {
                    return item < max_value_filter;
                });
                if (filter_out) {
                    //options.eq(index).attr('disabled', 'disabled');
                } else {
                    //options.eq(index).removeAttr('disabled', 'disabled');
                    ctr++;
                }

                filtered[index] = filter_out;
                num_significant_below[index] = ctr;

                // Update number of significant items
                if(index >= row_index && !set_significant_items) {
                    significant_items.html(ctr);
                    set_significant_items = true;
                }
            });

            $('#row_selector option').each( function () {
                if (filtered[this.value]) {
                    this.setAttribute('disabled', 'disabled');
                } else {
                    this.removeAttribute('disabled');
                }
            } );

            $.ajax({
                url: "{{url_for('spreadsheets.save_filters')}}",
                data: JSON.stringify({'max_value_filter': max_value_filter}),
                dataType: "json",
                contentType: "application/json",
                type: 'POST',
                success: function(response) {
                    // Nothing to see here.
                }
            });
        });

        $('#combine_replicates').change(function() {
            var combine_replicates = $(this).is(':checked');
            console.log('combine_replicates is' + combine_replicates);
            $.ajax({
                url: "{{url_for('spreadsheets.combine_replicates')}}",
                data: JSON.stringify({'combine_replicates: ': combine_replicates}),
                dataType: "json",
                contentType: "application/json",
                type: 'POST',
                success: function(response) {
                    // Nothing to see here.
                }
            });
        });

        $('#applyFilters').click();

});


</script>

<div id="graph-page" class="page-header">
    <h1>Results <small>Data sorted by significance</small></h1>
</div>

<p id="spreadsheet-breakpoint-page">
    <div class="row">
        <p class="col-lg-12 h3">{{descriptive_name}}
            <a href="{{ url_for('spreadsheets.download_spreadsheet') }}" download="processed_file.txt">
                <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
            </a>
        </p>

    </div>
    <div class="row">
        <span class="col-lg-9">
            Number of items equal to or more significant than currently selected:
            <span id="significant_items"></span>
        </span>
    </div>

    <div class="row">
        <div id="coarse_slider" class="col-lg-12 coarse-slider"></div>
    </div>

    <div class="row">
        <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
    </div>

    <div class='row'>
        <span class='col-xs-1' style="position:relative">
            <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
        </span>
        <span class='col-xs-3 ...'>
            <select size="50" name="row_selector" id="row_selector" class="clusterize-content clusterize-scroll"></select>
        </span>
        <span class="'col-xs-6" id="scatter_plot" style="width:625px;height:450px;vertical-align: top"></span>

        <div class="card col-xs-1" style="width: 15rem;">
            <div class="card-header">
                Statistics
            </div>
            <div class="card-body">
                <ul class="list-group list-group-flush">
                    <li class="list-group-item">Q: <span id="q_value"></span></li>
                    <li class="list-group-item">p-value: <span id="p_value"></span></li>
                    <li class="list-group-item">Amplitude: <span id="amplitude"></span></li>
                    <li class="list-group-item">Peak-time: <span id="peak_time"></span></li>
                    <li class="list-group-item">ANOVA p: <span id="anova"></span></li>
                </ul>
            </div>
        </div>
        <div id="FiltersCard" class="card col-xs-1" style="width: 20rem;">
            <div class="card-header">
                Filters
            </div>
            <div class="card-body">
                <div id="EmptyFiltersList" style="visibility:hidden">No filters currently selected.</div>
                <div class="form-group form-inline">
                    <label class="col-form-label" for="max_value_filter" style="margin-right: 10px">Max Value &gt;</label>
                    <input class="form-control form-control-sm" type="text" id="max_value_filter" name="max_value_filter" style='width: 60px' />
                </div>
                <button id="applyFilters" type="button" class="btn btn-primary" data-dismiss="modal">Apply filters</button>
            </div>
        </div>
    </div>

    <div class="row" style="padding-top:2rem;padding-bottom:2rem">
        <span class="col-lg-5">
            <input type="hidden" id="row_index" name="row_index"/>
            <button id="set_breakpoint" class="btn btn-primary">Set Significance Cutoff</button>
        </span>
        <span id="toggle_replicates" class="col-lg-5" style="display:none">
            <span style="vertical-align:center;padding-right:1rem">Combine Replicates</span>
            <label class="switch">
                <input id="combine_replicates" name="combine_replicates" type="checkbox" >
                <span class="slider"></span>
            </label>
        </span>
        <span class='col-lg-2'>
            <button id="download_heatmap" class="btn btn-primary" style="display:none">Download Heatmap</button>
        </span>
    </div>
    <div id="heatmap_block" style="display:none">
        <div class="row">
            <span class="col-lg-12">Number of items in heatmap: <span id="cutoff"></span></span>
        </div>
        <div class="row" id="heatmap"></div>
    </div>

{% endblock %}
