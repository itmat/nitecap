{% extends "base.html" %}

{% block content %}


<!-- temporary inlining of Vue.JS dev version -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>

    $(document).ready(function () {
        // Handles to the error-handling modal
        nitecap_error = $("#error-modal");
        nitecap_error_message = $("#error-modal-message")

        spreadsheet_ids = {{ spreadsheet_ids | safe }};

        $.ajax({
            url: "/spreadsheets/get_spreadsheets",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                onSpreadsheetLoad(response);
            },
            error: function(error) {
                console.log("Error loading spreadsheets");
                console.log(error);

                nitecap_error_message.text("Error loading spreadsheets");
                nitecap_error.modal();
            }
        });

    });

    function onSpreadsheetLoad(spreadsheets) {
        // FOR VUE
        spreadsheets.forEach(function(spreadsheet) {
            spreadsheet.upside_ps = null;
            spreadsheet.upside_qs = null;

            // VUE PERF NOTE
            // Vue "observes" all attributes of observed objects
            // so it will try to observe everything in the large data arrays
            // however we do not need reactivity for those arrays since they don't change
            // Here we disable adding new elements to them which causes Vue to not observe every element in the array
            // Note that the arrays themselves are still observed in the sense that doing spreadsheet.tds = <new array>
            // will propagate changes that depend on spreadsheet.tds
            Object.keys(spreadsheet).forEach(function(key){
                if (Array.isArray(spreadsheet[key])) {
                    Object.preventExtensions(spreadsheet[key]);
                }
            });
        });

        app.spreadsheets = spreadsheets;
        app.labels = spreadsheets[0].labels;
        app.timepoints_per_day = app.spreadsheets[0].timepoints_per_day;
        app.num_days = (Math.max.apply(null, spreadsheets[0].x_values) + 1) / spreadsheets[0].timepoints_per_day;

        function makeCoarseSlider(element, start_value, maximum) {
            element.slider({
                orientation: "horizontal",
                min: 0,
                value: start_value,
                step: 1,
                max: maximum,
                range: "min",
                slide: function (event, ui) {
                    app.selected_row = ui.value;
                }
            });
        }

        makeCoarseSlider($('#coarse_slider'), 0, app.labels.length - 1);


        // Load the JTK values for each spreadsheet
        $.ajax({
            url: "/spreadsheets/jtk",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                let jtk_ps = response['jtk_ps'];
                let jtk_qs = response['jtk_qs'];

                spreadsheets.forEach(function(spreadsheet, i) {
                    // For Vue performance see VUE PERF NOTE
                    Object.preventExtensions(jtk_ps[i]);
                    Object.preventExtensions(jtk_qs[i]);
                    spreadsheet.jtk_ps = jtk_ps[i];
                    spreadsheet.jtk_qs = jtk_qs[i];
                });
            },
            error: function(error) {
                console.log("Error loading JTK values");
                console.log(error);

                nitecap_error_message.text("Error loading JTK values");
                nitecap_error.modal();
            }
        });

        // Load the Upside values
        if (spreadsheets.length > 1) {
            $.ajax({
                url: "/spreadsheets/get_upside",
                data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
                dataType: 'text json',
                contentType: 'application/json',
                type: 'POST',
                success: function(response) {
                    // See VUE PERF NOTE
                    // Make all arrays non-traversed by Vue for performance
                    Object.keys(response).forEach(function(key) {
                        Object.preventExtensions(response[key]);
                    });

                    upside_ps = response['upside_ps'];
                    upside_qs = response['upside_qs'];

                    spreadsheets.forEach(function(spreadsheet, idx){
                        Object.preventExtensions(upside_ps[idx]); // See VUE PERF NOTE
                        Object.preventExtensions(upside_qs[idx]); // these aren't covered by above since are one level deeper
                        spreadsheet.upside_ps = upside_ps[idx];
                        spreadsheet.upside_qs = upside_qs[idx];
                    });

                    app.stats.two_way_anova_ps = response['two_way_anova_ps'];
                    app.stats.two_way_anova_qs = response['two_way_anova_qs'];
                    app.stats.phase_ps = response['phase_ps'];
                    app.stats.phase_qs = response['phase_qs'];
                    app.stats.amplitude_ps = response['amplitude_ps'];
                    app.stats.amplitude_qs = response['amplitude_qs'];

                },
                error: function(error) {
                    console.log("Error loading upside values");
                    console.log(error);

                    nitecap_error_message.text("Error loading comparison statistics");
                    nitecap_error.modal();
                }
            });
        }

        $('[data-toggle="tooltip"]').tooltip();
    }
</script>

{% raw %}

<div id="vue-app">
    <div class="page-header">
        <h1>Spreadsheet Viewer</h1>
    </div>

    <div class="row">
        <p class="col-lg-12 h3" v-if="spreadsheets[1]" v-cloak>
            {{spreadsheets[0].descriptive_name}} vs. {{spreadsheets[1].descriptive_name}}

            <a v-bind:href="'/spreadsheets/download_comparison/'+spreadsheets[0].spreadsheet_id+','+spreadsheets[1].spreadsheet_id"
                    class="mx-3" download="processed_file.txt">
                <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
            </a>
        </p>

        <p class="col-lg-12 h3" v-if="spreadsheets.length === 1">
            {{spreadsheets[0].descriptive_name}}
            <a v-bind:href="'/spreadsheets/download/'+spreadsheets[0].spreadsheet_id" class="mx-3" download="processed_file.txt">
                <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
            </a>
            <a v-bind:href="'/spreadsheets/collect_data/'+spreadsheets[0].spreadsheet_id">
                <i class="fas fa-edit" data-toggle="tooltip" data-placement="top" title="Edit"></i>
            </a>
            <a id='share_spreadsheet' href="#" v-on:click="onShare">
                <i class="fas fa-share-square" data-toggle="tooltip" data-placement="top" title="Share"></i>
            </a>
        </p>
    </div>
    <div class="row">
        <span class="form-group col-lg-9">
            Number of selected rows:
            <input type="number" v-model="num_below"></input>
        </span>
    </div>


    <div class="row">
        <div class="col">
            <div id="coarse_slider" class="coarse-slider"></div>
        </div>
    </div>

    <div class="row">
        <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
    </div>

    <div class='row'>
        <span class='col-auto'>
            <div class='row'>
                <div class="col">
                    <div class="input-group mb-2">
                        <input class="form-control form-control-sm" type="text" name="row_search"
                               placeholder="Search for row by label" v-model="search_value"
                               v-on:keyup.enter="searchRows"/>
                        <div class="input-group-append">
                            <button type="button" class="btn btn-secondary btn-sm"
                                    v-on:click="searchRows">
                                Search
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class='row'>
                <div class='col-auto'>
                    <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
                    <row-selector v-bind:sort-order="sort_order"
                                  v-bind:filtered="filtered"
                                  v-bind:num-rows="21"
                                  v-bind:q-values="label_qs"
                                  v-bind:selected-row="selected_row"
                                  v-bind:labels="labels"
                                  v-bind:label-max-length="35"
                                  v-bind:select-row="selectRow"
                                  v-cloak>
                    </row-selector>
                    <div class="form-check">
                        <input class="form-check-input" id="hide_filtered" type="checkbox" v-model="hide_filtered_rows">
                        <label class="form-check-label" for="hide_filtered">Hide filtered rows</label>
                    </div>
                </div>
            </div>
        </span>
        <div class='col-auto'>
            <span id="scatter_plot" style="width:625px;height:525px;vertical-align: top"></span>
            <div class='p-3 float-right'>
                <button class="btn btn-primary" v-on:click="downloadPlot">Download Plot</button>
            </div>
            <div class='p-3 float-right'>
                <button class="btn btn-primary btn-sm" v-on:click="shiftSpreadsheets" v-if="spreadsheets.length > 1">Reorder Spreadsheets</button>
            </div>
            <form class="form-group">
                <div class="form-inline">
                    <label for="plot_style_select">Plot style</label>
                    <select id="plot_style_select" value="basketweave" class="form-control form-control-sm" v-model="plot.config.style">
                        <option value="basketweave">Basketweave</option>
                        <option value="points">Points</option>
                        <option value="mean">Mean only</option>
                        <option value="mean_points">Points and Mean</option>
                        <option value="std">Standard Deviations</option>
                        <option value="std_points">Standard Deviations and Points</option>
                        <option value="SEM">SEM</option>
                        <option value="SEM_points">SEM and Points</option>
                    </select>
                </div>
                <div class="form-inline">
                    <label for="plot_x_label_style">Plot x-axis labels</label>
                    <select id="plot_x_label_style" class="form-control form-control-sm" v-model="plot.config.x_label_style">
                        <option value="daytime" selected>Day and time</option>
                        <option value="time">Time of day</option>
                        <option value="infer">Inferred labels</option>
                        <option value="infer_wrapped">Inferred labels wrapping</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="form-check" id="fold_days_box" v-if="num_days > 1">
                    <input class="form-check-input" id="fold_days_checkbox" type="checkbox" v-model="plot.config.fold_days">
                    <label class="form-check-label" for="fold_days_checkbox">Overlay cycles</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" id="include_zero_checkbox" type="checkbox" v-model="plot.config.include_zero">
                    <label class="form-check-label" for="include_zero_checkbox">Include zero</label>
                </div>
            </form>
        </div>

        <div class="col-auto">
            <div class="card">
                <div class="card-header">
                    Statistics
                    <a id="statsHelp" class="text-primary help-pointer ml-3"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Statistics Help"
                       data-content="Displays statistics about the selected row. JTK values are calculated on first page load and may a take a minute.">
                        <i class="fas fa-info-circle"></i>
                    </a>
                </div>
                <div class="card-body">
                    <table class="table table-sm">
                        <thead>
                            <tr v-if="spreadsheets.length > 1">
                                <th scope="col"></th>
                                <th scope="col" v-for="name in descriptive_names">{{name}}</th>
                            </tr>
                        </thead>
                        <tbody v-if="spreadsheets !== null" class="stats-box">
                            <template v-for="stat in useable_stats">
                                <tr>
                                    <td v-bind:rowspan="typeof stat.value === 'string' ? 1 : 2">
                                        {{stat.name}}
                                        <a class="text-primary help-pointer float-right ml-1"
                                            data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                            v-bind:title="stat.name"
                                            v-bind:data-content="stat.description">
                                            <i class="fas fa-info-circle"></i>
                                        </a>
                                    </td>

                                    <template v-if="typeof stat.value === 'string'">
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="(spreadsheet, i) in spreadsheets">
                                                <td v-if="spreadsheet[stat.value] != null"
                                                    v-on:click="sort_by = {stat:stat, spreadsheet_num: i}"
                                                    v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-sort-cell' : ''"
                                                    v-bind:title="String(spreadsheet[stat.value][row_index])">
                                                    {{util.formatNum(spreadsheet[stat.value][row_index], 4)}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value] != null"
                                                v-bind:title="String(stats[stat.value][row_index])"
                                                v-on:click="sort_by = {stat:stat}"
                                                v-bind:class="stat === sort_by.stat ? 'selected-sort-cell' : ''"
                                                v-bind:colspan="spreadsheets.length">
                                                {{util.formatNum(stats[stat.value][row_index], 4)}}
                                            </td>
                                            <td v-else>
                                                loading
                                            </td>
                                        </template>
                                    </template>

                                    <template v-else>
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="(spreadsheet, i) in spreadsheets">
                                                <td v-if="spreadsheet[stat.value.p] != null"
                                                    v-on:click="sort_by = {stat:stat, spreadsheet_num: i}"
                                                    v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-sort-cell' : ''"
                                                    v-bind:title="String(spreadsheet[stat.value.p][row_index])">
                                                    p: {{util.formatNum(spreadsheet[stat.value.p][row_index], 4)}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value.p] != null"
                                                v-bind:title="String(stats[stat.value.p][row_index])"
                                                v-on:click="sort_by = {stat:stat}"
                                                v-bind:class="stat === sort_by.stat ? 'selected-sort-cell' : ''"
                                                v-bind:colspan="spreadsheets.length">
                                                p: {{util.formatNum(stats[stat.value.p][row_index], 4)}}
                                            </td>
                                            <td v-else v-bind:colspan="spreadsheets.length">
                                                loading
                                            </td>
                                        </template>
                                    </template>
                                </tr>

                                <tr v-if="typeof stat.value !== 'string'">
                                    <template v-if="stat.per_spreadsheet">
                                        <template v-for="(spreadsheet, i) in spreadsheets">
                                            <td v-if="spreadsheet[stat.value.q] != null"
                                                v-on:click="sort_by = {stat:stat, spreadsheet_num: i}"
                                                v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-sort-cell' : ''"
                                                v-bind:title="String(spreadsheet[stat.value.q][row_index])">
                                                q: {{util.formatNum(spreadsheet[stat.value.q][row_index], 4)}}
                                            </td>
                                            <td v-else>
                                                loading
                                            </td>
                                        </template>
                                    </template>
                                    <template v-else>
                                        <td v-if="stats[stat.value.q] != null"
                                            v-bind:title="String(stats[stat.value.q][row_index])"
                                            v-on:click="sort_by = {stat:stat}"
                                            v-bind:class="stat === sort_by.stat ? 'selected-sort-cell' : ''"
                                            v-bind:colspan="spreadsheets.length">
                                            q: {{util.formatNum(stats[stat.value.q][row_index], 4)}}
                                        </td>
                                        <td v-else v-bind:colspan="spreadsheets.length">
                                            loading
                                        </td>
                                    </template>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <div class="row">
        <div id="FiltersCard" class="col-auto" v-on:keyup.enter="applyFilters">
            <div class="card">
                <div class="card-header">
                    Filters
                    <a id="filtersHelp" class="text-primary help-pointer ml-3"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Filter Help"
                       data-content="Keep only rows matching the criteria provided. Rerunning the q-values computes q-values using only the unfiltered genes. This is statistically invalid to do if filtering on most criteria (eg: if filtering p-values or q-values, one should not rerun the q-values). Instead, only rerun q-values when filtering exclusively on time-unaware criteria (such as max value).">
                        <i class="fas fa-info-circle"></i>
                    </a>
                </div>
                <div class="card-body">
                    <div id="filter_list">
                        <div v-for="(filter, index) in filters" class="row"
                            :key="filter.id">
                            <div class='col form-inline filter_item'>
                                <input class="form-control form-control-sm m-1 filter-lower-bound" style="width: 85px"
                                     v-bind:aria-label="'Lower bound for filter ' + index"
                                     v-model="filter.lower_bound">
                                </input>

                                &le;

                                <select class="form-control form-control-sm m-1 filter_value_selector"
                                        v-bind:aria-label="'Filter selector for filter ' + index"
                                        v-model="filter.variable">
                                    <option v-for="filter_data in filter_data_list"
                                            v-bind:value="filter_data.key">
                                            {{filter_data.name}}
                                    </option>
                                </select>

                                &le;

                                <input class="form-control form-control-sm m-1 filter-upper-bound" style="width: 85px"
                                     v-bind:aria-label="'Upper bound for filter ' + index"
                                     v-model="filter.upper_bound">
                                </input>

                                <button class="btn btn-default" v-bind:aria-label="'Remove filter ' + index" title="Remove filter"
                                        v-on:click="filters = filters.filter(function(x,j) {return j !== index;})">
                                    <span class="far fa-minus-square"> </span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <button id="reset_filters_button" class="btn btn-default" aria-label="Reset filters"
                        v-on:click="resetFilters">
                        <span class="fas fa-undo" title="Reset filters" data-toggle="tooltip" data-placement="top"></span>
                    </button>
                    <button id="add_filter_button" class="btn btn-default" style="float: right" aria-label="Add filter"
                        v-on:click="addFilter">
                        <span class="far fa-plus-square" title="Add filter" data-toggle="tooltip" data-placement="top"></span>
                    </button>
                    <div>
                        <button id="applyFilters" type="button" class="btn btn-primary mb-4" v-on:click="applyFilters">Apply filters</button>
                        <button id="rerun_qvalues" type="button" class="btn btn-primary mb-4">Rerun q-values</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <heatmap-plot
        v-bind:spreadsheets="spreadsheets"
        v-bind:num_days="num_days"
        v-bind:selected_rows="selected_rows"
        v-bind:timepoint_labels="timepoint_labels"
        v-bind:day_and_time_labels="day_and_time_labels"
        v-bind:labels="labels">
    </heatmap-plot>

    <pca-plot
        v-bind:spreadsheets="spreadsheets"
        v-bind:timepoint_labels="timepoint_labels">
    </PCA-plot>

    <!-- MODALS -->
    <div id="share_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">SHARE this spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="share_url">Copy this URL and offer it to anyone with whom you'd like to share your
                        spreadsheet data:</label>
                    <textarea id="share_url" class="form-control" rows="6"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
      </div>
    </div>

</div>

{% endraw %} <!-- TODO remove these raw tags when we are no longer using templating at all -->

<script src="{{url_for('static', filename='js/row_selector.js')}}"></script>
<script src="{{url_for('static', filename='js/PCA_plot.js')}}"></script>
<script src="{{url_for('static', filename='js/heatmap_plot.js')}}"></script>

<script>
    Vue.prototype.util = {
        formatNum: formatNum
    };

    let stats_list = [
        {name: "Nitecap",
         value: {p: "ps",
                 q: "qs"},
          description: "Nitecap significance of rhythmicity for primary dataset.",
         per_spreadsheet: true,
         num_spreadsheets:'any',
         sort_value:'tds',
         secondary_sort_value:'qs'},
        {name: "JTK",
         value: {p: "jtk_ps",
                 q: "jtk_qs"},
         description: "JTK_cycle significance of rhythmicity for primary dataset.",
        per_spreadsheet: true,
        num_spreadsheets:'any'},
        {name: "ANOVA",
         value: {p: "anova_ps",
                 q: "anova_qs"},
         description: "1-Way ANOVA on primary dataset. If there are no replicates on timepoints, ANOVA cannot be run.",
         per_spreadsheet: true,
         num_spreadsheets: 'any'},
        {name: "Damping",
         value: {p: "upside_ps",
                 q: "upside_qs"},
         description: "Damping analysis giving significance of a decrease in variation in the secondary dataset compared to the first.",
         per_spreadsheet: true,
         num_spreadsheets: 'multi'},
        {name: "Two-way ANOVA",
         value: {p: "two_way_anova_ps",
                 q: "two_way_anova_qs"},
         description: "Two-way ANOVA test for difference in timepoint-effects across datasets",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        {name: "Phase Difference",
         value: {p: "phase_ps",
                 q: "phase_qs"},
         description: "Test for equality of phase between datasets through cosinor analysis (least squares fit)",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        {name: "Amplitude Difference",
         value: {p: "amplitude_ps",
                 q: "amplitude_qs"},
         description: "Test for equality of amplitudes between datasets through cosinor analysis (least squares fit)",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        {name: "Amplitude",
         value: "amplitudes",
         description: "Amplitude of the variation.",
         per_spreadsheet: true,
         num_spreadsheets: 'any',
         sort_direction: -1},
        {name: "Peak-time",
         value: "peak_times",
         description: "Time the peak value occurs at. The units are the numbers of the timepoints, i.e. 3.5 means half-way between timepoint 3 and timepoint 4.",
         per_spreadsheet: true,
         num_spreadsheets: 'any'},
    ];

    let filter_data_list_base = [
        {values: function () {
                         // Grand maximum across both datasets within each row
                         let maxes = app.spreadsheets.map(function (spreadsheet) {
                                return maximums(spreadsheet.data);
                         });
                         return maxes[0].map( function(row, i) {
                            return Math.max.apply(null, maxes.map(function(max){return max[i];}));
                        });
                    },
                name: "Maximum value",
                independent: true,
                key:"max_value"},
        {values: function () {
                    // Grand means across both datasets within each row
                    // skipping over NaN/null values
                    let sums_ = app.spreadsheets.map(function(spreadsheet) {
                        let summed_rows = sums(spreadsheet.data);
                        return summed_rows;
                    });
                    let total_sums = sums(sums_, 0);

                    let nonnans = app.spreadsheets.map(function(spreadsheet) {
                        return numValids(spreadsheet.data);
                    });
                    let total_nonnans = sums(nonnans, 0);

                    let divide = function(a,b) { return a/b; };

                    let means = total_sums.map(function(sum, i) {
                        return sum / total_nonnans[i];
                    });
                    return means;
                },
                name: "Mean value",
                independent: true,
                key: "mean_value"},
        {values: function () {
                let missing = app.spreadsheets.map( function(spreadsheet) {
                     return numNaNTimepoints(spreadsheet.data, spreadsheet.x_values);
                });
                return maximums(missing, axis=0);
            },
            name: "Missing Timepoints",
            independent: true, // TODO: is this actually right?
            key: "missing_timepoints"},
    ];

    let app = new Vue({
        el: "#vue-app",
        data: {
            filters: [],
            last_used_filters: [],
            hide_filtered_rows: false,
            spreadsheets: [],
            selected_row: 0,
            sort_by: {stat: stats_list[0], spreadsheet_num: 0},

            search_value: '',

            stats_list: stats_list,

            stats: {
                amplitude_ps: null,
                amplitude_qs: null,
                phase_ps: null,
                phase_qs: null,
                two_way_anova_ps: null,
                two_way_anova_qs: null,
            },

            labels: [],
            timepoints_per_day: 0,
            num_days: 0,

            plot: {
                config: {
                    fold_days: false,
                    style: "mean_points",
                    x_label_style: "infer",
                    include_zero: false,
                },
                first_render: false,
            },

        },

        methods: {
            resetFilters: function(){
                this.filters = this.last_used_filters.slice();
            },

            addFilter: function(){
                let new_id = 0; // Make filter keys
                if (this.filters.length > 0){
                    new_id  = Math.max.apply(null, this.filters.map( function(filter) {
                        return filter.id;
                    }))  + 1;
                }
                this.filters.push( {variable: 'max_value', lower_bound:'', upper_bound:'', id: new_id} );
            },

            applyFilters: function() {
                // Copy the filters that we last ran
                // last_used_filters are the ones we actually filter on
                // needs to be deep copy so we json-ify it and back
                this.last_used_filters = JSON.parse(JSON.stringify(this.filters));
            },

            redrawPlot: function() {
                let vm = this;
                // Update the Plotly plots of the feature profiles
                let traces = [];
                let colors = Plotly.d3.scale.category10();
                vm.spreadsheets.forEach(function (spreadsheet, idx) {
                    let row_index = vm.sort_order[vm.selected_row];
                    raw_y_values = spreadsheet.data[row_index];
                    if (raw_y_values === undefined) {
                        console.log("Could not find the y-values for row " + row_index);
                        return;
                    }

                    if (vm.plot.config.fold_days) {
                        plot_x_values = spreadsheet.x_values.map(function (x) {return x % spreadsheet.timepoints_per_day;});
                        plot_x_labels = plot_x_values.map(function(x) {return "Timepoint " + (x+1);});
                        plot_x_label_values = plot_x_labels.map(function(x,i) {return i;});
                    } else {
                        plot_x_values = spreadsheet.x_values;
                        plot_x_labels = spreadsheet.x_labels;
                        plot_x_label_values = spreadsheet.x_label_values;
                    }

                    let x_label_style = vm.plot.config.x_label_style;
                    if (x_label_style === 'none') {
                        plot_x_labels = plot_x_labels.map( function (x) {return '';} );
                    } else if (x_label_style === 'time') {
                        plot_x_labels = plot_x_labels.map( function(x,i) {
                            return "Timepoint " + (i % spreadsheet.timepoints_per_day + 1);
                        });
                    } else if (x_label_style === 'infer') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t);
                            });
                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    } else if (x_label_style === 'infer_wrapped') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t, true);
                            });

                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    }

                    let stats = rowStatsByTimepoint(raw_y_values, plot_x_values);

                    // Pick a color for this spreadsheet using Plotly's defaults from d3
                    let spreadsheet_color = colors(idx);
                    let marker_settings = {size: 12, symbol: 'circle-open'};


                    // Default values for the different plot styles to override
                    let trace = {
                        x: plot_x_values, y: raw_y_values,
                        mode: 'markers',
                        marker: marker_settings,
                        name: vm.descriptive_names[idx],
                        type: 'scatter',
                        'marker': {color: spreadsheet_color},
                        'line': {color: spreadsheet_color}
                    };

                    // Pick data and styling based off the plot_style_select value
                    let plot_style = vm.plot.config.style;
                    if (plot_style === "basketweave") {
                        // Make pairs of points that are adjacent in time to each other, for each dataset
                        column_pairs = [];
                        plot_x_values.forEach( function(x,i) {
                            for(let j = i+1; j < plot_x_values.length; j++) {
                                if (Math.abs(plot_x_values[j] - x) === 1) {
                                    column_pairs.push([i,j]);
                                }
                            }
                        });

                        paired_y_values = [];
                        for (let i in column_pairs) {
                            paired_y_values.push(raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null);
                        }

                        paired_x_values = [];
                        for (let i in column_pairs) {
                            paired_x_values.push(plot_x_values[column_pairs[i][0]], plot_x_values[column_pairs[i][1]], null);
                        }

                        trace.mode = 'lines+markers';
                        trace.x = paired_x_values;
                        trace.y = paired_y_values;
                    } else if (plot_style === "points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                    } else if (plot_style === "mean") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                    } else if (plot_style === "mean_points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                        traces.push({ // The mean value trace
                            x: stats.means.map( function (x,i) {return i;} ), // Just 0,1,2,3...
                            y: stats.means,
                            type: "scatter",
                            mode: "lines",
                            showlegend: false,
                            'line': {color: spreadsheet_color}
                        });
                    } else if (plot_style === "std") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                    } else if (plot_style === "std_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            showlegend: false,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style === "SEM") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                    } else if (plot_style === "SEM_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            showlegend: false,
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    }

                    traces.push(trace);

                });

                let layout = {
                    hovermode: 'closest',
                    title: app.labels[app.sort_order[app.selected_row]],
                    legend: { orientation: 'h', y: -0.2 },
                    xaxis: {
                        ticktext: plot_x_labels,
                        tickvals: plot_x_label_values,
                        automargin: true,
                    },
                    yaxis: {
                        rangemode: vm.plot.config.include_zero ? 'tozero' : '',
                    }
                };

                if (vm.first_render) {
                    Plotly.newPlot('scatter_plot', traces, layout);
                    vm.first_render = false;
                } else {
                    Plotly.react('scatter_plot', traces, layout);
                }
            },

            downloadPlot: function() {
                let gd = document.getElementById('scatter_plot');
                Plotly.downloadImage(gd, {format: 'svg', filename: 'plot_' + (app.selected_row+1)});
            },


            selectRow: function(row) {
                this.selected_row = row;
            },

            onRowChange: function () {
                this.redrawPlot();

                $('#coarse_slider').slider('value', this.selected_row);
            },

            searchRows: function() {
                let search_value = this.search_value.toLowerCase();

                // Pull out row indexes matching our search_value
                let matching_rows = app.labels.map( function(unused, index) {
                    let label = app.labels[app.sort_order[index]];
                    if (label.toLowerCase().indexOf(search_value) !== -1) {
                        return index;
                    }
                }).filter(isFinite);


                if (matching_rows.length === 0) {
                    console.log("Unfortunately no matching row found.");
                    // TODO: display something to the user
                    return;
                }

                // Find matches in rows past the current selection
                let matches_after = matching_rows.filter( function (i) {
                    return i > app.selected_row;
                } );

                let row = null;
                if (matches_after.length > 0) {
                    // First look for matches that are *after* our selected_row
                    // so that multiple button presses will cycle the selection through all matches
                    row = matches_after[0];
                } else {
                    // If that fails, grab the first matching row
                    row = matching_rows[0];
                }

                app.selected_row = row;
            },

            onShare: function() {
                // Open Modal to share the spreadsheet
                let spreadsheet_id = this.spreadsheets[0].spreadsheet_id;
                let vm = this;
                $.ajax({
                    url: "{{url_for('spreadsheets.share')}}",
                    data: JSON.stringify({'spreadsheet_id': spreadsheet_id, 'row_index': vm.selected_row}),
                    dataType: "json",
                    contentType: "application/json",
                    type: 'POST',
                    success: function (response) {
                        let url = "{{url_for('spreadsheets.share', _external=True)}}/" + response['share'];
                        $("#share_url").val(url);
                        $('#share_popup').modal()
                    },
                    error: function (request) {
                        error_message = $.parseJSON(request.responseText).error;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    }
                });
            },

            shiftSpreadsheets: function () {
                // Shifts through the spreadsheets in order
                let spreadsheets = this.spreadsheets;
                let first = spreadsheets[0];
                let tail = spreadsheets.slice(1);
                this.spreadsheets = tail.concat(first);
            },

        },

        computed: {
            row_index: function() {
                if (this.sort_order !== null) {
                    return this.sort_order[this.selected_row];
                } else {
                    return this.selected_row;
                }

            },

            num_below: {
                get: function () {
                    return this.num_significant_below[this.selected_row];
                },
                set: function (val) {
                    val = parseInt(val);
                    if (val === null || this.num_significant_below === null) {
                        this.selected_row = 0;
                    }

                    let idx = this.num_significant_below.indexOf(val);
                    if (idx !== -1) {
                        this.selected_row = idx;
                    } else {
                        if (idx > Math.max(null, this.num_significant_below)) {
                            this.selected_row = this.num_siginificant_below.length;
                        } else {
                            this.selected_row = 0;
                        }
                    }
                }
            },

            sort_function: function () {
                // We sort by the value specified in sort_by
                // We also have a 'secondary sort value' which is used purely as a null/not-null check
                // So if secondary sort value is null then we will sort the value to the end as if the main value were null
                // This solves the problem where q-values are null and being sorted to the front of the list particulary
                // from filters re-running q-values (which nulls them if filtered) and then being viewed without that filter
                let vm = this;
                let sorter = null;
                let value = null;
                let secondary_value = null;

                if (this.sort_by.stat.sort_value !== undefined) {
                    value = this.sort_by.stat.sort_value;
                    if (this.sort_by.stat.secondary_sort_value !== undefined) {
                        secondary_value = this.sort_by.stat.secondary_sort_value;
                    } else {
                        secondary_value = value;
                    }
                } else if (typeof this.sort_by.stat.value === 'string') {
                    value = this.sort_by.stat.value;
                    secondary_value = value;
                } else {
                    value = this.sort_by.stat.value.p;
                    secondary_value = this.sort_by.stat.value.q;
                }

                let sort_direction = 1;
                if (this.sort_by.stat.sort_direction !== undefined) {
                    sort_direction = this.sort_by.stat.sort_direction;
                }

                if (vm.sort_by.spreadsheet_num !== undefined) {
                    sorter = function (i,j) {
                        let a = vm.spreadsheets[vm.sort_by.spreadsheet_num][secondary_value][i] &&
                                    vm.spreadsheets[vm.sort_by.spreadsheet_num][value][i];
                        let b = vm.spreadsheets[vm.sort_by.spreadsheet_num][secondary_value][j] &&
                                    vm.spreadsheets[vm.sort_by.spreadsheet_num][value][j];
                        return compare(a ? a * sort_direction : a, // multiply by +/- 1 but not if null
                                       b ? b * sort_direction : b,
                                       i, j);
                    };
                } else {
                    sorter = function (i,j) {
                        let a = vm.stats[secondary_value][i]
                                    && vm.stats[value][i];
                        let b = vm.stats[secondary_value][j]
                                    && vm.stats[value][j];
                        return compare(a ? a * sort_direction : b, // multiply by +/- 1 but not if null
                                       b ? b * sort_direction : b,
                                       i, j);
                    };
                }

                return sorter;
            },

            sort_order: function () {
                let vm = this;

                let sort_order =  this.labels.map( function(x,i) {return i;} );
                sort_order = sort_order.sort(this.sort_function);

                if (this.hide_filtered_rows) {
                    // Move filtered items from the sort_order to the back of the list  to hide them
                    let head = sort_order.filter( function(x) {return !vm.filtered[x];});
                    let tail = sort_order.filter( function(x) {return vm.filtered[x];});
                    sort_order = head.concat(tail);
                }

                return sort_order;
            },

            label_qs: function () {
                let value = this.sort_by.stat.value;

                if (typeof value === 'string') {
                    // No inherent q-value for this sort value
                    // we default to Nitecap of primary spreadsheet
                    return this.spreadsheets[0] ? this.spreadsheets[0].ps : [];
                }

                if (this.sort_by.spreadsheet_num !== undefined) {
                    let sp = this.spreadsheets[this.sort_by.spreadsheet_num];
                    let vq = value.q;
                    let vals = sp ? sp[vq]: [];
                    return vals;
                    return this.spreadsheets[this.sort_by.spreadsheet_num][value.q];
                } else {
                    return this.stats[value.q];
                }
            },

            filtered: function () {
                let vm = this;
                let filtered_out = this.labels.map( function (x) {return false;} );

                // Apply all filters
                this.last_used_filters.forEach(function(filter) {
                    let filter_value = filter.variable;

                    let lower_bound = parseFloat(filter.lower_bound);
                    let upper_bound = parseFloat(filter.upper_bound);

                    if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                    if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                    let idx = vm.filter_data_list.map(function(filter) {return filter.key;} ).indexOf(filter_value);
                    let values = vm.filter_data_list[idx].values();
                    filtered_out = filtered_out.map( function (x,i) {
                        return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                    });
                });

                return filtered_out;
            },

            num_significant_below: function() {
                // Recompute the number of signifcant items below a cutoff
                // discards filtered out rows
                let num_significant_below = new Array(this.labels.length);
                let ctr = 0;
                this.labels.forEach(function(label, index) {
                    if (!app.filtered[app.sort_order[index]]) {
                        ctr++;
                    }

                    num_significant_below[index] = ctr;
                });
                return num_significant_below;
            },

            selected_rows: function() {
                // List of indices of the rows that are selected
                // (I.e. unfiltered, and below the significance cutoff
                let vm = this;

                return vm.sort_order.filter( function(row_num,rank) {
                    return (rank <= vm.selected_row) & (!vm.filtered[row_num]);
                } );
            },

            useable_stats: function () {
                // Only the stats from stats_list that apply to this context
                // i.e. the ones we have enough spreadsheets for
                let vm = this;
                return this.stats_list.filter( function(stat) {
                    if (stat.num_spreadsheets == 'multi') {
                        return vm.spreadsheets.length > 1;
                    } else {
                        return true;
                    }
                });
            },

            filter_data_list: function () {
                // List of filters including the 'special' ones declared in filters_data_list_base
                // and also those derived from the statistics in stats_list
                let vm = this;

                // Make a filter for each stat
                let stat_filters = [];
                vm.useable_stats.forEach( function (stat) {
                    if (stat.per_spreadsheet) {
                        let just_one = vm.spreadsheets.length === 1;
                        vm.spreadsheets.forEach( function(spreadsheet, idx) {
                            if (typeof stat.value === 'string') {
                                let name = stat.name + ' ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value];},
                                     independent: false,
                                     key: name
                                });
                            } else {
                                let name = stat.name + ' p ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.p];},
                                     independent: false,
                                     key: name
                                });

                                name = stat.name + ' q ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.q];},
                                     independent: false,
                                     key: name
                                });
                            }
                        });
                    } else {
                        if (typeof stat.value === 'string') {
                            stat_filters.push({
                                 name: stat.name,
                                 values: function () {return vm.stats[stat.value];},
                                 independent: false,
                                 key: stat.name
                            });
                        } else {
                            stat_filters.push({
                                 name: stat.name + ' p',
                                 values: function () {return vm.stats[stat.value.p];},
                                 independent: false,
                                 key: stat.name + ' p',
                            });

                            stat_filters.push({
                                 name: stat.name + ' q',
                                 values: function () {return vm.stats[stat.value.q];},
                                 independent: false,
                                 key: stat.name + ' q',
                            });
                        }
                    }

                });

                // Return all filters, including the 'base' ones and the ones derived from our statistics
                return filter_data_list_base.concat(stat_filters);
            },

            spreadsheet_ids: function() {
                return this.spreadsheets.map( function(spreadsheet) {return spreadsheet.spreadsheet_id;});
            },

            timepoint_labels: function() {
                // Labels to use for timepoints 0,1,2,...,timepoints_per_day-1
                // ignoring the cycle/day number
                let vm = this;

                return vm.spreadsheets.map( function(spreadsheet) {
                    let times = spreadsheet.x_label_values.filter(function(t) {
                        if (t < spreadsheet.timepoints_per_day) {
                            return 1;
                        } else {
                            return 0;
                        }
                    });

                    // Try to infer if possible from column headers
                    let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                    if (inferred !== null) {
                        let headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t, true);
                        });
                        let labels = [];
                       times.forEach( function (time,i) {
                            if (labels[time] === undefined) {
                                labels[time] = headings[i];
                            }
                        });
                        return labels;
                    }

                    // Otherwise we default to "Timepoint 1", etc.
                    return times.map( function(time) {
                        return "Timepoint " + (time + 1);
                    });
                });
            },

            day_and_time_labels: function() {
                // Labels to use for Day 1 Timepoint 1, etc.
                let vm = this;

                return vm.spreadsheets.map( function(spreadsheet) {
                    let times = spreadsheet.x_values;

                    // Try to infer if possible from column headers
                    let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                    if (inferred !== null) {
                        let headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t);
                        });
                        let labels = [];
                       times.forEach( function (time,i) {
                            if (labels[time] === undefined) {
                                labels[time] = headings[i];
                            }
                        });
                        return labels;
                    }

                    return times.map( function(time) {
                        return "Day " + (Math.floor(time / spreadsheet.timepoints_per_day) + 1) + " Timepoint " + (time % spreadsheet.timepoints_per_day + 1);
                    });
                });
            },

            descriptive_names: function() {
                // Descriptive names for spreadsheets
                // They are given descriptive names already but we want to isolate the part that is 'variable' between them
                // for easier display
                let names = this.spreadsheets.map( function(x) {return x.descriptive_name;});

                if (names.length < 2) {
                    // Can't simplify anything if there is only one!
                    return names;
                }

                let split_names = names.map( function(x) { return x.split(" ");});

                // Find the common prefix for all the names
                // eg names "Tom Dataset WT" and "Tom Dataset KO"
                // have prefix ["Tom", "Dataset"]
                let prefix = split_names[0];
                split_names.forEach(function(split_name) {
                    let no_mismatch_yet = true;
                    prefix = prefix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                });

                // Same as above, but find the common suffix for all the names
                let suffix = split_names[0].slice(0).reverse();
                split_names.forEach(function(split_name) {
                    split_name.reverse();
                    let no_mismatch_yet = true;
                    suffix = suffix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                    split_name.reverse(); // put it back
                });
                suffix = suffix.reverse();

                // Re-build the names with the prefix and suffix removed
                names = split_names.map( function(split_name) {
                    return split_name.slice(prefix.length, split_name.length - suffix.length).join(" ");
                });
                return names;
            },
        },

        watch: {
            row_index: "onRowChange",

            "plot.config": {
                handler: "redrawPlot",
                deep: true
            },
        },
    });
</script>
{% endblock %}
