{% extends "base.html" %}

{% block content %}


<!-- temporary inlining of Vue.JS dev version -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>
    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    });

    PCA_WIDTH = 800;
    PCA_HEIGHT = 800;
    PCA_SYMBOL = "M 0,-15 A 15,15 0 0,1 15,0 L 0,0 Z M 15,0 A 15,15 0 0,1 -15,0 A 15,15 0 0,1 0,-15 L 0,-10 A 10,10 0 0,0 -10,0 A 10,10 0 0,0 10,0";

    $(document).ready(function () {

        spreadsheet_ids = {{ spreadsheet_ids | safe }};

        $.ajax({
            url: "get_spreadsheets",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                onSpreadsheetLoad(response);
            },
            error: function(error) {
                console.log("Error loading spreadsheets");
                console.log(error);
            }
        });
    });

    function onSpreadsheetLoad(spreadsheets) {
        // FOR VUE
        spreadsheets.forEach(function(spreadsheet) {
            spreadsheet.upside_ps = null;
            spreadsheet.upside_qs = null;

            // VUE PERF NOTE
            // Vue "observes" all attributes of observed objects
            // so it will try to observe everything in the large data arrays
            // however we do not need reactivity for those arrays since they don't change
            // Here we disable adding new elements to them which causes Vue to not observe every element in the array
            // Note that the arrays themselves are still observed in the sense that doing spreadsheet.tds = <new array>
            // will propagate changes that depend on spreadsheet.tds
            Object.keys(spreadsheet).forEach(function(key){
                if (Array.isArray(spreadsheet[key])) {
                    Object.preventExtensions(spreadsheet[key]);
                }
            });
        });

        app.spreadsheets = spreadsheets;
        app.labels = spreadsheets[0].labels;
        app.timepoints_per_day = app.spreadsheets[0].timepoints_per_day;
        app.num_days = (Math.max.apply(null, spreadsheets[0].x_values) + 1) / spreadsheets[0].timepoints_per_day;

        function makeCoarseSlider(element, start_value, maximum) {
            element.slider({
                orientation: "horizontal",
                min: 0,
                value: start_value,
                step: 1,
                max: maximum,
                range: "min",
                slide: function (event, ui) {
                    app.selected_row = ui.value;
                }
            });
        }

        makeCoarseSlider($('#coarse_slider'), 0, app.labels.length - 1);


        // Load the JTK values for each spreadsheet
        $.ajax({
            url: "jtk",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                let jtk_ps = response['jtk_ps'];
                let jtk_qs = response['jtk_qs'];

                // Find the right spreadsheets and put each jtk_ps/qs into it
                spreadsheet_ids.forEach(function(id, i) {
                    app.spreadsheets.forEach(function(spreadsheet) {
                        if (spreadsheet.spreadsheet_id == id) {
                            // For Vue performance see VUE PERF NOTE
                            Object.preventExtensions(jtk_ps[i]);
                            Object.preventExtensions(jtk_qs[i]);
                            spreadsheet.jtk_ps = jtk_ps[i];
                            spreadsheet.jtk_qs = jtk_qs[i];
                        }
                    });
                });
            },
            error: function(error) {
                console.log("Error loading JTK values");
                console.log(error);
            }
        });

        // Load the Upside values
        if (app.spreadsheets.length > 1) {
            $.ajax({
                url: "get_upside",
                data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
                dataType: 'text json',
                contentType: 'application/json',
                type: 'POST',
                success: function(response) {
                    // See VUE PERF NOTE
                    // Make all arrays non-traversed by Vue for performance
                    Object.keys(response).forEach(function(key) {
                        Object.preventExtensions(response[key]);
                    });

                    upside_ps = response['upside_ps'];
                    upside_qs = response['upside_qs'];

                    app.spreadsheets.forEach(function(spreadsheet, idx){
                        Object.preventExtensions(upside_ps[idx]); // See VUE PERF NOTE
                        Object.preventExtensions(upside_qs[idx]); // these aren't covered by above since are one level deeper
                        spreadsheet.upside_ps = upside_ps[idx];
                        spreadsheet.upside_qs = upside_qs[idx];
                    });

                    app.stats.two_way_anova_ps = response['two_way_anova_ps'];
                    app.stats.two_way_anova_qs = response['two_way_anova_qs'];
                    app.stats.phase_ps = response['phase_ps'];
                    app.stats.phase_qs = response['phase_qs'];
                    app.stats.amplitude_ps = response['amplitude_ps'];
                    app.stats.amplitude_qs = response['amplitude_qs'];

                },
                error: function(error) {
                    console.log("Error loading upside values");
                    console.log(error);
                    response = error.responseText;
                }
            });
        }
    }
</script>

{% raw %}

<div id="vue-app">


<div id="comparison-graph-page" class="page-header">
    <h1>Spreadsheet Comparison</h1>
</div>

<p id="spreadsheet-comparison-page">
    <div class="row">
        <p class="col-lg-12 h3" v-if="spreadsheets[1]" v-cloak>
            {{spreadsheets[0].descriptive_name}} vs. {{spreadsheets[1].descriptive_name}}

            <a v-bind:href="'download_comparison/'+spreadsheets[0].spreadsheet_id+','+spreadsheets[1].spreadsheet_id"
                    class="mx-3" download="processed_file.txt">
                <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
            </a>
        </p>

        <p class="col-lg-12 h3" v-if="spreadsheets.length === 1">
            {{spreadsheets[0].descriptive_name}}
            <a v-bind:href="'download?spreadsheet_id='+spreadsheets[0].spreadsheet_id" class="mx-3" download="processed_file.txt">
                <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
            </a>
            <a v-bind:href="'collect_data?spreadsheet_id='+spreadsheets[0].spreadsheet_id">
                <i class="fas fa-edit" data-toggle="tooltip" data-placement="top" title="Edit"></i>
            </a>
            <a id='share_spreadsheet' href="#">
                <i class="fas fa-share-square" data-toggle="tooltip" data-placement="top" title="Share"></i>
            </a>
        </p>
    </div>
    <div class="row">
        <span class="form-group col-lg-9">
            Number of selected rows:
            <input type="number" v-model="num_below"></input>
        </span>
    </div>


    <div class="row">
        <div class="col">
            <div id="coarse_slider" class="coarse-slider"></div>
        </div>
    </div>

    <div class="row">
        <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
    </div>

    <div class='row'>
        <span class='col-auto'>
            <div class='row'>
                <div class="col">
                    <div class="input-group mb-2">
                        <input class="form-control form-control-sm" type="text" name="row_search"
                               placeholder="Search for row by label" v-model="search_value"
                               v-on:keyup.enter="searchRows"/>
                        <div class="input-group-append">
                            <button type="button" class="btn btn-secondary btn-sm"
                                    v-on:click="searchRows">
                                Search
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class='row'>
                <div class='col-auto'>
                    <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
                    <row-selector v-bind:sort-order="sort_order"
                                  v-bind:filtered="filtered"
                                  v-bind:num-rows="21"
                                  v-bind:q-values="spreadsheets[0] ? spreadsheets[0].qs : []"
                                  v-bind:selected-row="selected_row"
                                  v-bind:labels="labels"
                                  v-bind:label-max-length="35"
                                  v-bind:select-row="selectRow"
                                  v-cloak>
                    </row-selector>
                    <div class="form-check">
                        <input class="form-check-input" id="hide_filtered" type="checkbox" v-model="hide_filtered_rows">
                        <label class="form-check-label" for="hide_filtered">Hide filtered rows</label>
                    </div>
                </div>
            </div>
            <div class='p-3'>
                <button class="btn btn-primary" v-on:click="downloadPlot">Download Plot</button>
            </div>
        </span>
        <div class='col-auto'>
            <span id="scatter_plot" style="width:625px;height:525px;vertical-align: top"></span>
            <form class="form-group">
                <div class="form-inline">
                    <label for="plot_style_select">Plot style</label>
                    <select id="plot_style_select" value="basketweave" class="form-control form-control-sm" v-model="plot.config.style">
                        <option value="basketweave">Basketweave</option>
                        <option value="points">Points</option>
                        <option value="mean">Mean only</option>
                        <option value="mean_points">Points and Mean</option>
                        <option value="std">Standard Deviations</option>
                        <option value="SEM">SEM</option>
                    </select>
                </div>
                <div class="form-inline">
                    <label for="plot_x_label_style">Plot x-axis labels</label>
                    <select id="plot_x_label_style" class="form-control form-control-sm" v-model="plot.config.x_label_style">
                        <option value="daytime" selected>Day and time</option>
                        <option value="time">Time of day</option>
                        <option value="infer">Inferred labels</option>
                        <option value="infer_wrapped">Inferred labels wrapping</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="form-check" id="fold_days_box" v-if="num_days > 1">
                    <input class="form-check-input" id="fold_days_checkbox" type="checkbox" v-model="plot.config.fold_days">
                    <label class="form-check-label" for="fold_days_checkbox">Overlay cycles</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" id="include_zero_checkbox" type="checkbox" v-model="plot.config.include_zero">
                    <label class="form-check-label" for="include_zero_checkbox">Include zero</label>
                </div>
            </form>
            <button class="btn btn-primary mt-2" v-on:click="cycleSpreadsheets">Toggle Primary Plot</button>
            <span>Currently: <span id="primary_plot_name" v-cloak>{{spreadsheets[0] ? spreadsheets[0].descriptive_name : "loading"}}</span></span>
        </div>

        <div class="col-auto">
            <div class="card">
                <div class="card-header">
                    Statistics
                    <a id="statsHelp" class="text-primary help-pointer"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Statistics Help"
                       data-content="Displays statistics about the selected row. JTK values are calculated on first page load and may a take a minute.">
                        <i class="fas fa-info-circle ml-3"></i>
                    </a>
                </div>
                <div class="card-body">
                    <label for="sort_select">Sort by:</label>
                    <select id="sort_select" class="form-control form-control-sm"
                            v-model="sort_variable">
                         <option value="nitecap">Nitecap</option>
                         <option value="jtk" v-bind:disabled="spreadsheets.length == 0 || spreadsheets[0].jtk_ps === null">JTK</option>
                         <option value="anova">ANOVA</option>
                         <option value="amplitude">Amplitude</option>
                         <option value="upside" v-bind:disabled="spreadsheets.length == 0 || spreadsheets[0].updside_ps === null">Damping</option>
                         <option value="two_way_anova" v-bind:disabled="stats.two_way_anova_ps === null">Two-way ANOVA</option>
                         <option value="phase_change" v-bind:disabled="stats.phase_ps === null">Phase Difference</option>
                         <option value="amplitude_change" v-bind:disabled="stats.amplitude_ps === null">Amplitude Difference</option>
                    </select>
                    <table class="table table-sm">
                        <thead>
                            <tr v-if="spreadsheets.length > 1">
                                <th scope="col"></th>
                                <th scope="col">Primary</th>
                                <th scope="col">Secondary</th>
                            </tr>
                        </thead>
                        <tbody v-if="spreadsheets !== null">
                            <template v-for="stat in useable_stats">
                                <tr>
                                    <td v-bind:rowspan="typeof stat.value === 'string' ? 1 : 2">
                                        {{stat.name}}
                                        <a class="text-primary help-pointer float-right"
                                            data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                            v-bind:title="stat.name"
                                            v-bind:data-content="stat.description">
                                            <i class="fas fa-info-circle ml-3"></i>
                                        </a>
                                    </td>

                                    <template v-if="typeof stat.value === 'string'">
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="spreadsheet in spreadsheets">
                                                <td v-if="spreadsheet[stat.value] != null"
                                                    v-bind:title="String(spreadsheet[stat.value][row_index])">
                                                    {{util.formatNum(spreadsheet[stat.value][row_index], 4)}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value] != null"
                                                v-bind:title="String(stats[stat.value][row_index])"
                                                v-bind:colspan="spreadsheets.length">
                                                {{util.formatNum(stats[stat.value][row_index], 4)}}
                                            </td>
                                            <td v-else>
                                                loading
                                            </td>
                                        </template>
                                    </template>

                                    <template v-else>
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="spreadsheet in spreadsheets">
                                                <td v-if="spreadsheet[stat.value.p] != null"
                                                    v-bind:title="String(spreadsheet[stat.value.p][row_index])">
                                                    p: {{util.formatNum(spreadsheet[stat.value.p][row_index], 4)}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value.p] != null"
                                                v-bind:title="String(stats[stat.value.p][row_index])"
                                                v-bind:colspan="spreadsheets.length">
                                                p: {{util.formatNum(stats[stat.value.p][row_index], 4)}}
                                            </td>
                                            <td v-else v-bind:colspan="spreadsheets.length">
                                                loading
                                            </td>
                                        </template>
                                    </template>
                                </tr>

                                <tr v-if="typeof stat.value !== 'string'">
                                    <template v-if="stat.per_spreadsheet">
                                        <template v-for="spreadsheet in spreadsheets">
                                            <td v-if="spreadsheet[stat.value.q] != null"
                                                v-bind:title="String(spreadsheet[stat.value.q][row_index])">
                                                q: {{util.formatNum(spreadsheet[stat.value.q][row_index], 4)}}
                                            </td>
                                            <td v-else>
                                                loading
                                            </td>
                                        </template>
                                    </template>
                                    <template v-else>
                                        <td v-if="stats[stat.value.q] != null"
                                            v-bind:title="String(stats[stat.value.q][row_index])"
                                            v-bind:colspan="spreadsheets.length">
                                            q: {{util.formatNum(stats[stat.value.q][row_index], 4)}}
                                        </td>
                                        <td v-else v-bind:colspan="spreadsheets.length">
                                            loading
                                        </td>
                                    </template>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <div class="row">
        <div id="FiltersCard" class="col-auto" v-on:keyup.enter="applyFilters">
            <div class="card">
                <div class="card-header">
                    Filters
                    <a id="filtersHelp" class="text-primary help-pointer"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Filter Help"
                       data-content="Keep only rows matching the criteria provided. Rerunning the q-values computes q-values using only the unfiltered genes. This is statistically invalid to do if filtering on most criteria (eg: if filtering p-values or q-values, one should not rerun the q-values). Instead, only rerun q-values when filtering exclusively on time-unaware criteria (such as max value).">
                        <i class="fas fa-info-circle ml-3"></i>
                    </a>
                </div>
                <div class="card-body">
                    <div id="filter_list">
                        <div v-for="(filter, index) in filters" class="row"
                            :key="filter.id">
                            <div class='col form-inline filter_item'>
                                <input class="form-control form-control-sm m-1 filter-lower-bound" style="width: 85px"
                                     v-bind:aria-label="'Lower bound for filter ' + index"
                                     v-model="filter.lower_bound">
                                </input>

                                &le;

                                <select class="form-control form-control-sm m-1 filter_value_selector"
                                        v-bind:aria-label="'Filter selector for filter ' + index"
                                        v-model="filter.variable">
                                    <option v-for="filter_data in filter_data_list"
                                            v-bind:value="filter_data.key">
                                            {{filter_data.name}}
                                    </option>
                                </select>

                                &le;

                                <input class="form-control form-control-sm m-1 filter-upper-bound" style="width: 85px"
                                     v-bind:aria-label="'Upper bound for filter ' + index"
                                     v-model="filter.upper_bound">
                                </input>

                                <button class="btn btn-default" v-bind:aria-label="'Remove filter ' + index" title="Remove filter"
                                        v-on:click="filters = filters.filter(function(x,j) {return j !== index;})">
                                    <span class="far fa-minus-square"> </span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <button id="reset_filters_button" class="btn btn-default" aria-label="Reset filters"
                        v-on:click="resetFilters">
                        <span class="fas fa-undo" title="Reset filters" data-toggle="tooltip" data-placement="top"></span>
                    </button>
                    <button id="add_filter_button" class="btn btn-default" style="float: right" aria-label="Add filter"
                        v-on:click="addFilter">
                        <span class="far fa-plus-square" title="Add filter" data-toggle="tooltip" data-placement="top"></span>
                    </button>
                    <div>
                        <button id="applyFilters" type="button" class="btn btn-primary mb-4" v-on:click="applyFilters">Apply filters</button>
                        <button id="rerun_qvalues" type="button" class="btn btn-primary mb-4">Rerun q-values</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row" style="padding-top:2rem;padding-bottom:2rem">
        <span class="col-lg-5">
            <input type="hidden" id="row_index" name="row_index"/>
            <button class="btn btn-primary" v-on:click="updateHeatmap">Generate Heatmap</button>
        </span>
    </div>

    <div class="row">
        <div class="col card" id="heatmap_block" v-show="heatmap.rendered">
            <div class="card-body">
                <span class="col-lg-12">Number of items in heatmap: {{heatmap.labels.length}}</span>
                <div id="heatmap"></div>
                <span class="col-lg-5">
                    <div class="form-check">
                        <input class="form-check-input" id="combine_replicates" type="checkbox" v-model="heatmap.config.combine_replicates">
                        <label class="form-check-label" for="combine_replicates">Combine replicates</label>
                    </div>

                    <div class="form-check" v-if="num_days > 1">
                        <input class="form-check-input" id="heatmap_fold_days" type="checkbox" v-model="heatmap.config.fold_days">
                        <label class="form-check-label" for="heatmap_fold_days">Overlay cycles</label>
                    </div>

                    <div class="form-check">
                        <input class="form-check-input" id="heatmap_show_labels" type="checkbox" v-model="heatmap.config.show_labels">
                        <label class="form-check-label" for="heatmap_show_labels">Show row labels</label>
                    </div>
                </span>
                <span>
                    <button id="download_heatmap" class="btn btn-primary" v-on:click="downloadHeatmap">Download Heatmap</button>
                </span>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col card">
            <div class="card-body">
                <button id="run_pca" class="btn btn-primary"
                    v-bind:disabled="pca.running"
                    v-on:click="runPCA">
                    {{pca.running ? "Processing..." : "Run PCA"}}
                    <span v-if="pca.running" class='spinner-border spinner-border-sm text-light mr-2' role='status' aria-hidden='true'>
                    </span>
                </button>
                <span class="alert alert-error" v-if="pca.alert !== ''">{{pca.alert}}</span>

                <div id="pca_plot"></div>

                <span id="pca_controls" class="col" v-if="pca.rendered">
                    <span>log(x+1) Transform</span>
                    <label class="switch">
                        <input id="pca_logtransform" name="pca_logtransform" type="checkbox" v-model="pca.config.logtransform"/>
                        <span class="slider"></span>
                    </label>

                    <span for="pca_zscore">Z-Score Normalization</span>
                    <label class="switch">
                        <input id="pca_zscore" name="pca_zscore" type="checkbox" v-model="pca.config.zscore">
                        <span class="slider"></span>
                    </label>

                    <button id="download_pca" class="btn btn-primary" v-on:click="downloadPCA">Download PCA</button>
                </span>
            </div>
        </div>
    </div>


{% endraw %} <!-- TODO remove these raw tags when we are no longer using templating at all -->
</div>

<script src="{{url_for('static', filename='js/row_selector.js')}}"></script>

<script>
    Vue.prototype.filter_data_list = [
        {values: function () {
                         // Grand maximum across both datasets within each row
                         let maxes = app.spreadsheets.map(function (spreadsheet) {
                                return maximums(spreadsheet.data);
                         });
                         return maxes[0].map( function(row, i) {
                            return Math.max(maxes[0][i], maxes[1][i]);
                        });
                    },
                name: "Maximum value",
                independent: true,
                key:"max_value"},
        {values: function () {
                    // Grand means across both datasets within each row
                    // TODO: better support for missing values (different numbers missing in each spreadsheet)
                    let means = app.spreadsheets.map(function (spreadsheet) {
                        return means(spreadsheet.data);
                    });
                    let a = app.spreadsheets[0].data[0].length;
                    let b = app.spreadsheets[1].data[0].length;
                    return means[0].map( function(row, i) {
                        return (means[0][i]*a + means[1][i]*b) / (a + b);
                    });
                },
                name: "Mean value",
                independent: true,
                key: "mean_value"},
        {values: function () { return app.spreadsheets[0].ps; },
                name: "Nitecap p Primary",
                independent: false,
                key: "nitecap_p0"},
        {values: function () { return app.spreadsheets[0].qs; },
                name: "Nitecap q Primary",
                independent: false,
                key: "nitecap_q0"},
        {values: function () { return app.spreadsheets[0].jtk_ps; },
                name: "JTK p Primary",
                independent: false,
                key: "jtk_p0"},
        {values: function () { return app.spreadsheets[0].jtk_qs; },
                name: "JTK q Primary",
                independent: false,
                key: "jtk_q0"},
        {values: function () { return app.spreadsheets[0].anova_ps; },
                name: "ANOVA p Primary",
                independent: false,
                key: "anova_p0"},
        {values: function () { return app.spreadsheets[0].anova_qs; },
                name: "ANOVA q Primary",
                independent: false,
                key: "anova_q0"},
        {values: function () { return app.spreadsheets[0].amplitudes; },
                name: "Amplitude Primary",
                independent: false,
                key: "amplitude0"},
        {values: function () { return app.spreadsheets[0].peak_times; },
                name: "Peak time Primary",
                independent: false,
                key: "peaktime0"},
        {values: function () { return app.spreadsheets[1].ps; },
                name: "Nitecap p Secondary",
                independent: false,
                key: "nitecap_p1"},
        {values: function () { return app.spreadsheets[1].qs; },
                name: "Nitecap q Secondary",
                independent: false,
                key: "nitecap_q1"},
        {values: function () { return app.spreadsheets[1].jtk_ps; },
                name: "JTK p Secondary",
                independent: false,
                key: "jtk_p1"},
        {values: function () { return app.spreadsheets[1].jtk_qs; },
                name: "JTK q Secondary",
                independent: false,
                key: "jtk_q1"},
        {values: function () { return app.spreadsheets[1].anova_ps; },
                name: "ANOVA p Secondary",
                independent: false,
                key: "anova_p1"},
        {values: function () { return app.spreadsheets[1].anova_qs; },
                name: "ANOVA q Secondary",
                independent: false,
                key: "anova_q1"},
        {values: function () { return app.spreadsheets[1].amplitudes; },
                name: "Amplitude Secondary",
                independent: false,
                key: "amplitude1"},
        {values: function () { return app.spreadsheets[1].peak_times; },
                name: "Peak time Secondary",
                independent: false,
                key: "peaktime1"},
        {values:function () { return app.stats.two_way_anova_ps; },
                  name: "Two-way ANOVA p",
                  independent: false,
                  key: "two_way_anova_p"},
        {values:function () { return app.stats.two_way_anova_qs; },
                  name: "Two-way ANOVA q",
                  independent: false,
                  key: "two_way_anova_q"},
        {values:function () { return app.stats.phase_ps; },
                  name: "Phase difference p",
                  independent: false,
                  key: "phase_difference_q"},
        {values:function () { return app.stats.phase_qs; },
                  name: "Phase difference q",
                  independent: false,
                  key: "phase_difference_p"},
        {values:function () { return app.stats.amplitude_ps; },
                  name: "Amplitude difference p",
                  independent: false,
                  key: "amplitude_difference_p"},
        {values:function () { return app.stats.amplitude_qs; },
                  name: "Amplitude difference q",
                  independent: false,
                key: "amplitude_difference_q"}
    ];

    Vue.prototype.filter_data = new Map();
    Vue.prototype.filter_data_list.forEach( function(filter) {
        Vue.prototype.filter_data.set(filter.key, filter);
    });

    Vue.prototype.util = {
        formatNum: formatNum
    };

    Vue.prototype.sorters = {
        "nitecap": function(i,j) {
            let a = app.spreadsheets[0].tds[i];
            let b = app.spreadsheets[0].tds[j];
            return compare(a,b,i,j);
        },
        "anova": function (i,j) {
            // Sort anova p-values in ascending order
            let a = app.spreadsheets[0].anova_ps[i];
            let b = app.spreadsheets[0].anova_ps[j];
            return compare(a,b,i,j);
        },
        "jtk": function (i,j) {
            // Sort jtk p-values in ascending order
            let a = app.spreadsheets[0].jtk_ps[i];
            let b = app.spreadsheets[0].jtk_ps[j];
            return compare(a,b,i,j);
        },
        "amplitude": function (i,j) {
            // Sort amplitude values in descending order
            let a = -app.spreadsheets[0].amplitudes[i];
            let b = -app.spreadsheets[0].amplitudes[j];
            return compare(a,b,i,j);
        },
        "upside": function (i,j) {
            // Sort by ascending order
            let a = app.spreadsheets[0].upside_ps[i];
            let b = app.spreadsheets[0].upside_ps[j];
            return compare(a,b,i,j);
        },
        "two_way_anova": function (i,j) {
            // Sort by ascending order
            let a = app.stats.two_way_anova_ps[i];
            let b = app.stats.two_way_anova_ps[j];
            return compare(a,b,i,j);
        },
        "amplitude_change": function (i,j) {
            // Sort by ascending order
            let a = app.stats.amplitude_ps[i];
            let b = app.stats.amplitude_ps[j];
            return compare(a,b,i,j);
        },
        "phase_change": function (i,j) {
            // Sort by ascending order
            let a = app.stats.phase_ps[i];
            let b = app.stats.phase_ps[j];
            return compare(a,b,i,j);
        }
    };

    let app = new Vue({
        el: "#vue-app",
        data: {
            filters: [],
            last_used_filters: [],
            hide_filtered_rows: false,
            spreadsheets: [],
            selected_row: 0,
            sort_variable: "nitecap",

            search_value: '',

            stats: {
                amplitude_ps: null,
                amplitude_qs: null,
                phase_ps: null,
                phase_qs: null,
                two_way_anova_ps: null,
                two_way_anova_qs: null,
            },

            labels: [],
            timepoints_per_day: 0,
            num_days: 0,

            plot: {
                config: {
                    fold_days: false,
                    style: "mean_points",
                    x_label_style: "infer",
                    include_zero: false,
                },
                first_render: false,
            },

            stats_list: [
                {name: "Nitecap",
                 value: {p: "ps",
                         q: "qs"},
                  description: "Nitecap significance of rhythmicity for primary dataset.",
                 per_spreadsheet: true,
                 num_spreadsheets:'any'},
                {name: "JTK",
                 value: {p: "jtk_ps",
                         q: "jtk_qs"},
                 description: "JTK_cycle significance of rhythmicity for primary dataset.",
                per_spreadsheet: true,
                num_spreadsheets:'any'},
                {name: "ANOVA",
                 value: {p: "anova_ps",
                         q: "anova_qs"},
                 description: "1-Way ANOVA on primary dataset. If there are no replicates on timepoints, ANOVA cannot be run.",
                 per_spreadsheet: true,
                 num_spreadsheets: 'any'},
                {name: "Damping",
                 value: {p: "upside_ps",
                         q: "upside_qs"},
                 description: "Damping analysis giving significance of a decrease in variation in the secondary dataset compared to the first.",
                 per_spreadsheet: true,
                 num_spreadsheets: 'multi'},
                {name: "Two-way ANOVA",
                 value: {p: "two_way_anova_ps",
                         q: "two_way_anova_qs"},
                 description: "Two-way ANOVA test for difference in timepoint-effects across datasets",
                 per_spreadsheet: false,
                 num_spreadsheets: 'multi'},
                {name: "Phase Difference",
                 value: {p: "phase_ps",
                         q: "phase_qs"},
                 description: "Test for equality of phase between datasets through cosinor analysis (least squares fit)",
                 per_spreadsheet: false,
                 num_spreadsheets: 'multi'},
                {name: "Amplitude Difference",
                 value: {p: "amplitude_ps",
                         q: "amplitude_qs"},
                 description: "Test for equality of amplitudes between datasets through cosinor analysis (least squares fit)",
                 per_spreadsheet: false,
                 num_spreadsheets: 'multi'},
                {name: "Amplitude",
                 value: "amplitudes",
                 description: "Amplitude of the variation.",
                 per_spreadsheet: true,
                 num_spreadsheets: 'any'},
                {name: "Peak-time",
                 value: "peak_times",
                 description: "Time the peak value occurs at. The units are the numbers of the timepoints, i.e. 3.5 means half-way between timepoint 3 and timepoint 4.",
                 per_spreadsheet: true,
                 num_spreadsheets: 'any'},
            ],

            heatmap: {
                cutoff: 0,
                rendered: false,
                data: [],
                x_values: [],
                x_labels: [],
                labels: [],
                config: {
                    fold_days: false,
                    combine_replicates: false,
                    show_labels: false,
                },
            },

            pca: {
                config: {
                    logtransform: false,
                    zscore: true,
                },
                rendered: false,
                running: false,
                alert: '',
            },
        },

        methods: {
            resetFilters: function(){
                this.filters = this.last_used_filters.slice();
            },

            addFilter: function(){
                let new_id = 0; // Make filter keys
                if (this.filters.length > 0){
                    new_id  = Math.max.apply(null, this.filters.map( function(filter) {
                        return filter.id;
                    }))  + 1;
                }
                this.filters.push( {variable: 'max_value', lower_bound:'', upper_bound:'', id: new_id} );
            },

            applyFilters: function() {
                // Copy the filters that we last ran
                // last_used_filters are the ones we actually filter on
                // needs to be deep copy so we json-ify it and back
                this.last_used_filters = JSON.parse(JSON.stringify(this.filters));
            },

            redrawPlot: function() {
                let vm = this;
                // Update the Plotly plots of the feature profiles
                let traces = [];
                let colors = Plotly.d3.scale.category10();
                vm.spreadsheets.forEach(function (spreadsheet, idx) {
                    let row_index = vm.sort_order[vm.selected_row];
                    raw_y_values = spreadsheet.data[row_index];
                    if (raw_y_values === undefined) {
                        console.log("Could not find the y-values for row " + row_index);
                        return;
                    }

                    if (vm.plot.config.fold_days) {
                        plot_x_values = spreadsheet.x_values.map(function (x) {return x % spreadsheet.timepoints_per_day;});
                        plot_x_labels = plot_x_values.map(function(x) {return "Timepoint " + (x+1);});
                        plot_x_label_values = plot_x_labels.map(function(x,i) {return i;});
                    } else {
                        plot_x_values = spreadsheet.x_values;
                        plot_x_labels = spreadsheet.x_labels;
                        plot_x_label_values = spreadsheet.x_label_values;
                    }

                    let x_label_style = vm.plot.config.x_label_style;
                    if (x_label_style === 'none') {
                        plot_x_labels = plot_x_labels.map( function (x) {return '';} );
                    } else if (x_label_style === 'time') {
                        plot_x_labels = plot_x_labels.map( function(x,i) {
                            return "Timepoint " + (i % spreadsheet.timepoints_per_day + 1);
                        });
                    } else if (x_label_style === 'infer') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t);
                            });
                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    } else if (x_label_style === 'infer_wrapped') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t, true);
                            });

                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    }

                    let stats = rowStatsByTimepoint(raw_y_values, plot_x_values);

                    // Pick a color for this spreadsheet using Plotly's defaults from d3
                    let spreadsheet_color = colors(idx);
                    let marker_settings = {size: 12, symbol: 'circle-open'};


                    // Default values for the different plot styles to override
                    let trace = {
                        x: plot_x_values, y: raw_y_values,
                        mode: 'markers',
                        marker: marker_settings,
                        name: spreadsheet.descriptive_name,
                        type: 'scatter',
                        'marker': {color: spreadsheet_color},
                        'line': {color: spreadsheet_color}
                    };

                    // Pick data and styling based off the plot_style_select value
                    let plot_style = vm.plot.config.style;
                    if (plot_style === "basketweave") {
                        // Make pairs of points that are adjacent in time to each other, for each dataset
                        column_pairs = [];
                        plot_x_values.forEach( function(x,i) {
                            for(let j = i+1; j < plot_x_values.length; j++) {
                                if (Math.abs(plot_x_values[j] - x) === 1) {
                                    column_pairs.push([i,j]);
                                }
                            }
                        });

                        paired_y_values = [];
                        for (let i in column_pairs) {
                            paired_y_values.push(raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null);
                        }

                        paired_x_values = [];
                        for (let i in column_pairs) {
                            paired_x_values.push(plot_x_values[column_pairs[i][0]], plot_x_values[column_pairs[i][1]], null);
                        }

                        trace.mode = 'lines+markers';
                        trace.x = paired_x_values;
                        trace.y = paired_y_values;
                    } else if (plot_style === "points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                    } else if (plot_style === "mean") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                    } else if (plot_style === "mean_points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        traces.push({ // The mean value trace
                            x: stats.means.map( function (x,i) {return i;} ), // Just 0,1,2,3...
                            y: stats.means,
                            type: "scatter",
                            mode: "lines",
                            showlegend: false,
                            'line': {color: spreadsheet_color}
                        });
                    } else if (plot_style === "std") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                    } else if (plot_style === "SEM") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                    }

                    traces.push(trace);

                });

                let layout = {
                    hovermode: 'closest',
                    title: app.labels[app.sort_order[app.selected_row]],
                    legend: { orientation: 'h', y: -0.2 },
                    xaxis: {
                        ticktext: plot_x_labels,
                        tickvals: plot_x_label_values,
                        automargin: true,
                    },
                    yaxis: {
                        rangemode: vm.plot.config.include_zero ? 'tozero' : '',
                    }
                };

                if (vm.first_render) {
                    Plotly.newPlot('scatter_plot', traces, layout);
                    vm.first_render = false;
                } else {
                    Plotly.react('scatter_plot', traces, layout);
                }
            },

            downloadPlot: function() {
                let gd = document.getElementById('scatter_plot');
                Plotly.downloadImage(gd, {format: 'svg', filename: 'plot_' + (app.selected_row+1)});
            },


            updateHeatmap: function() {
                let vm = this;
                vm.heatmap.cutoff = vm.num_significant_below[vm.selected_row];

                let selected_indexes = vm.sort_order.filter( function(row_num,rank) {
                    return (rank <= vm.selected_row) & (!vm.filtered[row_num]);
                } );

                let phase_sorted_order = selected_indexes.sort( function (i,j) {
                    return compare(vm.spreadsheets[0].peak_times[i], vm.spreadsheets[0].peak_times[j], i,j);
                } );

                let zScoreData = vm.spreadsheets.map(function(spreadsheet) {
                    return computeZScores(phase_sorted_order)(spreadsheet.data);
                });

                let times = vm.spreadsheets.map(function(spreadsheet){ return spreadsheet.x_values; });

                if (vm.heatmap.config.fold_days) {
                    times = vm.spreadsheets.map(function(spreadsheet) {
                        return spreadsheet.x_values.map(function(x) {
                            return x % spreadsheet.timepoints_per_day;
                        });
                    });
                }

                vm.heatmap.labels = phase_sorted_order.map( function(i) {
                    return vm.labels[i];
                } );

                let heatmap_options = {
                    modeBarButtonsToAdd: [{
                        name: 'download in SVG format',
                        icon: Plotly.Icons.camera,
                        click: function (gd) {
                            Plotly.downloadImage(gd, {format: 'svg'})
                        }
                    }]
                };


                if (vm.heatmap.config.combine_replicates) {
                    // Average all z-scores at the same timepoint together
                    let meanZScores = zScoreData.map( function(zscores,idx) {
                        return meanByTimepoints(zscores, times[idx]);
                    });

                    vm.heatmap.data = meanZScores;

                    if (vm.heatmap.config.fold_days) {
                        vm.heatmap.x_values = meanZScores.map( function (zscores) {
                            return zscores[0].map( function(x,i) {return "Timepoint " + (i + 1);});
                        });
                    } else {
                        vm.heatmap.x_values = vm.spreadsheets.map( function(spreadsheet) {return spreadsheet.x_labels;} );
                    }
                } else {
                    if (vm.heatmap.config.fold_days) {
                        let x_sort_order = times.map( function(times_) {
                            return times_.map( function(x,i) {return i;} ).sort( function (i,j) {
                                return compare(times_[i],times_[j],i,j);
                            } );
                        });

                        vm.heatmap.data = zScoreData.map( function(zscores,idx) {
                            return zscores.map( function(row) {
                                return x_sort_order[idx].map( function(i) {
                                    return row[i];
                                });
                            } );
                        });

                        let rep_counts = [];
                        vm.heatmap.x_values = x_sort_order.map( function(x_sort_order_, idx) {
                            return x_sort_order_.map( function(i) {
                                let time = times[idx][i];
                                if (rep_counts[time] === undefined) {
                                    rep_counts[time] = 0;
                                }
                                rep_counts[time] += 1;

                                return "Timepoint " + (time + 1) + " Rep " + rep_counts[time];
                            });
                        });
                    } else {
                        vm.heatmap.data = zScoreData;

                        vm.heatmap.x_values = vm.spreadsheets.map( function(spreadsheet, idx) {
                            let rep_counts = [];
                            return spreadsheet.x_values.map( function(time) {
                                if (rep_counts[time] === undefined) {
                                    rep_counts[time] = 0;
                                }
                                rep_counts[time] += 1;
                                let day = Math.floor(time / spreadsheet.timepoints_per_day) + 1;
                                let time_of_day = time % spreadsheet.timepoints_per_day + 1;
                                return "Day " + day + " Timepoint " + time_of_day + " Rep " + rep_counts[time];
                            });
                        });
                    }
                }

                // Find max/min values so that we can center the colormap with 0=middle
                let maxInRow = vm.heatmap.data.map( function(spreadsheet) { return spreadsheet.map(array_max); });
                let minInRow = vm.heatmap.data.map( function(spreadsheet) { return spreadsheet.map(array_min); });

                let max = Math.max.apply(null, maxInRow.map(array_max));
                let min = Math.min.apply(null, minInRow.map(array_min));
                let limit = Math.max(Math.abs(min), Math.abs(max));

                let y_vals =  vm.heatmap.labels.map(function (x,i) {return i;});

                let heatmap_values = vm.spreadsheets.map( function(spreadsheet, idx) {
                    let colorbar = {};
                    if (idx === 0){
                        colorbar = {
                            title: 'Z Score',
                            titleside: 'right'
                        };
                    }
                    return {
                        x: vm.heatmap.x_values[idx],
                        y: y_vals,
                        z: vm.heatmap.data[idx],
                        type: 'heatmap',
                        xaxis: "x" + (idx+1),
                        yaxis: "y",
                        zmin: -1 * limit,
                        zmax: limit,
                        colorbar: colorbar
                    };
                });

                let heatmap_layout = {
                    height: 700,
                    width: 300*vm.spreadsheets.length+600,
                    margin: {
                        l: 200,
                        r: 5,
                        b: 175,
                        t: 20
                    },
                    pad: 4,
                    yaxis: {
                        tickmode: "array",
                        ticktext: vm.heatmap.labels,
                        tickvals: y_vals,
                        showticklabels: vm.heatmap.config.show_labels,
                        ticks: ''
                    },
                    grid: {
                        rows: 1,
                        columns: vm.spreadsheets.length
                    }
                };

                Plotly.newPlot('heatmap', heatmap_values, heatmap_layout, heatmap_options);

                vm.heatmap.rendered = true;
            },

            downloadHeatmap: function() {
                let gd = document.getElementById('heatmap');
                Plotly.downloadImage(gd, {format: 'svg', filename: 'heatmap_' + (this.selected_row+1)});
            },

            selectRow: function(row) {
                this.selected_row = row;
            },

            onRowChange: function () {
                this.redrawPlot();
            },

            cycleSpreadsheets: function() {
                // Shifts spreadsheets over by one, cyclicly
                // For just 2, it just swaps primary/secondary
                this.spreadsheets.push(this.spreadsheets.shift());
            },
            searchRows: function() {
                let search_value = this.search_value.toLowerCase();

                // Pull out row indexes matching our search_value
                let matching_rows = app.labels.map( function(unused, index) {
                    let label = app.labels[app.sort_order[index]];
                    if (label.toLowerCase().indexOf(search_value) !== -1) {
                        return index;
                    }
                }).filter(isFinite);


                if (matching_rows.length === 0) {
                    console.log("Unfortunately no matching row found.");
                    // TODO: display something to the user
                    return;
                }

                // Find matches in rows past the current selection
                let matches_after = matching_rows.filter( function (i) {
                    return i > app.selected_row;
                } );

                let row = null;
                if (matches_after.length > 0) {
                    // First look for matches that are *after* our selected_row
                    // so that multiple button presses will cycle the selection through all matches
                    row = matches_after[0];
                } else {
                    // If that fails, grab the first matching row
                    row = matching_rows[0];
                }

                app.selected_row = row;
            },

            setPCAPointStyles: function() {
                let vm = this;

                let pca_plot = Plotly.d3.select("#pca_plot");
                let points = pca_plot.selectAll(".scatter").selectAll("path");

                // remove any existing background circles
                pca_plot.selectAll(".scatter").selectAll("circle").remove();
                // Add in background circles
                points.each(function(x,i,j) {

                    let t = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    t.setAttributeNS(null, "r", "13");
                    t.setAttributeNS(null, "transform", this.getAttributeNS(null,"transform"));
                    t.setAttributeNS(null, "fill", "white");
                    this.parentNode.insertBefore(t, this);
                });

                // Set the shape of the points to be the "colored wedge" shape
                points.attr("d", PCA_SYMBOL);
                // Rotate the colored wedge by the time (x-value)
                points.attr("transform", function(x,i,j) {
                    let spreadsheet = vm.spreadsheets[j];
                    let rotation = (spreadsheet.x_values[i] % spreadsheet.timepoints_per_day) / spreadsheet.timepoints_per_day * 360 - 45;

                    let curr_transform = this.getAttribute("transform");
                    if (curr_transform.indexOf("rotate") < 0) {
                        return curr_transform + " rotate(" + rotation + ")";
                    } else {
                        return curr_transform;
                    }
                });

                vm.setPCALegend();
            },

            setPCALegend: function() {
                let vm = this;

                let pca_plot = Plotly.d3.select('#pca_plot');
                let info_layer = pca_plot.select('.infolayer');


                // Remove any existing legend
                info_layer.selectAll('.pca_legend').remove();
                info_layer.selectAll('.pca_legend_bg').remove();

                let times = vm.spreadsheets[0].x_label_values.filter(function(t) { if (t < vm.spreadsheets[0].timepoints_per_day) { return 1; } else { return 0; } });
                let labels = times.map( function(t) {return "Timepoint " + (t + 1);} );

                if (times.length > 6) {
                    // If there are too many points to show all in the legend
                    // then downsample them to be a more reasonable number
                    let n = Math.floor(times.length/6);
                    times = times.filter( function (x,i) { return (i % n) === 0; });
                    labels = labels.filter( function (x,i) { return (i % n) === 0; });
                }

                let margin = 5;
                let entry_height = 30;
                let radius = 15;
                let legend_width = 200;
                let legend_height = (entry_height+margin)*times.length + margin;
                let x = 800;
                let y = 50;

                // Expand the SVG to fit the legend
                pca_plot.selectAll('.main-svg').attr('width', PCA_WIDTH + margin*2 + legend_width);

                // Background rect
                let bg = info_layer.append('rect')
                            .attr('class', 'pca_legend_bg')
                            .attr('x', x + margin)
                            .attr('y', y + margin)
                            .attr('width', legend_width)
                            .attr('height', legend_height)
                            .attr('fill', 'rgb(238,238,238)');

                // Group containing all the entries in the legend, translated to be inside the bg rect
                let g = info_layer.append('g')
                        .attr('class', 'pca_legend')
                        .attr('transform', 'translate(' + (x + 2*margin) + "," + (y + 2*margin) + ")");

                // Each entry is a path (the symbol, appropriately rotated) and text describing the time
                let entries = g.selectAll('g')
                                .data(times)
                               .enter()
                                 .append('g')
                                 .attr('transform', function (x,i) {return 'translate(0,'+ (i*(entry_height+margin)) + ')';});
                entries.append('path')
                        .attr('transform', function (x,i) {
                                return 'translate(' + radius + ',' + radius + ')'
                                      +'rotate(' + ((times[i] % vm.spreadsheets[0].timepoints_per_day) / vm.spreadsheets[0].timepoints_per_day * 360 - 45) + ')';
                            })
                        .attr('d', PCA_SYMBOL)
                        .attr('fill', 'rgb(127,127,127)');

                entries.append('text')
                        .attr('x',2*radius + margin)
                        .attr('transform', 'translate(0,' + radius + ')')
                        .attr('dy', '0.4em')
                        .text(function (x,i) { return labels[i]; });
            },

            runPCA: function() {
                let vm = this;

                // We only run PCA on unfiltered genes below the selected row
                let selected_genes = app.sort_order.filter( function(row,rank) {
                    if (rank > app.selected_row) {
                        return false;
                    }
                    if (app.filtered[row]) {
                        return false;
                    }
                    return true;
                });

                if (selected_genes.length <  3) {
                    vm.pca.alert = "Too few rows selected, need at least 3 for PCA.";
                    return;
                } else {
                    vm.pca.alert = '';
                }

                let pt_labels = vm.spreadsheets.map( function(spreadsheet, idx) {
                    let rep_counts = [];
                    return spreadsheet.x_values.map( function(time) {
                        if (rep_counts[time] === undefined) {
                            rep_counts[time] = 0;
                        }
                        rep_counts[time] += 1;
                        let day = Math.floor(time / spreadsheet.timepoints_per_day) + 1;
                        let time_of_day = time % spreadsheet.timepoints_per_day + 1;
                        return "Day " + day + " Timepoint " + time_of_day + " Rep " + rep_counts[time];
                    });
                });

                vm.pca.running = true;

                $.ajax({
                    url: "run_pca",
                    data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids,
                                          'selected_genes': selected_genes,
                                          'take_logtransform': vm.pca.config.logtransform,
                                          'take_zscore': vm.pca.config.zscore}),
                    dataType: 'json',
                    contentType: 'application/json',
                    type: 'POST',
                    success: function (response) {
                        pca_coords = response['pca_coords'];
                        explained_variance = response['explained_variance'];

                        let traces = vm.spreadsheets.map( function (spreadsheet, idx) {
                            return {
                                x: pca_coords[idx][0],
                                y: pca_coords[idx][1],
                                mode: 'markers',
                                name: spreadsheet.descriptive_name,
                                text: pt_labels[idx],
                                marker: {
                                    size: 25,
                                    opacity: 1,
                                }
                            };
                        });

                        let layout = {
                            height:PCA_HEIGHT,
                            width:PCA_WIDTH,
                            xaxis: {
                                title: "PC1 (" + toFixed(explained_variance[0]*100,1) + "%)"
                            },
                            yaxis: {
                                title: "PC2 (" + toFixed(explained_variance[1]*100,1) + "%)"
                            },
                            hovermode: 'closest',
                            legend: {
                                x:0,
                                y:1,
                                bgcolor: '#EEEEEE'
                            }
                        };

                        let pca_plot = document.getElementById('pca_plot');
                        Plotly.newPlot(pca_plot, traces, layout);

                        pca_plot.on('plotly_afterplot', vm.setPCAPointStyles);
                    },
                    error: function (error) {
                        console.log("Error running PCA");
                        console.log(error);
                        alert.text(error.responseText);
                        alert.show();
                    },
                    complete: function() {
                        vm.pca.running = false;
                        vm.pca.rendered = true;
                    }
                });
            },

            downloadPCA: function() {
                // NOTE: we cannot use Plotly.downloadImage() since we have modified the plot
                // after its creation and the downloadImage() won't reflect those changes
                // So instead we just directly grab its SVG structure by toSVG() and then download that

                // Gather the plot as an SVG
                let pca_plot = document.getElementById('pca_plot');
                let svg_data = Plotly.Snapshot.toSVG(pca_plot, {format: 'svg'});

                // Create a URL for it
                let blob = new Blob([svg_data]);
                let url = URL.createObjectURL(blob);

                // Trigger downloading of the URL by making an <a href ...> to it and clicking it
                let anchor = document.createElement("a");
                anchor.href = url;
                anchor.download = "pca.svg";
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);

                // Cleanup after 60s, they've presumably successfully downloaded the small svg
                setTimeout(function () { URL.revokeObjectURL(url) }, 60000);
            },

        },

        computed: {
            row_index: function() {
                if (this.sort_order !== null) {
                    return this.sort_order[this.selected_row];
                } else {
                    return this.selected_row;
                }

            },

            num_below: {
                get: function () {
                    return this.num_significant_below[this.selected_row];
                },
                set: function (val) {
                    val = parseInt(val);
                    if (val === null || this.num_significant_below === null) {
                        this.selected_row = 0;
                    }

                    let idx = this.num_significant_below.indexOf(val);
                    if (idx !== -1) {
                        this.selected_row = idx;
                    } else {
                        if (idx > Math.max(null, this.num_significant_below)) {
                            this.selected_row = this.num_siginificant_below.length;
                        } else {
                            this.selected_row = 0;
                        }
                    }
                }
            },

            sort_order: function () {
                let vm = this;

                let sorter = this.sorters[this.sort_variable];
                let sort_order =  this.labels.map( function(x,i) {return i;} );
                sort_order = sort_order.sort( this.sorters[this.sort_variable] );

                if (this.hide_filtered_rows) {
                    // Move filtered items from the sort_order to the back of the list  to hide them
                    let head = sort_order.filter( function(x) {return !vm.filtered[x];});
                    let tail = sort_order.filter( function(x) {return vm.filtered[x];});
                    sort_order = head.concat(tail);
                }

                return sort_order;
            },

            filtered: function () {
                let vm = this;
                let filtered_out = this.labels.map( function (x) {return false;} );

                // Apply all filters
                this.last_used_filters.forEach(function(filter) {
                    let filter_value = filter.variable;

                    let lower_bound = parseFloat(filter.lower_bound);
                    let upper_bound = parseFloat(filter.upper_bound);

                    if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                    if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                    let values = vm.filter_data.get(filter_value).values();
                    filtered_out = filtered_out.map( function (x,i) {
                        return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                    });
                });

                return filtered_out;
            },

            num_significant_below: function() {
                // Recompute the number of signifcant items below a cutoff
                // discards filtered out rows
                let num_significant_below = new Array(this.labels.length);
                let ctr = 0;
                this.labels.forEach(function(label, index) {
                    if (!app.filtered[app.sort_order[index]]) {
                        ctr++;
                    }

                    num_significant_below[index] = ctr;
                });
                return num_significant_below;
            },

            useable_stats: function () {
                // Only the stats from stats_list that apply to this context
                // i.e. the ones we have enough spreadsheets for
                let vm = this;
                return this.stats_list.filter( function(stat) {
                    if (stat.num_spreadsheets == 'multi') {
                        return vm.spreadsheets.length > 1;
                    } else {
                        return true;
                    }
                });
            },
        },

        watch: {
            row_index: "onRowChange",

            "heatmap.config": {
                handler: "updateHeatmap",
                deep: true
            },

            "plot.config": {
                handler: "redrawPlot",
                deep: true
            },

            "pca.config": {
                handler: "runPCA",
                deep: true
            },
        },
    });

</script>
{% endblock %}
