{% extends "base.html" %}

{% block content %}


<!-- temporary inlining of Vue.JS dev version -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>

    $(document).ready(function () {
        // Handles to the error-handling modal
        nitecap_error = $("#error-modal");
        nitecap_error_message = $("#error-modal-message")

        share_token = "{{ share_token }}";
        initial_config = {{ config | tojson }};

        initial_config.original_spreadsheet_ids = {{ spreadsheet_ids | safe }};

        // If not supplied in config (eg: no config at all), order by the given spreadsheet_ids
        if ((initial_config.spreadsheet_ids || []).length === 0) {
            initial_config.spreadsheet_ids = {{ spreadsheet_ids | safe }};
        }


        $.ajax({
            url: "/spreadsheets/get_spreadsheets",
            data: JSON.stringify({'spreadsheet_ids': initial_config.original_spreadsheet_ids, 'share_token': share_token}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                onSpreadsheetLoad(response);
            },
            error: function(error) {
                console.log("Error loading spreadsheets");
                console.log(error);

                nitecap_error_message.text("Error loading spreadsheets");
                nitecap_error.modal();
            }
        });

    });

    function onSpreadsheetLoad(spreadsheets) {
        let vm = app;

        // FOR VUE
        spreadsheets.forEach(function(spreadsheet) {
            spreadsheet.upside_ps = null;
            spreadsheet.upside_qs = null;

            // VUE PERF NOTE
            // Vue "observes" all attributes of observed objects
            // so it will try to observe everything in the large data arrays
            // however we do not need reactivity for those arrays since they don't change
            // Here we disable adding new elements to them which causes Vue to not observe every element in the array
            // Note that the arrays themselves are still observed in the sense that doing spreadsheet.tds = <new array>
            // will propagate changes that depend on spreadsheet.tds
            Object.keys(spreadsheet).forEach(function(key){
                if (Array.isArray(spreadsheet[key])) {
                    Object.preventExtensions(spreadsheet[key]);
                }
            });
        });

        // Gather spreadsheets by id
        vm.spreadsheets_by_id = {};
        spreadsheets.forEach(function(spreadsheet) {
            Vue.set(vm.spreadsheets_by_id, spreadsheet.spreadsheet_id, spreadsheet);
        });


        vm.labels = spreadsheets[0].labels;
        vm.timepoints_per_day = spreadsheets[0].timepoints_per_day;
        vm.num_days = (Math.max.apply(null, spreadsheets[0].x_values) + 1) / spreadsheets[0].timepoints_per_day;

        // Update stats_table with the Additional Stat Columns of the spreadsheets
        spreadsheets.forEach(function(spreadsheet) {
            Object.entries(spreadsheet.stat_values).forEach(function(entry) {
                let key = entry[0];
                let value = entry[1];
                vm.stats[key] = value;
                vm.stats_table[key] = {
                    name: key,
                    value: key,
                    description: "Additional stat column from spreadsheets with column name " + key +" (from spreadsheet " + spreadsheet.descriptive_name +").",
                    per_spreadsheet: false,
                };
            });
        });


        function makeCoarseSlider(element, start_value, maximum) {
            element.slider({
                orientation: "horizontal",
                min: 0,
                value: start_value,
                step: 1,
                max: maximum,
                range: "min",
                slide: function (event, ui) {
                    vm.config.selected_row = ui.value;
                }
            });
        }

        makeCoarseSlider($('#coarse_slider'), 0, vm.labels.length - 1);

        // Load config values
        mergeDeep(vm.config, initial_config);
        vm.config.filters.forEach(function(filter) {
            // editing_filters needs a copy of the actually-used filters
            vm.editing_filters.push(Object.assign({},filter));
        });

        // Load the JTK values for each spreadsheet
        $.ajax({
            url: "/spreadsheets/jtk",
            data: JSON.stringify({'spreadsheet_ids': initial_config.original_spreadsheet_ids, 'share_token':share_token}), // Use original_spreadsheet_ids since it needs to be consistent with original page load order
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                let jtk_ps = response['jtk_ps'];
                let jtk_qs = response['jtk_qs'];
                let ars_ps = response['ars_ps'];
                let ars_qs = response['ars_qs'];
                let ls_ps = response['ls_ps'];
                let ls_qs = response['ls_qs'];

                initial_config.original_spreadsheet_ids.forEach(function(spreadsheet_id, idx) {
                    let spreadsheet = vm.spreadsheets_by_id[spreadsheet_id];
                    // For Vue performance see VUE PERF NOTE
                    Object.preventExtensions(jtk_ps[idx]);
                    Object.preventExtensions(jtk_qs[idx]);
                    spreadsheet.jtk_ps = jtk_ps[idx];
                    spreadsheet.jtk_qs = jtk_qs[idx];
                    Object.preventExtensions(ars_ps[idx]);
                    Object.preventExtensions(ars_qs[idx]);
                    spreadsheet.ars_ps = ars_ps[idx];
                    spreadsheet.ars_qs = ars_qs[idx];
                    Object.preventExtensions(ls_ps[idx]);
                    Object.preventExtensions(ls_qs[idx]);
                    spreadsheet.ls_ps = ls_ps[idx];
                    spreadsheet.ls_qs = ls_qs[idx];
                });
            },
            error: function(error) {
                console.log("Error loading JTK values");
                console.log(error);

                nitecap_error_message.text("Error loading JTK values");
                nitecap_error.modal();
            }
        });

        // Load the Upside values
        if (spreadsheets.length > 1) {
            $.ajax({
                url: "/spreadsheets/get_upside",
                data: JSON.stringify({'spreadsheet_ids': initial_config.original_spreadsheet_ids, 'share_token':share_token}),
                dataType: 'text json',
                contentType: 'application/json',
                type: 'POST',
                success: function(response) {
                    // See VUE PERF NOTE
                    // Make all arrays non-traversed by Vue for performance
                    Object.keys(response).forEach(function(key) {
                        Object.preventExtensions(response[key]);
                    });

                    upside_ps = response['upside_ps'];
                    upside_qs = response['upside_qs'];

                    initial_config.original_spreadsheet_ids.forEach(function(spreadsheet_id, idx) {
                        let spreadsheet = vm.spreadsheets_by_id[spreadsheet_id];
                        Object.preventExtensions(upside_ps[idx]); // See VUE PERF NOTE
                        Object.preventExtensions(upside_qs[idx]); // these aren't covered by above since are one level deeper
                        spreadsheet.upside_ps = upside_ps[idx];
                        spreadsheet.upside_qs = upside_qs[idx];
                    });

                    // Load stats that are per-comparison not per-spreadsheet
                    app.stats.two_way_anova_ps = response['two_way_anova_ps'];
                    app.stats.two_way_anova_qs = response['two_way_anova_qs'];
                    app.stats.main_effect_ps = response['main_effect_ps'];
                    app.stats.main_effect_qs = response['main_effect_qs'];
                    app.stats.phase_ps = response['phase_ps'];
                    app.stats.phase_qs = response['phase_qs'];
                    app.stats.amplitude_ps = response['amplitude_ps'];
                    app.stats.amplitude_qs = response['amplitude_qs'];
                },

                error: function(error) {
                    console.log("Error loading upside values");
                    console.log(error);

                    nitecap_error_message.text("Error loading comparison statistics");
                    nitecap_error.modal();
                }
            });
        }

        $('[data-toggle="tooltip"]').tooltip();
    }
</script>

{% raw %}

<div id="vue-app">
    <div class="page-header">
        <h1>Spreadsheet Viewer</h1>
    </div>

    <div v-show="spreadsheets.length > 0">
        <div class="row">
            <p class="col-lg-12 h3" v-if="spreadsheets[1]" v-cloak>
                {{spreadsheets[0].descriptive_name}} vs. {{spreadsheets[1].descriptive_name}}

                <a v-bind:href="'/spreadsheets/download_comparison/'+spreadsheets[0].spreadsheet_id+','+spreadsheets[1].spreadsheet_id"
                        class="mx-3" download="processed_file.txt">
                    <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
                </a>

                <a id='share_spreadsheet' href="#" v-on:click="onShare">
                    <i class="fas fa-share-square" data-toggle="tooltip" data-placement="top" title="Share"></i>
                </a>
            </p>

            <p class="col-lg-12 h3" v-if="spreadsheets.length === 1">
                {{spreadsheets[0].descriptive_name}}
                <button class="btn btn-secondary btn-sm" id='share_spreadsheet' v-on:click="triggerDownloadPopup">
                    Download
                </button>
                <a v-bind:href="'/spreadsheets/collect_data/'+spreadsheets[0].spreadsheet_id">
                    <i class="fas fa-edit" data-toggle="tooltip" data-placement="top" title="Edit"></i>
                </a>
                <a id='share_spreadsheet' href="#" v-on:click="onShare">
                    <i class="fas fa-share-square" data-toggle="tooltip" data-placement="top" title="Share"></i>
                </a>
            </p>
        </div>

        <div class="row">
            <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
        </div>

        <div class='row justify-content-center'>
            <span class='col-auto'>
                <div class='row'>
                    <div class="col">
                        <div class="input-group mb-2">
                            <input class="form-control form-control-sm" type="text" name="row_search"
                                   placeholder="Search for row by label" v-model="search_value"
                                   v-on:keyup.enter="searchRows"/>
                            <div class="input-group-append">
                                <button type="button" class="btn btn-secondary btn-sm"
                                        v-on:click="searchRows">
                                    Search
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class='row'>
                    <div class='col-auto'>
                        <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
                        <row-selector v-bind:sort-order="sort_order"
                                      v-bind:filtered="filtered"
                                      v-bind:num-rows="21"
                                      v-bind:q-values="label_qs"
                                      v-bind:selected-row="config.selected_row"
                                      v-bind:labels="labels"
                                      v-bind:label-max-length="35"
                                      v-bind:select-row="selectRow"
                                      v-cloak>
                        </row-selector>
                        <div class="form-check">
                            <input class="form-check-input" id="hide_filtered" type="checkbox" v-model="config.hide_filtered_rows">
                            <label class="form-check-label" for="hide_filtered">Hide filtered rows</label>
                        </div>
                    </div>
                </div>
            </span>
            <div class='col-auto'>
                <span id="scatter_plot" style="width:625px;height:525px;vertical-align: top"></span>
                <div class='p-3 float-right'>
                    <button class="btn btn-primary" v-on:click="downloadPlot">Download Plot</button>
                </div>
                <div class='p-3 float-right'>
                    <button class="btn btn-primary btn-sm" v-on:click="shiftSpreadsheets" v-if="spreadsheets.length > 1">Reorder Spreadsheets</button>
                </div>
                <form class="form-group">
                    <div class="form-inline">
                        <label for="plot_style_select">Plot style</label>
                        <select id="plot_style_select" value="basketweave" class="form-control form-control-sm" v-model="config.plot.style">
                            <option value="basketweave">Basketweave</option>
                            <option value="points">Points</option>
                            <option value="mean">Mean only</option>
                            <option value="mean_points">Points and Mean</option>
                            <option value="std">Standard Deviations</option>
                            <option value="std_points">Standard Deviations and Points</option>
                            <option value="SEM">SEM</option>
                            <option value="SEM_points">SEM and Points</option>
                            <option value="repeated_measures">Repated Measures</option>
                            <option value="cosinor">Cosinor</option>
                        </select>
                    </div>
                    <div class="form-inline">
                        <label for="plot_x_label_style">Plot x-axis labels</label>
                        <select id="plot_x_label_style" class="form-control form-control-sm" v-model="config.plot.x_label_style">
                            <option value="daytime" selected>Day and time</option>
                            <option value="time">Time of day</option>
                            <option value="infer">Inferred labels</option>
                            <option value="infer_wrapped">Inferred labels wrapping</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="form-check" id="fold_days_box" v-if="num_days > 1">
                        <input class="form-check-input" id="fold_days_checkbox" type="checkbox" v-model="config.plot.fold_days">
                        <label class="form-check-label" for="fold_days_checkbox">Overlay cycles</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" id="include_zero_checkbox" type="checkbox" v-model="config.plot.include_zero">
                        <label class="form-check-label" for="include_zero_checkbox">Include zero</label>
                    </div>
                </form>
            </div>

            <div class="col-auto">
                <div class="card">
                    <div class="card-header">
                        Statistics
                        <a id="statsHelp" class="text-primary help-pointer ml-3"
                           data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                           title="Statistics Help"
                           data-content="Displays statistics about the selected row. JTK values are calculated on first page load and may a take a minute.">
                            <i class="fas fa-info-circle"></i>
                        </a>
                    </div>
                    <div class="card-body" id="statistics-list">
                        <table class="table table-sm">
                            <thead>
                                <tr v-if="spreadsheets.length > 1">
                                    <th scope="col"></th>
                                    <th scope="col" v-for="name in descriptive_names">{{name}}</th>
                                </tr>
                            </thead>
                            <tbody v-if="spreadsheets !== null" class="stats-box">
                                <template v-for="(stat, stat_id) in useable_stats">
                                    <tr>
                                        <td v-bind:rowspan="typeof stat.value === 'string' ? 1 : 2">
                                            {{stat.name}}
                                            <a class="text-primary help-pointer float-right ml-1"
                                                data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                                v-bind:title="stat.name"
                                                v-bind:data-content="stat.description">
                                                <i class="fas fa-info-circle"></i>
                                            </a>
                                        </td>

                                        <template v-if="typeof stat.value === 'string'">
                                            <template v-if="stat.per_spreadsheet">
                                                <template v-for="(spreadsheet, i) in spreadsheets">
                                                    <td v-if="spreadsheet[stat.value] != null"
                                                        v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                        v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                        v-bind:title="String(spreadsheet[stat.value][row_index])">
                                                        {{util.formatNum(spreadsheet[stat.value][row_index], 4)}}
                                                    </td>
                                                    <td v-else>
                                                        loading
                                                    </td>
                                                </template>
                                            </template>
                                            <template v-else>
                                                <td v-if="stats[stat.value] != null"
                                                    v-bind:title="String(stats[stat.value][row_index])"
                                                    v-on:click="config.sort_by = {stat_id:stat_id}"
                                                    v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:colspan="spreadsheets.length">
                                                    {{util.formatNum(stats[stat.value][row_index], 4)}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>

                                        <template v-else>
                                            <template v-if="stat.per_spreadsheet">
                                                <template v-for="(spreadsheet, i) in spreadsheets">
                                                    <td v-if="spreadsheet[stat.value.p] != null"
                                                        v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                        v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                        v-bind:title="String(spreadsheet[stat.value.p][row_index])">
                                                        p: {{util.formatNum(spreadsheet[stat.value.p][row_index], 4)}}
                                                    </td>
                                                    <td v-else>
                                                        loading
                                                    </td>
                                                </template>
                                            </template>
                                            <template v-else>
                                                <td v-if="stats[stat.value.p] != null"
                                                    v-bind:title="String(stats[stat.value.p][row_index])"
                                                    v-on:click="config.sort_by = {stat_id:stat_id}"
                                                    v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:colspan="spreadsheets.length">
                                                    p: {{util.formatNum(stats[stat.value.p][row_index], 4)}}
                                                </td>
                                                <td v-else v-bind:colspan="spreadsheets.length">
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                    </tr>

                                    <tr v-if="typeof stat.value !== 'string'">
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="(spreadsheet, i) in spreadsheets">
                                                <td v-if="spreadsheet[stat.value.q] != null"
                                                    v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                    v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:title="String(spreadsheet[stat.value.q][row_index])">
                                                    q: {{util.formatNum(spreadsheet[stat.value.q][row_index], 4)}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value.q] != null"
                                                v-bind:title="String(stats[stat.value.q][row_index])"
                                                v-on:click="config.sort_by = {stat_id:stat_id}"
                                                v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                v-bind:colspan="spreadsheets.length">
                                                q: {{util.formatNum(stats[stat.value.q][row_index], 4)}}
                                            </td>
                                            <td v-else v-bind:colspan="spreadsheets.length">
                                                loading
                                            </td>
                                        </template>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

        </div>

        <div class="row">
            <div class="col">
                <div id="coarse_slider" class="coarse-slider"></div>
            </div>
        </div>

        <div class="row">
            <span class="form-group col-lg-5">
                Number of selected rows:
                <input type="number" v-model.number="num_below"></input>
            </span>
            <span class="form-group col-lg-5">
                Cutoff:
                <input v-model.lazy.number="cutoff"></input>
            </span>
        </div>




        <div class="card">

            <div class="card-header">
                <ul class="nav nav-tabs" id="toolTabs" role="tablist">
                    <li class="nav-item">
                        <a class="nav-link activate" id="filters-tab" data-toggle="tab" href="#filters" aria-controls="home" aria-selected="True">Filters</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="pathways-tab" data-toggle="tab" href="#pathways" aria-controls="pathways" aria-selected="false">Pathways</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="heatmap-tab" data-toggle="tab" href="#heatmap" aria-controls="heatmap" aria-selected="false">Heatmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="PCA-tab" data-toggle="tab" href="#PCA" aria-controls="PCA" aria-selected="false">PCA</a>
                    </li>
                </ul>
            </div>

            <div class="tab-content card-body" id="toolTabContent">
                <div class="tab-pane fade show active" id="filters" role="tabpanel" aria-labelledby="filters-tab" v-on:keyup.enter="applyFilters">
                    <div class="col-auto">
                        <div id="filter_list">
                            <div v-for="(filter, index) in editing_filters" class="row"
                                :key="filter.id">
                                <div class='col form-inline filter_item'>
                                    <input class="form-control form-control-sm m-1 filter-lower-bound" style="width: 85px"
                                         v-bind:aria-label="'Lower bound for filter ' + index"
                                         v-model="filter.lower_bound">
                                    </input>

                                    &le;

                                    <select class="form-control form-control-sm m-1 filter_value_selector"
                                            v-bind:aria-label="'Filter selector for filter ' + index"
                                            v-model="filter.variable">
                                        <option v-for="filter_data in filter_data_list"
                                                v-bind:value="filter_data.key">
                                                {{filter_data.name}}
                                        </option>
                                    </select>

                                    &le;

                                    <input class="form-control form-control-sm m-1 filter-upper-bound" style="width: 85px"
                                         v-bind:aria-label="'Upper bound for filter ' + index"
                                         v-model="filter.upper_bound">
                                    </input>

                                    <button class="btn btn-default" v-bind:aria-label="'Remove filter ' + index" title="Remove filter"
                                            v-on:click="editing_filters = editing_filters.filter(function(x,j) {return j !== index;})">
                                        <span class="far fa-minus-square"> </span>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <button id="applyFilters" type="button" class="btn btn-primary" v-on:click="applyFilters">Apply filters</button>
                        <button id="add_filter_button" class="btn btn-default" aria-label="Add filter"
                            v-on:click="addFilter">
                            <span class="far fa-plus-square" title="Add filter" data-toggle="tooltip" data-placement="top"></span>
                        </button>
                        <button id="reset_filters_button" class="btn btn-default" aria-label="Reset filters"
                            v-on:click="resetFilters">
                            <span class="fas fa-undo" title="Reset filters" data-toggle="tooltip" data-placement="top"></span>
                        </button>
                        <a id="filtersHelp" class="text-primary help-pointer ml-3"
                           data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                           title="Filter Help"
                           data-content="Keep only rows matching the criteria provided. Rerunning the q-values computes q-values using only the unfiltered genes. This is statistically invalid to do if filtering on most criteria (eg: if filtering p-values or q-values, one should not rerun the q-values). Instead, only rerun q-values when filtering exclusively on time-unaware criteria (such as max value).">
                            <i class="fas fa-info-circle"></i>
                        </a>
                        <!--<button id="rerun_qvalues" type="button" class="btn btn-primary mb-4">Rerun q-values</button>-->
                    </div>
                </div>

                <div class="tab-pane fade" id="pathways" role="tabpanel" aria-labelledby="pathways-tab">
                    <pathway-analysis
                        v-bind:foreground="spreadsheets[0] ? selected_rows.map(function(i) {return spreadsheets[0].labels[i];}): []"
                        v-bind:background="background_ids"
                        >
                    </pathway-analysis>
                </div>
                <div class="tab-pane fade" id="heatmap" role="tabpanel" aria-labelledby="heatmap-tab">
                    <heatmap-plot
                        v-bind:spreadsheets="spreadsheets"
                        v-bind:num_days="num_days"
                        v-bind:selected_rows="selected_rows"
                        v-bind:timepoint_labels="timepoint_labels"
                        v-bind:day_and_time_labels="day_and_time_labels"
                        v-bind:labels="labels">
                    </heatmap-plot>
                </div>
                <div class="tab-pane fade" id="PCA" role="tabpanel" aria-labelledby="PCA-tab">
                    <pca-plot
                        v-bind:spreadsheets="spreadsheets"
                        v-bind:timepoint_labels="timepoint_labels">
                    </PCA-plot>
                </div>
            </div>
        </div>
    </div>
    <div v-show="spreadsheets.length == 0">
        <p> Loading... </p>
    </div>


    <!-- MODALS -->
    <div id="share_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">SHARE this spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="share_url">Copy this URL and offer it to anyone with whom you'd like to share your
                        spreadsheet data:</label>
                    <textarea id="share_url" class="form-control" rows="6"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
      </div>
    </div>

    <div id="download_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">Download spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-include-data" v-model:value="download.include_data"></input>
                        <label class="form-check-label" for="download-include_data">
                            Include data
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-just-selected-rows" v-model:value="download.just_selected_rows"></input>
                        <label class="form-check-label" for="download-just-selected-rows">
                            Inlucde only top {{row_index}} rows
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-drop-filtered" v-model:value="download.drop_filtered_rows"></input>
                        <label class="form-check-label" for="download-drop-filtered">
                            Drop filtered-out rows
                        </label>
                    </div>
                    Statistics
                    <div class="form-check" v-for="(stat, stat_name) in useable_stats">
                        <input class="form-check-input" type="checkbox" v-bind:id="'download-'+stat_name" v-model:value="download.stats[stat_name]"></input>
                        <label class="form-check-label" v-bind:for="'download-'+stat_name">
                            {{stat.name}} statistics
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal" v-on:click="downloadSpreadsheet">Download</button>
            </div>
        </div>
      </div>
    </div>

</div>

{% endraw %} <!-- TODO remove these raw tags when we are no longer using templating at all -->

<script src="{{url_for('static', filename='js/row_selector.js')}}"></script>
<script src="{{url_for('static', filename='js/PCA_plot.js')}}"></script>
<script src="{{url_for('static', filename='js/heatmap_plot.js')}}"></script>
<script src="{{url_for('static', filename='js/pathway.js')}}"></script>
<script src="{{url_for('static', filename='js/pathway_component.js')}}"></script>

<script>
    Vue.prototype.util = {
        formatNum: formatNum
    };

    let stats_table = {
        nitecap: {name: "Nitecap",
         value: {p: "ps",
                 q: "qs"},
          description: "Nitecap significance of rhythmicity for primary dataset.",
         per_spreadsheet: true,
         num_spreadsheets:'any',
         sort_value:'tds',
         secondary_sort_value:'qs'},
        jtk: {name: "JTK",
         value: {p: "jtk_ps",
                 q: "jtk_qs"},
         description: "JTK_cycle significance of rhythmicity for primary dataset.",
        per_spreadsheet: true,
        num_spreadsheets:'any'},
        ars: {name: "ARS",
         value: {p: "ars_ps",
                 q: "ars_qs"},
         description: "ARSER significance of rhythmicity for primary dataset. Computed by meta2d.",
        per_spreadsheet: true,
        num_spreadsheets:'any'},
        ls: {name: "LS",
         value: {p: "ls_ps",
                 q: "ls_qs"},
         description: "Lomb-Scargle significance of rhythmicity for primary dataset. Computed by meta2d.",
        per_spreadsheet: true,
        num_spreadsheets:'any'},
        cosinor: {name: "Cosinor",
         value: {p: "cosinor_ps",
                 q: "cosinor_qs"},
         description: "Cosinor significance of rhythmicity for primary dataset.",
         per_spreadsheet: true,
         num_spreadsheets:'any'},
        anova: {name: "ANOVA",
         value: {p: "anova_ps",
                 q: "anova_qs"},
         description: "1-Way ANOVA on primary dataset. If there are no replicates on timepoints, ANOVA cannot be run.",
         per_spreadsheet: true,
         num_spreadsheets: 'any'},
        damping: {name: "Damping",
         value: {p: "upside_ps",
                 q: "upside_qs"},
         description: "Damping analysis giving significance of a decrease in variation in the secondary dataset compared to the first.",
         per_spreadsheet: true,
         num_spreadsheets: 'multi'},
        two_way_anova: {name: "Two-way ANOVA",
         value: {p: "two_way_anova_ps",
                 q: "two_way_anova_qs"},
         description: "Two-way ANOVA test for difference in timepoint-effects across datasets",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        main_effect_diff: {name: "Main Effect Diff",
         value: {p: "main_effect_ps",
                 q: "main_effect_qs"},
         description: "Main effect test of difference between the two datasets in the two-way ANOVA",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        phase_difference: {name: "Phase Difference",
         value: {p: "phase_ps",
                 q: "phase_qs"},
         description: "Test for equality of phase between datasets through cosinor analysis (least squares fit)",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        amplitude_difference: {name: "Amplitude Difference",
         value: {p: "amplitude_ps",
                 q: "amplitude_qs"},
         description: "Test for equality of amplitudes between datasets through cosinor analysis (least squares fit)",
         per_spreadsheet: false,
         num_spreadsheets: 'multi'},
        amplitude: {name: "Amplitude",
         value: "amplitudes",
         description: "Amplitude of the variation.",
         per_spreadsheet: true,
         num_spreadsheets: 'any',
         sort_direction: -1},
        peak_time: {name: "Peak-time",
         value: "peak_times",
         description: "Time the peak value occurs at. The units are the numbers of the timepoints, i.e. 3.5 means half-way between timepoint 3 and timepoint 4.",
         per_spreadsheet: true,
         num_spreadsheets: 'any'},
    };

    let filter_data_list_base = [
        {values: function () {
                         // Grand maximum across both datasets within each row
                         if (app.spreadsheets.length === 0) { return []; }
                         let maxes = app.spreadsheets.map(function (spreadsheet) {
                                return maximums(spreadsheet.data);
                         });
                         return maxes[0].map( function(row, i) {
                            return Math.max.apply(null, maxes.map(function(max){return max[i];}));
                        });
                    },
                name: "Maximum value",
                independent: true,
                key:"max_value"},
        {values: function () {
                    // Grand means across both datasets within each row
                    // skipping over NaN/null values
                     if (app.spreadsheets.length === 0) { return []; }
                    let sums_ = app.spreadsheets.map(function(spreadsheet) {
                        let summed_rows = sums(spreadsheet.data);
                        return summed_rows;
                    });
                    let total_sums = sums(sums_, 0);

                    let nonnans = app.spreadsheets.map(function(spreadsheet) {
                        return numValids(spreadsheet.data);
                    });
                    let total_nonnans = sums(nonnans, 0);

                    let divide = function(a,b) { return a/b; };

                    let means = total_sums.map(function(sum, i) {
                        return sum / total_nonnans[i];
                    });
                    return means;
                },
                name: "Mean value",
                independent: true,
                key: "mean_value"},
        {values: function () {
                 if (app.spreadsheets.length === 0) { return []; }
                let missing = app.spreadsheets.map( function(spreadsheet) {
                     return numNaNTimepoints(spreadsheet.data, spreadsheet.x_values);
                });
                return maximums(missing, axis=0);
            },
            name: "Missing Timepoints",
            independent: true, // TODO: is this actually right?
            key: "missing_timepoints"},
    ];

    let app = new Vue({
        el: "#vue-app",
        data: {
            editing_filters: [],
            spreadsheets_by_id: {}, // spreadsheets by ID
            config: {
                spreadsheet_ids: [],
                original_spreadsheet_ids: [],
                selected_row: 0,
                sort_by: {stat_id: 'nitecap', spreadsheet_num: 0},
                filters: [],
                hide_filtered_rows: false,
                plot: {
                    fold_days: false,
                    style: "mean_points",
                    x_label_style: "infer",
                    include_zero: false,
                },
            },

            search_value: '',

            stats_table: stats_table,

            stats: {
                amplitude_ps: null,
                amplitude_qs: null,
                phase_ps: null,
                phase_qs: null,
                two_way_anova_ps: null,
                two_way_anova_qs: null,
                main_effect_ps: null,
                main_effect_qs: null,
            },

            download: {
                include_data: true,
                just_selected_rows: false,
                drop_filtered_rows: false,
                stats: {},
            },

            labels: [],
            timepoints_per_day: 0,
            num_days: 0,

            plot: {
                first_render: false,
            },

        },

        methods: {
            resetFilters: function(){
                this.editing_filters = [];
                this.config.filters.forEach(function(filter){
                    // make editing_filters a copy of the last-used filters
                    app.editing_filters.push(Object.assign({},filter));
                });
            },

            addFilter: function(){
                let new_id = 0; // Make filter keys
                if (this.editing_filters.length > 0){
                    new_id  = Math.max.apply(null, this.editing_filters.map( function(filter) {
                        return filter.id;
                    }))  + 1;
                }
                this.editing_filters.push( {variable: 'max_value', lower_bound:'', upper_bound:'', id: new_id} );
            },

            applyFilters: function() {
                // Copy the filters that we last ran
                // config.filters are the ones we actually filter on
                // needs to be deep copy so we json-ify it and back
                this.config.filters = JSON.parse(JSON.stringify(this.editing_filters));
            },

            redrawPlot: function() {
                let vm = this;
                // Update the Plotly plots of the feature profiles
                let traces = [];
                let colors = Plotly.d3.scale.category10();
                vm.spreadsheets.forEach(function (spreadsheet, idx) {
                    let row_index = vm.sort_order[vm.config.selected_row];
                    raw_y_values = spreadsheet.data[row_index];
                    if (raw_y_values === undefined) {
                        console.log("Could not find the y-values for row " + row_index);
                        return;
                    }

                    if (vm.config.plot.fold_days) {
                        plot_x_values = spreadsheet.x_values.map(function (x) {return x % spreadsheet.timepoints_per_day;});
                        plot_x_labels = plot_x_values.map(function(x) {return "Timepoint " + (x+1);});
                        plot_x_label_values = plot_x_labels.map(function(x,i) {return i;});
                    } else {
                        plot_x_values = spreadsheet.x_values;
                        plot_x_labels = spreadsheet.x_labels;
                        plot_x_label_values = spreadsheet.x_label_values;
                    }

                    let x_label_style = vm.config.plot.x_label_style;
                    if (x_label_style === 'none') {
                        plot_x_labels = plot_x_labels.map( function (x) {return '';} );
                    } else if (x_label_style === 'time') {
                        plot_x_labels = plot_x_labels.map( function(x,i) {
                            return "Timepoint " + (i % spreadsheet.timepoints_per_day + 1);
                        });
                    } else if (x_label_style === 'infer') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t);
                            });
                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    } else if (x_label_style === 'infer_wrapped') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t, true);
                            });

                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    }

                    let stats = rowStatsByTimepoint(raw_y_values, plot_x_values);

                    // Pick a color for this spreadsheet using Plotly's defaults from d3
                    let spreadsheet_color = colors(idx);
                    let marker_settings = {size: 12, symbol: 'circle-open'};


                    // Default values for the different plot styles to override
                    let trace = {
                        x: plot_x_values, y: raw_y_values,
                        mode: 'markers',
                        marker: marker_settings,
                        name: vm.descriptive_names[idx],
                        type: 'scatter',
                        'marker': {color: spreadsheet_color},
                        'line': {color: spreadsheet_color}
                    };

                    // Pick data and styling based off the plot_style_select value
                    let plot_style = vm.config.plot.style;
                    if (plot_style === "basketweave") {
                        // Make pairs of points that are adjacent in time to each other, for each dataset
                        column_pairs = [];
                        plot_x_values.forEach( function(x,i) {
                            for(let j = i+1; j < plot_x_values.length; j++) {
                                if (Math.abs(plot_x_values[j] - x) === 1) {
                                    column_pairs.push([i,j]);
                                }
                            }
                        });

                        paired_y_values = [];
                        for (let i in column_pairs) {
                            paired_y_values.push(raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null);
                        }

                        paired_x_values = [];
                        for (let i in column_pairs) {
                            paired_x_values.push(plot_x_values[column_pairs[i][0]], plot_x_values[column_pairs[i][1]], null);
                        }

                        trace.mode = 'lines+markers';
                        trace.x = paired_x_values;
                        trace.y = paired_y_values;
                    } else if (plot_style === "points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                    } else if (plot_style === "mean") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                    } else if (plot_style === "mean_points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                        traces.push({ // The mean value trace
                            x: stats.means.map( function (x,i) {return i;} ), // Just 0,1,2,3...
                            y: stats.means,
                            type: "scatter",
                            mode: "lines",
                            showlegend: false,
                            'line': {color: spreadsheet_color}
                        });
                    } else if (plot_style === "std") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                    } else if (plot_style === "std_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            showlegend: false,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style === "SEM") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                    } else if (plot_style === "SEM_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            showlegend: false,
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style == "repeated_measures") {
                        trace.mode = "lines";
                        // Collect the data by replicate
                        // Replicates have to be ordered the same
                        // I.e. First rep is first in all timepoints
                        let data_by_trace = [];
                        let rep_counts = [];
                        let last_value = 0;
                        plot_x_values.forEach( function(x,i) {
                            // Count how many we've seen before at this time
                            if (rep_counts[x] === undefined) {
                                rep_counts[x] = 0;
                            }
                            let rep_num = rep_counts[x];
                            rep_counts[x] += 1;

                            if (data_by_trace[rep_num] === undefined) {
                                data_by_trace[rep_num] = []; // Start new trace
                            }
                            // Add this reading to the trace for the replicate
                            data_by_trace[rep_num].push(raw_y_values[i]);
                        });


                        // Skip the default trace
                        trace = {};

                        // Add one trace per replicate
                        data_by_trace.forEach( function(trace,i) {
                            traces.push({
                                x: trace.map( function(x,i) {return i;}),
                                y: trace,
                                type: 'lines',
                                showlegend: false,
                                line: {color: spreadsheet_color},
                            });
                        });
                    } else if (plot_style == "cosinor") {
                        // number of sampling points used for plotting cosinor
                        const sampling_density = 120;

                        let t = [];
                        for (let i = 0; i <= sampling_density; i++)
                            t.push(24*vm.num_days*i/sampling_density);

                        let x0 = spreadsheet.cosinor_x0s[row_index];
                        let x1 = spreadsheet.cosinor_x1s[row_index];
                        let x2 = spreadsheet.cosinor_x2s[row_index];

                        let y = t.map(t => x0 + x1*Math.cos(2*Math.PI*t/24) + x2*Math.sin(2*Math.PI*t/24));

                        // rescale to match the other plots
                        for (let i = 0; i < t.length; i++)
                            t[i] *= spreadsheet.timepoints_per_day/24;

                        traces.push({
                            x: t, y,
                            mode: "lines",
                            type: "scatter",
                            line: {color: spreadsheet_color},
                            opacity: 0.2,
                            name: "Cosinor fit",
                        });
                    }

                    traces.push(trace);

                });

                let layout = {
                    hovermode: 'closest',
                    title: app.labels[app.sort_order[app.config.selected_row]],
                    legend: { orientation: 'h', y: -0.2 },
                    xaxis: {
                        ticktext: plot_x_labels,
                        tickvals: plot_x_label_values,
                        automargin: true,
                    },
                    yaxis: {
                        rangemode: vm.config.plot.include_zero ? 'tozero' : '',
                    }
                };

                if (vm.first_render) {
                    Plotly.newPlot('scatter_plot', traces, layout);
                    vm.first_render = false;
                } else {
                    Plotly.react('scatter_plot', traces, layout);
                }
            },

            downloadPlot: function() {
                let gd = document.getElementById('scatter_plot');
                Plotly.downloadImage(gd, {format: 'svg', filename: 'plot_' + (app.config.selected_row+1)});
            },


            selectRow: function(row) {
                this.config.selected_row = row;
            },

            onRowChange: function () {
                this.redrawPlot();

                $('#coarse_slider').slider('value', this.config.selected_row);
            },

            searchRows: function() {
                let search_value = this.search_value.toLowerCase().trim();

                // Pull out row indexes matching our search_value
                let matching_rows = app.labels.map( function(unused, index) {
                    let label = app.labels[app.sort_order[index]];
                    if (label.toLowerCase().indexOf(search_value) !== -1) {
                        return index;
                    }
                }).filter(isFinite);


                if (matching_rows.length === 0) {
                    console.log("Unfortunately no matching row found.");
                    // TODO: display something to the user
                    return;
                }

                // Find matches in rows past the current selection
                let matches_after = matching_rows.filter( function (i) {
                    return i > app.config.selected_row;
                } );

                let row = null;
                if (matches_after.length > 0) {
                    // First look for matches that are *after* our selected_row
                    // so that multiple button presses will cycle the selection through all matches
                    row = matches_after[0];
                } else {
                    // If that fails, grab the first matching row
                    row = matching_rows[0];
                }

                app.config.selected_row = row;
            },

            onShare: function() {
                // Open Modal to share the spreadsheet
                let vm = this;
                $.ajax({
                    url: "{{url_for('spreadsheets.share')}}",
                    data: JSON.stringify({'spreadsheet_ids': vm.config.original_spreadsheet_ids, 'config': vm.config}),
                    dataType: "json",
                    contentType: "application/json",
                    type: 'POST',
                    success: function (response) {
                        let url = "{{url_for('spreadsheets.share', _external=True)}}/" + response['share'];
                        $("#share_url").val(url);
                        $('#share_popup').modal()
                    },
                    error: function (request) {
                        error_message = $.parseJSON(request.responseText).error;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    }
                });
            },

            triggerDownloadPopup: function() {
                $("#download_popup").modal();
            },

            downloadSpreadsheet: function() {
                let vm = this;

                let download_rows = null;
                if (vm.download.just_selected_rows) {
                    download_rows = vm.sort_order.slice(0,vm.row_index);
                } else {
                    // All rows 0,1,2,...
                    download_rows = app.labels.map(function(x,i) { return i;} );
                }

                if (vm.download.drop_filtered_rows) {
                    download_rows = download_rows.filter(function(x) {
                        return !vm.filtered[x];
                    });
                }

                let download_columns = ['anova_p'];

                $.ajax({
                    url: "/spreadsheets/download",
                    data: JSON.stringify({
                        'spreadsheet_ids': vm.config.original_spreadsheet_ids,
                        'share_token': share_token,
                        'config': {
                            rows: download_rows,
                            columns: download_columns,
                            include_data: vm.download.include_data,
                        },
                    }),
                    dataType:"text",
                    contentType: "application/json",
                    type: "POST",
                    success: function (response) {
                        // Create a URL for it
                        console.log("Success", response);
                        let blob = new Blob([response]);
                        let url = URL.createObjectURL(blob);

                        // Trigger downloading of the URL by making an <a href ...> to it and clicking it
                        let anchor = document.createElement("a");
                        anchor.href = url;
                        anchor.download = "spreadsheet.txt";
                        document.body.appendChild(anchor);
                        anchor.click();
                        document.body.removeChild(anchor);

                        // Cleanup after 5mins
                        setTimeout(function () { URL.revokeObjectURL(url) }, 5*60*1000);
                    },
                    error: function(request) {
                        error_message = $.parseJSON(request.responseText).err;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    },
                });
            },

            shiftSpreadsheets: function () {
                // Shifts through the spreadsheets in order
                let spreadsheets = this.config.spreadsheet_ids;
                let first = spreadsheets[0];
                let tail = spreadsheets.slice(1);
                spreadsheets = tail.concat(first);
                this.config.spreadsheet_ids = spreadsheets;
            },

        },

        computed: {
            spreadsheets: function() {
                // Spreadsheets in the order they are displayed
                let vm = this;
                return vm.config.spreadsheet_ids.map(function(id) { return vm.spreadsheets_by_id[id]; } )
            },
            row_index: function() {
                if (this.sort_order !== null) {
                    return this.sort_order[this.config.selected_row];
                } else {
                    return this.config.selected_row;
                }

            },

            num_below: {
                get: function () {
                    return this.num_significant_below[this.config.selected_row];
                },
                set: function (val) {
                    val = parseInt(val);
                    if (val === null || this.num_significant_below === null) {
                        this.config.selected_row = 0;
                    }

                    let idx = this.num_significant_below.indexOf(val);
                    if (idx !== -1) {
                        this.config.selected_row = idx;
                    } else {
                        if (idx > Math.max(null, this.num_significant_below)) {
                            this.config.selected_row = this.num_siginificant_below.length;
                        } else {
                            this.config.selected_row = 0;
                        }
                    }
                }
            },

            sort_by: function() {
                return {
                    stat: this.stats_table[this.config.sort_by.stat_id],
                    stat_id: this.config.sort_by.stat_id,
                    spreadsheet_num: this.config.sort_by.spreadsheet_num,
                };
            },

            sort_function: function () {
                // We sort by the value specified in sort_by
                // We also have a 'secondary sort value' which is used purely as a null/not-null check
                // So if secondary sort value is null then we will sort the value to the end as if the main value were null
                // This solves the problem where q-values are null and being sorted to the front of the list particulary
                // from filters re-running q-values (which nulls them if filtered) and then being viewed without that filter

                // display_value is the value array that should be monotonic in the sort order
                // which are convenient for the user to look at.
                // In particular, Nitecap sorts by the nitecap statistic but users want to see the q-value
                // and other methods sort by p-value but users want q-value
                let vm = this;
                let variable = null;
                let secondary_variable = null;
                let display_variable = null;

                if (this.sort_by.stat.sort_value !== undefined) {
                    variable = this.sort_by.stat.sort_value;
                    if (this.sort_by.stat.secondary_sort_value !== undefined) {
                        secondary_variable = this.sort_by.stat.secondary_sort_value;
                    } else {
                        secondary_variable = variable;
                    }
                    display_variable = secondary_variable;
                } else if (typeof this.sort_by.stat.value === 'string') {
                    variable = this.sort_by.stat.value;
                    secondary_variable = variable;
                    display_variable = variable;
                } else {
                    variable = this.sort_by.stat.value.p;
                    secondary_variable = this.sort_by.stat.value.q;
                    display_variable = secondary_variable;
                }

                let sort_direction = 1;
                if (this.sort_by.stat.sort_direction !== undefined) {
                    sort_direction = this.sort_by.stat.sort_direction;
                }

                let value = null;
                let secondary_value = null;
                let display_value = null;
                if (vm.sort_by.spreadsheet_num !== undefined) {
                    if (vm.spreadsheets.length > 0) {
                        value = vm.spreadsheets[vm.sort_by.spreadsheet_num][variable];
                        secondary_value = vm.spreadsheets[vm.sort_by.spreadsheet_num][secondary_variable];
                        display_value = vm.spreadsheets[vm.sort_by.spreadsheet_num][display_variable];
                    }
                } else {
                    value = vm.stats[variable];
                    secondary_value = vm.stats[secondary_variable];
                    display_value = vm.stats[display_variable];
                }

                if (display_value !== null && vm.spreadsheets.length > 0) {
                    display_value = display_value.map( function(x,i) {
                        return secondary_value[i] && display_value[i];
                    });
                }


                let sorter = function (i,j) {
                    let a = secondary_value[i] && value[i];
                    let b = secondary_value[j] && value[j];
                    return compare(a ? a * sort_direction : a, // multiply by +/- 1 but not if null
                                   b ? b * sort_direction : b,
                                   i, j);
                };

                if ((value === null) || (secondary_value === null)) {
                     // Don't sort, the values we are sorting by haven't loaded yet
                     // display_value will just be the index
                    sorter = function(i,j) { return i - j; };
                    display_value = app.labels.map(function(x,i) {return i+1;});
                }

                return {"func": sorter, "value": value,  "display_value":display_value, "sort_direction": sort_direction};
            },

            sort_order: function () {
                let vm = this;
                if (this.labels.length == 0) { return []; } // No spreadsheets yet

                let sort_order =  this.labels.map( function(x,i) {return i;} );
                sort_order = sort_order.sort(this.sort_function.func);

                if (this.config.hide_filtered_rows) {
                    // Move filtered items from the sort_order to the back of the list  to hide them
                    let head = sort_order.filter( function(x) {return !vm.filtered[x];});
                    let tail = sort_order.filter( function(x) {return vm.filtered[x];});
                    sort_order = head.concat(tail);
                }

                return sort_order;
            },

            label_qs: function () {
                let value = this.sort_by.stat.value;

                if (typeof value === 'string') {
                    // No inherent q-value for this sort value
                    // drop the "Q:" label
                    return null;
                }

                if (this.sort_by.spreadsheet_num !== undefined) {
                    let sp = this.spreadsheets[this.sort_by.spreadsheet_num];
                    let vq = value.q;
                    let vals = sp ? sp[vq]: [];
                    return vals;
                } else {
                    return this.stats[value.q];
                }
            },

            filtered: function () {
                let vm = this;
                let filtered_out = this.labels.map( function (x) {return false;} );
                if (filtered_out.length == 0){  return filtered_out; }

                // Apply all filters
                this.config.filters.forEach(function(filter) {
                    let filter_value = filter.variable;

                    let lower_bound = parseFloat(filter.lower_bound);
                    let upper_bound = parseFloat(filter.upper_bound);

                    if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                    if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                    let idx = vm.filter_data_list.map(function(filter) {return filter.key;} ).indexOf(filter_value);
                    let values = vm.filter_data_list[idx].values();
                    if (values === null || values === undefined) { return; } // Haven't loaded values yet, can't filter by them

                    filtered_out = filtered_out.map( function (x,i) {
                        return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                    });
                });

                return filtered_out;
            },

            num_significant_below: function() {
                // Recompute the number of signifcant items below a cutoff
                // discards filtered out rows
                let num_significant_below = new Array(this.labels.length);
                let ctr = 0;
                this.labels.forEach(function(label, index) {
                    if (!app.filtered[app.sort_order[index]]) {
                        ctr++;
                    }

                    num_significant_below[index] = ctr;
                });
                return num_significant_below;
            },

            selected_rows: function() {
                // List of indices of the rows that are selected
                // (I.e. unfiltered, and below the significance cutoff
                let vm = this;

                return vm.sort_order.filter( function(row_num,rank) {
                    return (rank <= vm.config.selected_row) & (!vm.filtered[row_num]);
                } );
            },

            background_ids: function() {
                let vm = this;
                if (vm.spreadsheets.length == 0) { return []; }
                return vm.spreadsheets[0].labels.filter( function(label, i) {return !vm.spreadsheets[0].filtered[i];});
            },

            useable_stats: function () {
                // Only the stats from stats_table that apply to this context
                // i.e. the ones we have enough spreadsheets for
                let vm = this;
                let stats = {};
                for (key in this.stats_table) {
                    let stat = this.stats_table[key]
                    if ((stat.num_spreadsheets == 'multi')
                            && (vm.spreadsheets.length < 2)) {
                        continue; // Need 2 or more spreadsheets
                    }
                    stats[key] = stat;
                }
                return stats;
            },

            filter_data_list: function () {
                // List of filters including the 'special' ones declared in filters_data_list_base
                // and also those derived from the statistics in stats_table
                let vm = this;

                // Make a filter for each stat
                let stat_filters = [];
                for (key in vm.useable_stats) {
                    let stat = vm.useable_stats[key];
                    if (stat.per_spreadsheet) {
                        let just_one = vm.spreadsheets.length === 1;
                        vm.spreadsheets.forEach( function(spreadsheet, idx) {
                            if (typeof stat.value === 'string') {
                                let name = stat.name + ' ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value];},
                                     independent: false,
                                     key: name
                                });
                            } else {
                                let name = stat.name + ' p ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.p];},
                                     independent: false,
                                     key: name
                                });

                                name = stat.name + ' q ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.q];},
                                     independent: false,
                                     key: name
                                });
                            }
                        });
                    } else {
                        if (typeof stat.value === 'string') {
                            stat_filters.push({
                                 name: stat.name,
                                 values: function () {return vm.stats[stat.value];},
                                 independent: false,
                                 key: stat.name
                            });
                        } else {
                            stat_filters.push({
                                 name: stat.name + ' p',
                                 values: function () {return vm.stats[stat.value.p];},
                                 independent: false,
                                 key: stat.name + ' p',
                            });

                            stat_filters.push({
                                 name: stat.name + ' q',
                                 values: function () {return vm.stats[stat.value.q];},
                                 independent: false,
                                 key: stat.name + ' q',
                            });
                        }
                    }

                }

                // Return all filters, including the 'base' ones and the ones derived from our statistics
                return filter_data_list_base.concat(stat_filters);
            },

            timepoint_labels: function() {
                // Labels to use for timepoints 0,1,2,...,timepoints_per_day-1
                // ignoring the cycle/day number
                let vm = this;

                return vm.spreadsheets.map( function(spreadsheet) {
                    let times = spreadsheet.x_label_values.filter(function(t) {
                        if (t < spreadsheet.timepoints_per_day) {
                            return 1;
                        } else {
                            return 0;
                        }
                    });

                    // Try to infer if possible from column headers
                    let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                    if (inferred !== null) {
                        let headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t, true);
                        });
                        let labels = [];
                        spreadsheet.x_values.forEach( function (time,i) {
                            if (labels[time] === undefined) {
                                labels[time] = headings[i];
                            }
                        });
                        return labels;
                    }

                    // Otherwise we default to "Timepoint 1", etc.
                    return times.map( function(time) {
                        return "Timepoint " + (time + 1);
                    });
                });
            },

            day_and_time_labels: function() {
                // Labels to use for Day 1 Timepoint 1, etc.
                let vm = this;

                return vm.spreadsheets.map( function(spreadsheet) {
                    let times = spreadsheet.x_values;

                    // Try to infer if possible from column headers
                    let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_day);
                    let headings = null;
                    if (inferred !== null) {
                        headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t);
                        });
                    } else {
                        headings = times.map( function(time) {
                            return "Day " + (Math.floor(time / spreadsheet.timepoints_per_day) + 1) + " Timepoint " + (time % spreadsheet.timepoints_per_day + 1);
                        });
                    }

                    // Return only one heading per time
                    // by dropping repeated times
                    let labels = [];
                    times.forEach( function (time,i) {
                         if (labels[time] === undefined) {
                             labels[time] = headings[i];
                         }
                    });
                    return labels;
                });
            },

            descriptive_names: function() {
                // Descriptive names for spreadsheets
                // They are given descriptive names already but we want to isolate the part that is 'variable' between them
                // for easier display
                let names = this.spreadsheets.map( function(x) {return x.descriptive_name;});

                if (names.length < 2) {
                    // Can't simplify anything if there is only one!
                    return names;
                }

                let split_names = names.map( function(x) { return x.split(" ");});

                // Find the common prefix for all the names
                // eg names "Tom Dataset WT" and "Tom Dataset KO"
                // have prefix ["Tom", "Dataset"]
                let prefix = split_names[0];
                split_names.forEach(function(split_name) {
                    let no_mismatch_yet = true;
                    prefix = prefix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                });

                // Same as above, but find the common suffix for all the names
                let suffix = split_names[0].slice(0).reverse();
                split_names.forEach(function(split_name) {
                    split_name.reverse();
                    let no_mismatch_yet = true;
                    suffix = suffix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                    split_name.reverse(); // put it back
                });
                suffix = suffix.reverse();

                // Re-build the names with the prefix and suffix removed
                names = split_names.map( function(split_name) {
                    return split_name.slice(prefix.length, split_name.length - suffix.length).join(" ");
                });
                return names;
            },

            cutoff: {
                get: function() {
                    if (this.spreadsheets.length == 0) { return 0; }
                    return this.sort_function.display_value[this.sort_order[this.config.selected_row]];
                },
                set: function(value) {
                    let app = this;
                    let sort_values = app.sort_function.display_value;
                    let i = 0;
                    for(; i < sort_values.length; i++) {
                        let v = sort_values[app.sort_order[i]];
                        if ((app.sort_function.sort_direction * v) > (app.sort_function.sort_direction * value)) {
                            break;
                        }
                    }
                    app.config.selected_row = Math.max(i-1, 0);
                },
            },

        },

        watch: {
            row_index: "onRowChange",

            "config.plot": {
                handler: "redrawPlot",
                deep: true
            },
        },
    });
</script>
{% endblock %}
