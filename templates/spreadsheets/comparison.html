{% extends "base.html" %}
{% block content %}

<script>
    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    });

    PCA_WIDTH = 800;
    PCA_HEIGHT = 800;
    PCA_SYMBOL = "M 0,-15 A 15,15 0 0,1 15,0 L 0,0 Z M 15,0 A 15,15 0 0,1 -15,0 A 15,15 0 0,1 0,-15 L 0,-10 A 10,10 0 0,0 -10,0 A 10,10 0 0,0 10,0";

    function computeNumSignificantBelow() {
        // Recompute the number of signifcant items below a cutoff
        var ctr = 0;
        var set_significant_items = false;
        var significant_items = $('#significant_items')[0];
        $.each(spreadsheets[0].data, function (index, row) {
            if (!filtered[sort_order[index]]) {
                ctr++;
            }

            num_significant_below[index] = ctr;

            // Update number of significant items
            if (index >= row_index && !set_significant_items) {
                significant_items.value  = ctr;
                set_significant_items = true;
            }
        });
    }

    $(document).ready(function () {

        spreadsheet_ids = {{ spreadsheet_ids | safe }};

        spreadsheets = null;

        $.ajax({
            url: "/spreadsheets/get_spreadsheets",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                spreadsheets = response;

                onSpreadsheetLoad();
            },
            error: function(error) {
                console.log("Error loading spreadsheets");
                console.log(error);
            }
        });
    });

    function onSpreadsheetLoad() {
        labels = spreadsheets[0].labels; // Both have same labels, so we pull those out

        // Start with no filters since we don't save these to DB for comparison
        filters = [];
        filtered = spreadsheets[0].labels.map(function(x) {return false;});


        $("#primary_plot_name").text(spreadsheets[0].descriptive_names);

        var breakpoint = 0;

        // Wether we have drawn a plot yet, changes what Plotly wants
        let first_plot = false;

        // Handles to the error modal on base.html
        nitecap_error = $("#error-modal");
        nitecap_error_message = $("#error-modal-message");

        // Handles to the filter panel features
        apply_filters_button = $('#applyFilters');
        rerun_qvalues_button = $('#rerun_qvalues');
        hide_filtered_checkbox = document.getElementById("hide_filtered");
        filter_list = $('#filter_list');
        add_filter_button = $('#add_filter_button');

        fold_days_checkbox = document.getElementById('fold_days_checkbox');

        num_days = (Math.max.apply(null, spreadsheets[0].x_values) + 1) / spreadsheets[0].timepoints_per_day;
        if (num_days > 1) {
            $('#fold_days_box').show();
            $('#heatmap_fold_days_box').show();
        }

        // To be loaded later by ajax
        jtk_ps = [null,null];
        jtk_qs = [null,null];
        upside_ps = null;
        upside_qs = null;
        two_way_anova_ps = null;
        two_way_anova_qs = null;
        phase_ps = null;
        phase_qs = null;
        amplitude_ps = null;
        amplitude_qs = null;

        // List of the number of significant (non-filtered) features that are at or below a given index
        num_significant_below = labels.map(function(x,i) { return i+1;} );

        // Indexes to the order in which we will display the genes
        // default to the order in which they were sent
        sort_order = labels.map(function(x,i) {return i;});

        // Currently selected row from slider
        selected_row = breakpoint;

        y_values = [];
        trace_name = 'Nothing selected';
        marker_settings = {size: 12, symbol: 'circle-open'};


        function makeCoarseSlider(element, start_value, maximum) {
            element.slider({
                orientation: "horizontal",
                min: 0,
                value: start_value,
                step: 1,
                max: maximum,
                range: "min",
                slide: function (event, ui) {
                    selected_row = ui.value;
                    rowSelector.selectRow(parseInt(ui.value));
                    $('#row_selector').focus();
                }
            });
        }

        makeCoarseSlider($('#coarse_slider'), breakpoint, labels.length - 1);

        function updateStatsBox() {
            var row_index = sort_order[selected_row];

            $('#significant_items')[0].value = num_significant_below[selected_row];

            spreadsheets.forEach( function (spreadsheet, order) {
                // Update the "statistics" card
                $('#p_value' + order).html(formatNum(spreadsheet.ps[row_index], 4));
                $('#p_value' + order).prop('title', toString(spreadsheet.ps[row_index]));
                $('#q_value' + order).html(formatNum(spreadsheet.qs[row_index], 4));
                $('#q_value' + order).prop('title', toString(spreadsheet.qs[row_index]));
                $('#amplitude' + order).html(formatNum(spreadsheet.amplitudes[row_index], 4));
                $('#amplitude' + order).prop('title', toString(spreadsheet.amplitudes[row_index]));
                $('#anova_p' + order).html(formatNum(spreadsheet.anova_ps[row_index], 4));
                $('#anova_p' + order).prop('title', toString(spreadsheet.anova_ps[row_index]));
                $('#anova_q' + order).html(formatNum(spreadsheet.anova_qs[row_index], 4));
                $('#anova_q' + order).prop('title', toString(spreadsheet.anova_qs[row_index]));
                $('#peak_time' + order).html(formatNum(spreadsheet.peak_times[row_index], 4));
                $('#peak_time' + order).prop('title', toString(spreadsheet.peak_times[row_index]));

                if (spreadsheet.jtk_ps !== null && spreadsheet.jtk_qs !== null) {
                    $('#jtk_p' + order).html(formatNum(spreadsheet.jtk_ps[row_index], 4));
                    $('#jtk_p' + order).prop('title', toString(spreadsheet.jtk_ps[row_index]));
                    $('#jtk_q' + order).html(formatNum(spreadsheet.jtk_qs[row_index], 4));
                    $('#jtk_q' + order).prop('title', toString(spreadsheet.jtk_qs[row_index]));
                } else {
                    $('#jtk_p' + order).html("loading");
                    $('#jtk_p' + order).prop('title', "loading");
                    $('#jtk_q' + order).html("loading");
                    $('#jtk_q' + order).prop('title', "loading");
                }

                if (upside_ps !== null && upside_qs !== null) {
                    $('#upside_p' + order).html(formatNum(upside_ps[order][row_index], 4));
                    $('#upside_p' + order).prop('title', toString(upside_ps[order][row_index]));
                    $('#upside_q' + order).html(formatNum(upside_qs[order][row_index], 4));
                    $('#upside_q' + order).prop('title', toString(upside_qs[order][row_index]));
                } else {
                    $('#upside_p' + order).html("loading");
                    $('#upside_p' + order).prop('title', "loading");
                    $('#upside_q' + order).html("loading");
                    $('#upside_q' + order).prop('title', "loading");
                }
            });

            if (two_way_anova_ps !== null && two_way_anova_qs !== null) {
                $('#two_way_anova_p').html(formatNum(two_way_anova_ps[row_index], 4));
                $('#two_way_anova_p').prop('title', toString(two_way_anova_ps[row_index]));
                $('#two_way_anova_q').html(formatNum(two_way_anova_qs[row_index], 4));
                $('#two_way_anova_q').prop('title', toString(two_way_anova_qs[row_index]));
            } else {
                $('#two_way_anova_p').html("loading");
                $('#two_way_anova_p').prop('title', "loading");
                $('#two_way_anova_q').html("loading");
                $('#two_way_anova_q').prop('title', "loading");
            }

            if (phase_ps !== null && phase_qs !== null) {
                $('#phase_p').html(formatNum(phase_ps[row_index], 4));
                $('#phase_p').prop('title', toString(phase_ps[row_index]));
                $('#phase_q').html(formatNum(phase_qs[row_index], 4));
                $('#phase_q').prop('title', toString(phase_qs[row_index]));
            } else {
                $('#phase_p').html("loading");
                $('#phase_p').prop('title', "loading");
                $('#phase_q').html("loading");
                $('#phase_q').prop('title', "loading");
            }

            if (amplitude_ps !== null && amplitude_qs !== null) {
                $('#amplitude_p').html(formatNum(amplitude_ps[row_index], 4));
                $('#amplitude_p').prop('title', toString(amplitude_ps[row_index]));
                $('#amplitude_q').html(formatNum(amplitude_qs[row_index], 4));
                $('#amplitude_q').prop('title', toString(amplitude_qs[row_index]));
            } else {
                $('#amplitude_p').html("loading");
                $('#amplitude_p').prop('title', "loading");
                $('#amplitude_q').html("loading");
                $('#amplitude_q').prop('title', "loading");
            }
        }

        var redrawPlot = function() {
            // Update the Plotly plots of the feature profiles
            traces = [];
            var colors = Plotly.d3.scale.category10();
            spreadsheets.forEach(function (spreadsheet, idx) {
                var row_index = sort_order[selected_row];
                raw_y_values = spreadsheet.data[row_index];
                if (raw_y_values === undefined) {
                    console.log("Could not find the y-values for row " + row_index);
                    return;
                }

                fold_days = fold_days_checkbox.checked;
                if (fold_days) {
                    plot_x_values = spreadsheet.x_values.map(function (x) {return x % spreadsheet.timepoints_per_day;});
                    plot_x_labels = plot_x_values.map(function(x) {return "Timepoint " + (x+1);});
                    plot_x_label_values = plot_x_labels.map(function(x,i) {return i;});
                } else {
                    plot_x_values = spreadsheet.x_values;
                    plot_x_labels = spreadsheet.x_labels;
                    plot_x_label_values = spreadsheet.x_label_values;
                }

                let x_label_style = $('#plot_x_label_style').val();
                if (x_label_style === 'none') {
                    plot_x_labels = plot_x_labels.map( function (x) {return '';} );
                } else if (x_label_style === 'time') {
                    plot_x_labels = plot_x_labels.map( function(x,i) {
                        return "Timepoint " + (i % spreadsheet.timepoints_per_day + 1);
                    });
                } else if (x_label_style === 'infer') {
                    let inferred = inferColumnTimes(spreadsheet.column_headers, num_days, spreadsheet.timepoints_per_day);
                    if (inferred !== null) {
                        let headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t);
                        });
                        plot_x_labels = [];
                        plot_x_label_values = [];
                        spreadsheet.x_values.forEach( function (time,i) {
                            if (plot_x_labels[time] === undefined) {
                                plot_x_labels[time] = headings[i];
                                plot_x_label_values[time] = time;
                            }
                        });
                    }
                } else if (x_label_style === 'infer_wrapped') {
                    let inferred = inferColumnTimes(spreadsheet.column_headers, num_days, spreadsheet.timepoints_per_day);
                    if (inferred !== null) {
                        let headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t, true);
                        });

                        plot_x_labels = [];
                        plot_x_label_values = [];
                        spreadsheet.x_values.forEach( function (time,i) {
                            if (plot_x_labels[time] === undefined) {
                                plot_x_labels[time] = headings[i];
                                plot_x_label_values[time] = time;
                            }
                        });
                    }
                }

                var stats = rowStatsByTimepoint(raw_y_values, plot_x_values);

                // Pick a color for this spreadsheet using Plotly's defaults from d3
                var spreadsheet_color = colors(idx);

                // Default values for the different plot styles to override
                var trace = {
                    x: plot_x_values, y: raw_y_values,
                    mode: 'markers',
                    marker: marker_settings,
                    name: spreadsheet.descriptive_name,
                    type: 'scatter',
                    'marker': {color: spreadsheet_color},
                    'line': {color: spreadsheet_color}
                };

                // Pick data and styling based off the plot_style_select value
                var plot_style = $('#plot_style_select').val();
                if (plot_style === "basketweave") {
                    // Make pairs of points that are adjacent in time to each other, for each dataset
                    column_pairs = [];
                    plot_x_values.forEach( function(x,i) {
                        for(var j = i+1; j < plot_x_values.length; j++) {
                            if (Math.abs(plot_x_values[j] - x) === 1) {
                                column_pairs.push([i,j]);
                            }
                        }
                    });

                    paired_y_values = [];
                    for (var i in column_pairs) {
                        paired_y_values.push(raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null);
                    }

                    paired_x_values = [];
                    for (var i in column_pairs) {
                        paired_x_values.push(plot_x_values[column_pairs[i][0]], plot_x_values[column_pairs[i][1]], null);
                    }

                    trace.mode = 'lines+markers';
                    trace.x = paired_x_values;
                    trace.y = paired_y_values;
                } else if (plot_style === "points") {
                    trace.x = plot_x_values;
                    trace.y = raw_y_values;
                } else if (plot_style === "mean") {
                    trace.mode = "lines";
                    trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                    trace.y = stats.means;
                } else if (plot_style === "mean_points") {
                    trace.x = plot_x_values;
                    trace.y = raw_y_values;
                    traces.push({ // The mean value trace
                        x: stats.means.map( function (x,i) {return i;} ), // Just 0,1,2,3...
                        y: stats.means,
                        type: "scatter",
                        mode: "lines",
                        showlegend: false,
                        'line': {color: spreadsheet_color}
                    });
                } else if (plot_style === "std") {
                    trace.mode = "lines";
                    trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                    trace.y = stats.means;
                    trace.error_y = {type: 'data', array:stats.stds, visible:true};
                } else if (plot_style === "SEM") {
                    trace.mode = "lines";
                    trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                    trace.y = stats.means;
                    trace.error_y = {type: 'data', array:stats.sems, visible:true};
                }

                traces.push(trace);

            });

            var layout = {
                hovermode: 'closest',
                title: labels[sort_order[selected_row]],
                legend: { orientation: 'h', y: -0.2 },
                xaxis: {
                    ticktext: plot_x_labels,
                    tickvals: plot_x_label_values,
                    automargin: true
                }
            };

            if (first_plot) {
                Plotly.newPlot(scatter_plot, traces, layout);
                first_plot = false;
            } else {
                Plotly.react(scatter_plot, traces, layout);
            }
        };

        $('#plot_style_select').change(redrawPlot);
        $('#plot_x_label_style').change(redrawPlot);
        fold_days_checkbox.addEventListener('change', redrawPlot);

        $('#download_plot').click(function() {
            var gd = document.getElementById('scatter_plot');
            Plotly.downloadImage(gd, {format: 'svg', filename: 'plot_' + (selected_row+1)});
        });

        // Make the row selector
        function onRowSelect(selection) {
            selected_row = selection;

            // Update the coarse slider
            $("#coarse_slider").slider("option", "value", selected_row);

            updateStatsBox();
            redrawPlot();
        }
        var num_row_selections = 21; // Show this many rows at once
        rowSelector = makeRowSelector($('#row_selector')[0],  labels, spreadsheets[0].qs, filtered, sort_order, num_row_selections, onRowSelect);
        rowSelector.selectRow(breakpoint);

        $("#hide_filtered").change( function() {
            let below = num_significant_below[selected_row];

            // Redo the ordering of the rows to move the filtered ones to the back
            sortRows();

            // Update the row selected to account for the same number of rows chosen as before
            // so that we don't change which row was selected
            // though this does move the viewed rows to contain the selected row even if it wasn't visible before
            let new_index = num_significant_below.indexOf(below);
            rowSelector.selectRow(new_index);
        });

        // Heatmap
        let updateHeatmap = function() {
            $('#heatmap_block').hide();
            $('#download_heatmap').hide();
            $('#heatmap_controls').hide();
            $('#cutoff').html(num_significant_below[selected_row]);

            let selected_indexes = sort_order.filter( function(row_num,rank) {
                return (rank <= selected_row) & (!filtered[row_num]);
            } );
            let phase_sorted_order = selected_indexes.sort( function (i,j) {
                return compare(spreadsheets[0].peak_times[i], spreadsheets[0].peak_times[j], i,j);
            } );

            let zScoreData = spreadsheets.map(function(spreadsheet) {
                return computeZScores(phase_sorted_order)(spreadsheet.data);
            });

            let times = spreadsheets.map(function(spreadsheet){ return spreadsheet.x_values; });

            let fold_days = $('#heatmap_fold_days').is(':checked');
            if (fold_days) {
                times = spreadsheets.map(function(spreadsheet) {
                    return spreadsheet.x_values.map(function(x) {
                        return x % spreadsheet.timepoints_per_day;
                    });
                });
            }

            heatmap_labels = phase_sorted_order.map( function(i) {
                return labels[i];
            } );

            let heatmap_options = {
                modeBarButtonsToAdd: [{
                    name: 'download in SVG format',
                    icon: Plotly.Icons.camera,
                    click: function (gd) {
                        Plotly.downloadImage(gd, {format: 'svg'})
                    }
                }]
            };


            let combine_replicates = $('#combine_replicates').is(':checked');
            if (combine_replicates) {
                // Average all z-scores at the same timepoint together
                let meanZScores = zScoreData.map( function(zscores,idx) {
                    return meanByTimepoints(zscores, times[idx]);
                });

                heatmap_data = meanZScores;

                if (fold_days) {
                    heatmap_x_values = meanZScores.map( function (zscores) {
                        return zscores[0].map( function(x,i) {return "Timepoint " + (i + 1);});
                    });
                } else {
                    heatmap_x_values = spreadsheets.map( function(spreadsheet) {return spreadsheet.x_labels;} );
                }
            } else {
                if (fold_days) {
                    let x_sort_order = times.map( function(times_) {
                        return times_.map( function(x,i) {return i;} ).sort( function (i,j) {
                            return compare(times_[i],times_[j],i,j);
                        } );
                    });

                    heatmap_data = zScoreData.map( function(zscores,idx) {
                        return zscores.map( function(row) {
                            return x_sort_order[idx].map( function(i) {
                                return row[i];
                            });
                        } );
                    });

                    let rep_counts = [];
                    heatmap_x_values = x_sort_order.map( function(x_sort_order_, idx) {
                        return x_sort_order_.map( function(i) {
                            let time = times[idx][i];
                            if (rep_counts[time] === undefined) {
                                rep_counts[time] = 0;
                            }
                            rep_counts[time] += 1;

                            return "Timepoint " + (time + 1) + " Rep " + rep_counts[time];
                        });
                    });
                } else {
                    heatmap_data = zScoreData;

                    heatmap_x_values = spreadsheets.map( function(spreadsheet, idx) {
                        let rep_counts = [];
                        return spreadsheet.x_values.map( function(time) {
                            if (rep_counts[time] === undefined) {
                                rep_counts[time] = 0;
                            }
                            rep_counts[time] += 1;
                            let day = Math.floor(time / spreadsheet.timepoints_per_day) + 1;
                            let time_of_day = time % spreadsheet.timepoints_per_day + 1;
                            return "Day " + day + " Timepoint " + time_of_day + " Rep " + rep_counts[time];
                        });
                    });
                }
            }

            // Find max/min values so that we can center the colormap with 0=middle
            let maxInRow = heatmap_data.map( function(spreadsheet) { return spreadsheet.map(array_max); });
            let minInRow = heatmap_data.map( function(spreadsheet) { return spreadsheet.map(array_min); });

            let max = Math.max.apply(null, maxInRow.map(array_max));
            let min = Math.min.apply(null, minInRow.map(array_min));
            let limit = Math.max(Math.abs(min), Math.abs(max));

            let y_vals =  heatmap_labels.map(function (x,i) {return i;});
            let show_labels = $('#heatmap_show_labels').is(':checked');

            let heatmap_values = spreadsheets.map( function(spreadsheet, idx) {
                let colorbar = {};
                if (idx === 0){
                    colorbar = {
                        title: 'Z Score',
                        titleside: 'right'
                    };
                }
                return {
                    x: heatmap_x_values[idx],
                    y: y_vals,
                    z: heatmap_data[idx],
                    type: 'heatmap',
                    xaxis: "x" + (idx+1),
                    yaxis: "y",
                    zmin: -1 * limit,
                    zmax: limit,
                    colorbar: colorbar
                };
            });

            let heatmap_layout = {
                height: 700,
                width: 1200,
                margin: {
                    l: 200,
                    r: 5,
                    b: 175,
                    t: 20
                },
                pad: 4,
                yaxis: {
                    tickmode: "array",
                    ticktext: heatmap_labels,
                    tickvals: y_vals,
                    showticklabels: show_labels,
                    ticks: ''
                },
                grid: {
                    rows: 1,
                    columns: 2
                }
            };

            Plotly.newPlot('heatmap', heatmap_values, heatmap_layout, heatmap_options);

            $('#heatmap_block').show();
            $('#download_heatmap').show();
            $('#heatmap_controls').show();
        };
        $('#set_breakpoint').click(updateHeatmap);

        $('#download_heatmap').click(function() {
            var gd = document.getElementById('heatmap');
            Plotly.downloadImage(gd, {format: 'svg', filename: 'heatmap_' + (selected_row+1)});
        });

        $('#combine_replicates').change(updateHeatmap);
        $('#heatmap_fold_days').change(updateHeatmap);
        $('#heatmap_show_labels').change(updateHeatmap);

        // Configuration of the filters
        filter_data_list = [
            ["max_value", {values: function () {
                                     // Grand maximum across both datasets within each row
                                     let maxes = spreadsheets.map(function (spreadsheet) {
                                            return maximums(spreadsheet.data);
                                     });
                                     return maxes[0].map( function(row, i) {
                                        return Math.max(maxes[0][i], maxes[1][i]);
                                    });
                                },
                            name: "Maximum value",
                            independent: true}],
            ["mean_value", {values: function () {
                                // Grand means across both datasets within each row
                                // TODO: better support for missing values (different numbers missing in each spreadsheet)
                                let means = spreadsheets.map(function (spreadsheet) {
                                    return means(spreadsheet.data);
                                });
                                let a = spreadsheets[0].data[0].length;
                                let b = spreadsheets[1].data[0].length;
                                return means[0].map( function(row, i) {
                                    return (means[0][i]*a + means[1][i]*b) / (a + b);
                                });
                            },
                            name: "Mean value",
                            independent: true}],
            ["nitecap_p0", {values: function () { return spreadsheets[0].ps; },
                            name: "Nitecap p Primary",
                            independent: false}],
            ["nitecap_q0", {values: function () { return spreadsheets[0].qs; },
                            name: "Nitecap q Primary",
                            independent: false}],
            ["jtk_p0", {values: function () { return spreadsheets[0].jtk_ps; },
                            name: "JTK p Primary",
                            independent: false}],
            ["jtk_q0", {values: function () { return spreadsheets[0].jtk_qs; },
                            name: "JTK q Primary",
                            independent: false}],
            ["anova_p0", {values: function () { return spreadsheets[0].anova_ps; },
                            name: "ANOVA p Primary",
                            independent: false}],
            ["anova_q0", {values: function () { return spreadsheets[0].anova_qs; },
                            name: "ANOVA q Primary",
                            independent: false}],
            ["amplitude0", {values: function () { return spreadsheets[0].amplitudes; },
                            name: "Amplitude Primary",
                            independent: false}],
            ["peak_time0", {values: function () { return spreadsheets[0].peak_times; },
                            name: "Peak time Primary",
                            independent: false}],
            ["nitecap_p1", {values: function () { return spreadsheets[1].ps; },
                            name: "Nitecap p Secondary",
                            independent: false}],
            ["nitecap_q1", {values: function () { return spreadsheets[1].qs; },
                            name: "Nitecap q Secondary",
                            independent: false}],
            ["jtk_p1", {values: function () { return spreadsheets[1].jtk_ps; },
                            name: "JTK p Secondary",
                            independent: false}],
            ["jtk_q1", {values: function () { return spreadsheets[1].jtk_qs; },
                            name: "JTK q Secondary",
                            independent: false}],
            ["anova_p1", {values: function () { return spreadsheets[1].anova_ps; },
                            name: "ANOVA p Secondary",
                            independent: false}],
            ["anova_q1", {values: function () { return spreadsheets[1].anova_qs; },
                            name: "ANOVA q Secondary",
                            independent: false}],
            ["amplitude1", {values: function () { return spreadsheets[1].amplitudes; },
                            name: "Amplitude Secondary",
                            independent: false}],
            ["peak_time1", {values: function () { return spreadsheets[1].peak_times; },
                            name: "Peak time Secondary",
                            independent: false}],
            ["two_way_anova_p", {values:function () { return two_way_anova_ps; },
                                  name: "Two-way ANOVA p",
                                  independent: false}],
            ["two_way_anova_q", {values:function () { return two_way_anova_qs; },
                                  name: "Two-way ANOVA q",
                                  independent: false}],
            ["phase_difference_q", {values:function () { return phase_ps; },
                                  name: "Phase difference p",
                                  independent: false}],
            ["phase_difference_p", {values:function () { return phase_qs; },
                                  name: "Phase difference q",
                                  independent: false}],
            ["amplitude_difference_p", {values:function () { return amplitude_ps; },
                                  name: "Amplitude difference p",
                                  independent: false}],
            ["amplitude_difference_q", {values:function () { return amplitude_qs; },
                                  name: "Amplitude difference q",
                                  independent: false}]
            ];
        // Build a Map for convenience of the filter data
        filter_data = new Map();
        filter_data_list.forEach( function(pair) {
            filter_data.set(pair[0], pair[1]);
        });

        function updateFilterList() {
            return;

            // Get raw DOM element, not the jQueried version
            let filter_list_element = filter_list.get(0);

            if (filters.length == 0) {
                // Deafult to empty max-value filter
                filters = [["max_value", NaN, NaN]];
            }

            // Clear out the filter list before remaking it
            while (filter_list_element.lastChild) {
                filter_list_element.removeChild(filter_list_element.lastChild);
            }

            filters.forEach( function (filter, i) {
                // Create the filter entries in the filter list

                let variable = filter[0];
                let lower_bound = filter[1];
                let upper_bound = filter[2];

                let filter_item_row = document.createElement('div');
                filter_item_row.className = "row";
                filter_list_element.appendChild(filter_item_row);

                let filter_item_div = document.createElement('div');
                filter_item_div.className = "col form-inline filter_item";
                filter_item_row.appendChild(filter_item_div);

                let filter_lb = document.createElement('input');
                filter_lb.className = "form-control form-control-sm m-1 filter_lower_bound";
                filter_lb.style="width: 85px";
                filter_lb.setAttribute('aria-label', "Lower bound for filter " + i);
                if (!isNaN(lower_bound) && lower_bound !== null) {
                    filter_lb.value = '' + lower_bound;
                }
                filter_lb.addEventListener('change', readFilters);
                filter_item_div.appendChild(filter_lb);

                let less_than_symbol = "\u2264"; // Actaully less than or equal to symbol
                filter_item_div.appendChild(document.createTextNode(less_than_symbol));

                let filter_value_selector = document.createElement('select');
                filter_value_selector.className = "form-control form-control-sm m-1 filter_value_selector";
                filter_data.forEach(function (filter, key) {
                    let option = document.createElement('option');
                    option.setAttribute("value", key);
                    option.innerHTML = filter.name;
                    filter_value_selector.appendChild(option);
                });
                filter_value_selector.value = variable;
                filter_value_selector.setAttribute('aria-label', 'Feature to filter on for filter ' + i);
                filter_item_div.appendChild(filter_value_selector);

                filter_item_div.appendChild(document.createTextNode(less_than_symbol));

                let filter_ub = document.createElement('input');
                filter_ub.className = "form-control form-control-sm m-1 filter_upper_bound";
                filter_ub.style="width: 85px";
                if (!isNaN(upper_bound) && upper_bound !== null) {
                    filter_ub.value = '' + upper_bound;
                }
                filter_ub.addEventListener('change', readFilters);
                filter_ub.setAttribute('aria-label', "Upper bound for filter " + i);
                filter_item_div.appendChild(filter_ub);

                let remove_button = document.createElement('button');
                remove_button.className = "btn btn-default";
                remove_button.setAttribute('aria-label', 'Remove filter ' + i);
                remove_button.setAttribute('title', 'Remove filter');

                function make_listener(index) {
                    return function () {
                        filters = filters.filter(function (x,j) { return j !== index; } );
                        updateFilterList();
                    };
                }
                remove_button.addEventListener('click', make_listener(i));

                let icon  = document.createElement('span');
                icon.className = 'far fa-minus-square';
                remove_button.appendChild(icon);
                filter_item_div.appendChild(remove_button);
            });
        }
        updateFilterList();

        add_filter_button.click( function () {
            filters.push( ['max_value', null, null] );
            updateFilterList();
        });

        // Applying Filters
        function applyFilters() {
            return;
            // Copy the filters that we last ran
            ran_filters = filters.slice();

            let filtered_out = labels.map( function (x) {return false;} );

            // Apply all filters
            filters.forEach(function(filter) {
                var filter_value = filter[0];

                var lower_bound = filter[1];
                var upper_bound = filter[2];

                if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                let values = filter_data.get(filter_value).values();
                filtered_out = filtered_out.map( function (x,i) {
                    return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                });
            });

            filtered = filtered_out;

            if (hide_filtered_checkbox.checked) {
                // Move filtered items from the sort_order to the back of the list  to hide them
                let head = sort_order.filter( function(x) {return !filtered[x];});
                let tail = sort_order.filter( function(x) {return filtered[x];});
                sort_order = head.concat(tail);
            }

            computeNumSignificantBelow();

            // Update row selector display to reflect the new filtering
            rowSelector.filterRows(filtered);
        }

        computeNumSignificantBelow();

        function readFilters() {
            // Reads the values from the DOM into the filters list
            filters = filter_list.find(".filter_item").map( function() {
                var filter = $(this);

                var value = filter.find(".filter_value_selector").val();

                var lower_bound = parseFloat(filter.find(".filter_lower_bound").val());
                var upper_bound = parseFloat(filter.find(".filter_upper_bound").val());

                return [[value, lower_bound, upper_bound]];
            }).toArray();
        }

        onApplyFilters = function(rerun_qvalues) {
            // First gather all the filters the user has entered
            readFilters();

            // Apply the filters to the rows
            // and also updates all the appropriate display
            sortRows();

            // Update the DB with the features
            // and if rerunning q-values, ask server to do that
            // TODO: currently no ajax to rerun q-values no matter
            //$.ajax();

            //if (rerun_qvalues) {
            //    rerun_qvalues_button.prop('disabled', true);
            //    rerun_qvalues_button.html(
            //        "<span class='spinner-border spinner-border-sm text-light mr-2' role='status' aria-hidden='true'>" +
            //        "</span>Computing...");
            //}
        };
        apply_filters_button.click( function () {onApplyFilters(false);} );

        rerun_qvalues_button.click( function () {
            // Check if any filters violate assumptions of rerunning the q-values
            let invalid = false;
            filters.forEach( function (filter) {
                if (!filter_data.get(filter[0]).independent) {
                    let has_lb = !(isNaN(filter[1]) || (filter[1] === null));
                    let has_ub = !(isNaN(filter[2]) || (filter[2] === null));
                    if (has_lb || has_ub) {
                        invalid = true;
                    }
                }
            } );

            if (invalid) {
                // Popup a modal to issue the warning before proceeding
                $('#rerun_qvalues_warning').modal();
            } else {
                // All good, apply the filters and rerun-qvalues
                onApplyFilters(true);
            }
        });

        let searchRows = function() {
            let search_value = $('#row_search_box').val().toLowerCase();

            // Pull out row indexes matching our search_value
            let matching_rows = labels.map( function(unused, index) {
                let label = labels[sort_order[index]];
                if (label.toLowerCase().indexOf(search_value) !== -1) {
                    return index;
                }
            }).filter(isFinite);


            if (matching_rows.length === 0) {
                console.log("Unfortunately no matching row found.");
                // TODO: display something to the user
                return;
            }

            // Find matches in rows past the current selection
            let matches_after = matching_rows.filter( function (i) {
                return i > selected_row;
            } );

            let row = null;
            if (matches_after.length > 0) {
                // First look for matches that are *after* our selected_row
                // so that multiple button presses will cycle the selection through all matches
                row = matches_after[0];
            } else {
                // If that fails, grab the first matching row
                row = matching_rows[0];
            }

            rowSelector.selectRow(row);
        };
        $('#search_button').click( searchRows);
        $('#row_search_box').on("keydown", function (evt) {
            if (evt.keyCode === 13) { // On Enter key press
                searchRows();
            }
        });

        var sorters = {
            "nitecap": function(i,j) {
                var a = spreadsheets[0].tds[i];
                var b = spreadsheets[0].tds[j];
                return compare(a,b,i,j);
            },
            "anova": function (i,j) {
                // Sort anova p-values in ascending order
                var a = spreadsheets[0].anova_ps[i];
                var b = spreadsheets[0].anova_ps[j];
                return compare(a,b,i,j);
            },
            "jtk": function (i,j) {
                // Sort jtk p-values in ascending order
                var a = spreadsheets[0].jtk_ps[i];
                var b = spreadsheets[0].jtk_ps[j];
                return compare(a,b,i,j);
            },
            "amplitude": function (i,j) {
                // Sort amplitude values in descending order
                var a = -spreadsheets[0].amplitudes[i];
                var b = -spreadsheets[0].amplitudes[j];
                return compare(a,b,i,j);
            },
            "upside": function (i,j) {
                // Sort by ascending order
                var a = upside_ps[0][i];
                var b = upside_ps[0][j];
                return compare(a,b,i,j);
            },
            "two_way_anova": function (i,j) {
                // Sort by ascending order
                var a = two_way_anova_ps[i];
                var b = two_way_anova_ps[j];
                return compare(a,b,i,j);
            },
            "amplitude_change": function (i,j) {
                // Sort by ascending order
                var a = amplitude_ps[i];
                var b = amplitude_ps[j];
                return compare(a,b,i,j);
            },
            "phase_change": function (i,j) {
                // Sort by ascending order
                var a = phase_ps[i];
                var b = phase_ps[j];
                return compare(a,b,i,j);
            }
        };

        function updateRowLabels() {
            var sorter = $('#sort_select').val();
            if (sorter === 'jtk') {
                rowSelector.makeRowLabels(labels, spreadsheets[0].jtk_qs);
            } else if (sorter === 'upside') {
                rowSelector.makeRowLabels(labels, upside_qs[0]);
            } else if (sorter === 'two_way_anova') {
                rowSelector.makeRowLabels(labels, two_way_anova_qs);
            } else if (sorter === 'anova') {
                rowSelector.makeRowLabels(labels, spreadsheets[0].anova_qs);
            } else if (sorter === 'amplitude_change') {
                rowSelector.makeRowLabels(labels, amplitude_qs);
            } else if (sorter === 'phase_change') {
                rowSelector.makeRowLabels(labels, phase_qs);
            } else {
                rowSelector.makeRowLabels(labels, spreadsheets[0].qs);
            }
        }

        var sortRows = function () {
            var sorter = $('#sort_select').val();
            sort_order = labels.map( function(x,i) {return i;} );
            sort_order = sort_order.sort( sorters[sorter] );

            applyFilters();

            rowSelector.setSortOrder(sort_order);
            rowSelector.selectRow(selected_row);

            updateRowLabels();
        };
        $('#sort_select').change( sortRows );

        $('#significant_items').change(function () {
            let row = Math.round(this.value) -1;
            console.log("Significant items changed to " + row);

            if (row < 0) {
                row = 0;
            } else if (row > labels.length-1) {
                row = labels.length-1;
            }

            rowSelector.selectRow(row);
        });

        // Load the JTK values for each spreadsheet
        $.ajax({
            url: "{{url_for('spreadsheets.get_jtk')}}",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                let jtk_ps = response['jtk_ps'];
                let jtk_qs = response['jtk_qs'];

                // Find the right spreadsheets and put each jtk_ps/qs into it
                spreadsheet_ids.forEach(function(id, i) {
                    spreadsheets.forEach(function(spreadsheet) {
                        if (spreadsheet.spreadsheet_id == id) {
                            spreadsheet.jtk_ps = jtk_ps[i];
                            spreadsheet.jtk_qs = jtk_qs[i];
                        }
                    });
                });

                $('#sort_select option[value="jtk"]').removeAttr("disabled");

                updateStatsBox();
            },
            error: function(error) {
                console.log("Error loading JTK values");
                console.log(error);
            }
        });

        // Load the Upside values
        $.ajax({
            url: "{{url_for('spreadsheets.get_upside')}}",
            data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids}),
            dataType: 'text json',
            contentType: 'application/json',
            type: 'POST',
            success: function(response) {
                upside_ps = response['upside_ps'];
                upside_qs = response['upside_qs'];
                two_way_anova_ps = response['two_way_anova_ps'];
                two_way_anova_qs = response['two_way_anova_qs'];
                phase_ps = response['phase_ps'];
                phase_qs = response['phase_qs'];
                amplitude_ps = response['amplitude_ps'];
                amplitude_qs = response['amplitude_qs'];

                $('#sort_select option[value="upside"]').removeAttr("disabled");
                $('#sort_select option[value="two_way_anova"]').removeAttr("disabled");
                $('#sort_select option[value="phase_change"]').removeAttr("disabled");
                $('#sort_select option[value="amplitude_change"]').removeAttr("disabled");

                updateStatsBox();
            },
            error: function(error) {
                console.log("Error loading upside values");
                console.log(error);
                response = error.responseText;
            }
        });

        // Cycle current primary to back of array and refresh relevant data
        $("#toggle_primary").click(function() {
            first_spreadsheet = spreadsheets.shift();
            spreadsheets.push(first_spreadsheet);
            $("#primary_plot_name").text(spreadsheets[0].descriptive_name);
            sortRows();

            if ($('#heatmap_block').is(":visible")) {
                updateHeatmap();
            }
        });


        // PCA plot
        function setPCAPointStyles() {
            let pca_plot = Plotly.d3.select("#pca_plot");
            let points = pca_plot.selectAll(".scatter").selectAll("path");

            // remove any existing background circles
            pca_plot.selectAll(".scatter").selectAll("circle").remove();
            // Add in background circles
            points.each(function(x,i,j) {

                let t = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                t.setAttributeNS(null, "r", "13");
                t.setAttributeNS(null, "transform", this.getAttributeNS(null,"transform"));
                t.setAttributeNS(null, "fill", "white");
                this.parentNode.insertBefore(t, this);
            });

            // Set the shape of the points to be the "colored wedge" shape
            points.attr("d", PCA_SYMBOL);
            // Rotate the colored wedge by the time (x-value)
            points.attr("transform", function(x,i,j) {
                let spreadsheet = spreadsheets[j];
                let rotation = (spreadsheet.x_values[i] % spreadsheet.timepoints_per_day) / spreadsheet.timepoints_per_day * 360 - 45;

                let curr_transform = this.getAttribute("transform");
                if (curr_transform.indexOf("rotate") < 0) {
                    return curr_transform + " rotate(" + rotation + ")";
                } else {
                    return curr_transform;
                }
            });

            setPCALegend();
        }

        function setPCALegend() {
            let pca_plot = Plotly.d3.select('#pca_plot');
            let info_layer = pca_plot.select('.infolayer');


            // Remove any existing legend
            info_layer.selectAll('.pca_legend').remove();
            info_layer.selectAll('.pca_legend_bg').remove();

            let times = spreadsheets[0].x_label_values.filter(function(t) { if (t < spreadsheets[0].timepoints_per_day) { return 1; } else { return 0; } });
            let labels = times.map( function(t) {return "Timepoint " + (t + 1);} );

            if (times.length > 6) {
                // If there are too many points to show all in the legend
                // then downsample them to be a more reasonable number
                let n = Math.floor(times.length/6);
                times = times.filter( function (x,i) { return (i % n) === 0; });
                labels = labels.filter( function (x,i) { return (i % n) === 0; });
            }

            let margin = 5;
            let entry_height = 30;
            let radius = 15;
            let legend_width = 200;
            let legend_height = (entry_height+margin)*times.length + margin;
            let x = 800;
            let y = 50;

            // Expand the SVG to fit the legend
            pca_plot.selectAll('.main-svg').attr('width', PCA_WIDTH + margin*2 + legend_width);

            // Background rect
            let bg = info_layer.append('rect')
                        .attr('class', 'pca_legend_bg')
                        .attr('x', x + margin)
                        .attr('y', y + margin)
                        .attr('width', legend_width)
                        .attr('height', legend_height)
                        .attr('fill', 'rgb(238,238,238)');

            // Group containing all the entries in the legend, translated to be inside the bg rect
            let g = info_layer.append('g')
                    .attr('class', 'pca_legend')
                    .attr('transform', 'translate(' + (x + 2*margin) + "," + (y + 2*margin) + ")");

            // Each entry is a path (the symbol, appropriately rotated) and text describing the time
            let entries = g.selectAll('g')
                            .data(times)
                           .enter()
                             .append('g')
                             .attr('transform', function (x,i) {return 'translate(0,'+ (i*(entry_height+margin)) + ')';});
            entries.append('path')
                    .attr('transform', function (x,i) {
                            return 'translate(' + radius + ',' + radius + ')'
                                  +'rotate(' + ((times[i] % spreadsheets[0].timepoints_per_day) / spreadsheets[0].timepoints_per_day * 360 - 45) + ')';
                        })
                    .attr('d', PCA_SYMBOL)
                    .attr('fill', 'rgb(127,127,127)');

            entries.append('text')
                    .attr('x',2*radius + margin)
                    .attr('transform', 'translate(0,' + radius + ')')
                    .attr('dy', '0.4em')
                    .text(function (x,i) { return labels[i]; });
        }

        let pca_button = $('#run_pca');
        function runPCA() {
            // We only run PCA on unfiltered genes below the selected row
            var selected_genes = sort_order.filter( function(row,rank) {
                if (rank > selected_row) {
                    return false;
                }
                if (filtered[row]) {
                    return false;
                }
                return true;
            });

            var alert = $('#run_pca_alert');
            if (selected_genes.length <  3) {
                alert.text("Too few rows selected, need at least 3 for PCA.");
                alert.show();
                return;
            } else {
                alert.hide();
            }

            var pt_labels = spreadsheets.map( function(spreadsheet, idx) {
                var rep_counts = [];
                return spreadsheet.x_values.map( function(time) {
                    if (rep_counts[time] === undefined) {
                        rep_counts[time] = 0;
                    }
                    rep_counts[time] += 1;
                    var day = Math.floor(time / spreadsheet.timepoints_per_day) + 1;
                    var time_of_day = time % spreadsheet.timepoints_per_day + 1;
                    return "Day " + day + " Timepoint " + time_of_day + " Rep " + rep_counts[time];
                });
            });

            pca_button.prop('disabled', true);
            pca_button.html("<span class='spinner-border spinner-border-sm text-light mr-2' role='status' aria-hidden='true'>" +
                        "</span>Processing...");

            $.ajax({
                url: "{{url_for('spreadsheets.run_pca')}}",
                data: JSON.stringify({'spreadsheet_ids': spreadsheet_ids,
                                      'selected_genes': selected_genes,
                                      'take_logtransform': $('#pca_logtransform').is(':checked'),
                                      'take_zscore': $('#pca_zscore').is(':checked')}),
                dataType: 'json',
                contentType: 'application/json',
                type: 'POST',
                success: function (response) {
                    pca_coords = response['pca_coords'];
                    explained_variance = response['explained_variance'];

                    var traces = spreadsheets.map( function (spreadsheet, idx) {
                        return {
                            x: pca_coords[idx][0],
                            y: pca_coords[idx][1],
                            mode: 'markers',
                            name: spreadsheet.descriptive_name,
                            text: pt_labels[idx],
                            marker: {
                                size: 25,
                                opacity: 1 //x_values[idx].map( function (x) { return (x+1) / (1+Math.max.apply(null, x_values[idx])); })
                            }
                        };
                    });

                    var layout = {
                        height:PCA_HEIGHT,
                        width:PCA_WIDTH,
                        xaxis: {
                            title: "PC1 (" + toFixed(explained_variance[0]*100,1) + "%)"
                        },
                        yaxis: {
                            title: "PC2 (" + toFixed(explained_variance[1]*100,1) + "%)"
                        },
                        hovermode: 'closest',
                        legend: {
                            x:0,
                            y:1,
                            bgcolor: '#EEEEEE'
                        }
                    };

                    let pca_plot = document.getElementById('pca_plot');
                    Plotly.newPlot(pca_plot, traces, layout);

                    pca_plot.on('plotly_afterplot', setPCAPointStyles);

                    $('#pca_controls').show();
                },
                error: function (error) {
                    console.log("Error running PCA");
                    console.log(error);
                    alert.text(error.responseText);
                    alert.show();
                },
                complete: function() {
                    // Restore PCA button function
                    pca_button.prop('disabled', false);
                    pca_button.html('Run PCA');
                }
            });
        };

        pca_button.click(runPCA);
        $('#pca_zscore').change(function() {
            runPCA();
        });
        $('#pca_logtransform').change(function() {
            runPCA();
        });

        $('#download_pca').click(function() {
            // NOTE: we cannot use Plotly.downloadImage() since we have modified the plot
            // after its creation and the downloadImage() won't reflect those changes
            // So instead we just directly grab its SVG structure by toSVG() and then download that

            // Gather the plot as an SVG
            let pca_plot = document.getElementById('pca_plot');
            let svg_data = Plotly.Snapshot.toSVG(pca_plot, {format: 'svg'});

            // Create a URL for it
            let blob = new Blob([svg_data]);
            let url = URL.createObjectURL(blob);

            // Trigger downloading of the URL by making an <a href ...> to it and clicking it
            var anchor = document.createElement("a");
            anchor.href = url;
            anchor.download = "pca.svg";
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);

            // Cleanup after 60s, they've presumably successfully downloaded the small svg
            setTimeout(function () { URL.revokeObjectURL(url) }, 60000);
        });
    }

</script>

<div id="vue-app">


<div id="comparison-graph-page" class="page-header">
    <h1>Spreadsheet Comparison</h1>
</div>

<p id="spreadsheet-comparison-page">
    <div class="row">
        <p class="col-lg-12 h3">
            {{descriptive_names[0]}} vs. {{descriptive_names[1]}}

            <a href="{{ url_for('spreadsheets.download_comparison', id1=spreadsheet_ids[0], id2=spreadsheet_ids[1]) }}" class="mx-3" download="processed_file.txt">
                <i class="fas fa-download" data-toggle="tooltip" data-placement="top" title="Download"></i>
            </a>
        </p>
    </div>
    <div class="row">
        <span class="form-group col-lg-9">
            Number of selected rows:
            <input type="number" id="significant_items"></input>
        </span>
    </div>

    <div class="row">
        <div class="col">
            <div id="coarse_slider" class="coarse-slider"></div>
        </div>
    </div>

    <div class="row">
        <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
    </div>

    <div class='row'>
        <span class='col-auto'>
            <div class='row'>
                <div class="col">
                    <div class="input-group mb-2">
                        <input class="form-control form-control-sm" type="text" name="row_search"
                               placeholder="Search for row by label" id="row_search_box" />
                        <div class="input-group-append">
                            <button type="button" id="search_button" class="btn btn-secondary btn-sm">
                                Search
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class='row'>
                <div class='col-auto'>
                    <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
                    <div id="row_selector" class="list-group" tabindex="0" style="white-space:pre">
                     </div>
                    <div class="form-check">
                        <input class="form-check-input" id="hide_filtered" type="checkbox" value="">
                        <label class="form-check-label" for="hide_filtered">Hide filtered rows</label>
                    </div>
                </div>
            </div>
            <div class='p-3'>
                <button id="download_plot" class="btn btn-primary">Download Plot</button>
            </div>
        </span>
        <div class='col-auto'>
            <span id="scatter_plot" style="width:625px;height:525px;vertical-align: top"></span>
            <form class="form-group">
                <div class="form-inline">
                    <label for="plot_style_select">Plot style</label>
                    <select id="plot_style_select" value="basketweave" class="form-control form-control-sm">
                        <option value="basketweave">Basketweave</option>
                        <option value="points">Points</option>
                        <option value="mean">Mean only</option>
                        <option value="mean_points">Points and Mean</option>
                        <option value="std">Standard Deviations</option>
                        <option value="SEM">SEM</option>
                    </select>
                </div>
                <div class="form-inline">
                    <label for="plot_x_label_style">Plot x-axis labels</label>
                    <select id="plot_x_label_style" class="form-control form-control-sm">
                        <option value="daytime" selected>Day and time</option>
                        <option value="time">Time of day</option>
                        <option value="infer">Inferred labels</option>
                        <option value="infer_wrapped">Inferred labels wrapping</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="form-check" id="fold_days_box" style="display:none">
                    <input class="form-check-input" id="fold_days_checkbox" type="checkbox" value="">
                    <label class="form-check-label" for="fold_days_checkbox">Overlay cycles</label>
                </div>
            </form>
            <button id="toggle_primary" class="btn btn-primary mt-2">Toggle Primary Plot</button>
            <span>Currently: <span id="primary_plot_name">{{descriptive_names[0]}}</span></span>
        </div>

        <div class="col-auto">
            <div class="card">
                <div class="card-header">
                    Statistics
                    <a id="statsHelp" class="text-primary help-pointer"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Statistics Help"
                       data-content="Displays statistics about the selected row. JTK values are calculated on first page load and may a take a minute.">
                        <i class="fas fa-info-circle ml-3"></i>
                    </a>
                </div>
                <div class="card-body">
                    <label for="sort_select">Sort by:</label>
                    <select id="sort_select" class="form-control form-control-sm">
                         <option value="nitecap">Nitecap</option>
                         <option value="jtk" disabled>JTK</option>
                         <option value="anova">ANOVA</option>
                         <option value="amplitude">Amplitude</option>
                         <option value="upside" disabled>Damping</option>
                         <option value="two_way_anova" disabled>Two-way ANOVA</option>
                         <option value="phase_change" disabled>Phase Difference</option>
                         <option value="amplitude_change" disabled>Amplitude Difference</option>
                    </select>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th scope="col"></th>
                                <th scope="col">Primary</th>
                                <th scope="col">Secondary</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td rowspan="2">Nitecap
                                    <a class="text-primary help-pointer float-right"
                                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                       title="Nitecap"
                                       data-content="Nitecap significance of rhythmicity for primary dataset.">
                                        <i class="fas fa-info-circle ml-3"></i>
                                    </a>
                                </td>
                                <td>p: <span id="p_value0"></span></td>
                                <td>p: <span id="p_value1"></span></td>
                            </tr>
                            <tr> <td>q: <span id="q_value0"></span></td> <td>q: <span id="q_value1"></span></td></tr>

                            <tr> <td rowspan="2">JTK
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="JTK"
                                   data-content="JTK_cycle significance of rhythmicity for primary dataset.">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                </td>
                                <td>p: <span id="jtk_p0"></span></td>
                                <td>p: <span id="jtk_p1"></span></td>
                            </tr>
                            <tr> <td>q: <span id="jtk_q0"></span></td> <td>q: <span id="jtk_q1"></span></td> </tr>

                            <tr> <td rowspan="2"> ANOVA
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="ANOVA"
                                   data-content="1-Way ANOVA on primary dataset. If there are no replicates on timepoints, ANOVA cannot be run.">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                 </td>
                                 <td>p: <span id="anova_p0"></span></td>
                                 <td>p: <span id="anova_p1"></span></td>
                            </tr>
                            <tr> <td>q: <span id="anova_q0"></span></td> <td>q: <span id="anova_q1"></span></td> </tr>

                            <tr> <td rowspan="2">Damping
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="Damping"
                                   data-content="Damping analysis giving significance of a decrease in variation in the secondary dataset compared to the first.">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                </td>
                                <td>p: <span id="upside_p0"></span></td>
                                <td>p: <span id="upside_p1"></span></td>
                            </tr>
                            <tr> <td>q: <span id="upside_q0"></span></td> <td>q: <span id="upside_q1"></span></td> </tr>

                            <tr> <td rowspan="2">Two-way ANOVA
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="Damping"
                                   data-content="Two-way ANOVA test for difference in timepoint-effects across datasets">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                </td>
                                <td colspan="2">p: <span id="two_way_anova_p"></span></td>
                            </tr>
                            <tr> <td colspan="2">q: <span id="two_way_anova_q"></span></td> </tr>

                            <tr> <td rowspan="2">Phase Difference
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="Damping"
                                   data-content="Test for equality of phase between datasets through cosinor analysis (least squares fit)">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                </td>
                                <td colspan="2">p: <span id="phase_p"></span></td>
                            </tr>
                            <tr> <td colspan="2">q: <span id="phase_q"></span></td> </tr>

                            <tr> <td rowspan="2">Amplitude Difference
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="Damping"
                                   data-content="Test for equality of amplitudes between datasets through cosinor analysis (least squares fit)">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                </td>
                                <td colspan="2">p: <span id="amplitude_p"></span></td>
                            </tr>
                            <tr> <td colspan="2">q: <span id="amplitude_q"></span></td> </tr>

                            <tr> <td>Amplitude
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="Amplitude"
                                   data-content="Amplitude of the variation.">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                </td>
                                <td id="amplitude0"></td>
                                <td id="amplitude1"></td>
                            </tr>

                            <tr> <td>Peak-time
                                <a class="text-primary help-pointer float-right"
                                   data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                   title="Peak-time"
                                   data-content="Time the peak value occurs at. The units are the numbers of the timepoints, i.e. 3.5 means half-way between timepoint 3 and timepoint 4.">
                                    <i class="fas fa-info-circle ml-3"></i>
                                </a>
                                 </td>
                                <td id="peak_time0"></td>
                                <td id="peak_time1"> </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <div class="row">
        <div id="FiltersCard" class="col-auto">
            <div class="card">
                <div class="card-header">
                    Filters
                    <a id="filtersHelp" class="text-primary help-pointer"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Filter Help"
                       data-content="Keep only rows matching the criteria provided. Rerunning the q-values computes q-values using only the unfiltered genes. This is statistically invalid to do if filtering on most criteria (eg: if filtering p-values or q-values, one should not rerun the q-values). Instead, only rerun q-values when filtering exclusively on time-unaware criteria (such as max value).">
                        <i class="fas fa-info-circle ml-3"></i>
                    </a>
                </div>
                <div class="card-body">
                    <div id="filter_list">
                        <div v-for="(filter, index) in filters" class="row">
                            <div class='col form-inline filter_item'>
                                <input class="form-control form-control-sm m-1 filter-lower-bound" style="width: 85px"
                                     v-bind:aria-label="'Lower bound for filter ' + index"
                                     v-model="filter[1]">
                                </input>

                                &le;

                                <select class="form-control form-control-sm m-1 filter_value_selector"
                                        v-bind:aria-label="'Filter selector for filter ' + index"
                                        v-bind:value="filter[0]">
                                    <option v-for="filter in filter_data_list"
                                            v-bind:value="filter.key">
                                            {% raw %} {{filter.name}} {% endraw %}
                                    </option>
                                </select>

                                &le;

                                <input class="form-control form-control-sm m-1 filter-upper-bound" style="width: 85px"
                                     v-bind:aria-label="'Upper bound for filter ' + index"
                                     v-model="filter[2]">
                                </input>

                                <button class="btn btn-default" v-bind:aria-label="'Remove filter ' + index" title="Remove filter"
                                        v-on:click="filters = filters.filter(function(x,j) {return j !== index;})">
                                    <span class="far fa-minus-square"> </span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <button id="reset_filters_button" class="btn btn-default" aria-label="Reset filters"
                        v-on:click="resetFilters">
                        <span class="fas fa-undo" title="Reset filters" data-toggle="tooltip" data-placement="top"></span>
                    </button>
                    <button id="add_filter_button" class="btn btn-default" style="float: right" aria-label="Add filter"
                        v-on:click="addFilter">
                        <span class="far fa-plus-square" title="Add filter" data-toggle="tooltip" data-placement="top"></span>
                    </button>
                    <div>
                        <button id="applyFilters" type="button" class="btn btn-primary mb-4" v-on:click="applyFilters">Apply filters</button>
                        <button id="rerun_qvalues" type="button" class="btn btn-primary mb-4">Rerun q-values</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row" style="padding-top:2rem;padding-bottom:2rem">
        <span class="col-lg-5">
            <input type="hidden" id="row_index" name="row_index"/>
            <button id="set_breakpoint" class="btn btn-primary">Generate Heatmap</button>
        </span>
    </div>

    <div class="row">
        <div class="col card" id="heatmap_block" style="display:none">
            <div class="card-body">
                <span class="col-lg-12">Number of items in heatmap: <span id="cutoff"></span></span>
                <div id="heatmap"></div>
                <span id="heatmap_controls" class="col-lg-5" style="display:none">
                    <div class="form-check">
                        <input class="form-check-input" id="combine_replicates" type="checkbox" value="">
                        <label class="form-check-label" for="combine_replicates">Combine replicates</label>
                    </div>

                    <div class="form-check" id="heatmap_fold_days_box" style="display:none">
                        <input class="form-check-input" id="heatmap_fold_days" type="checkbox" value="">
                        <label class="form-check-label" for="heatmap_fold_days">Overlay cycles</label>
                    </div>

                    <div class="form-check">
                        <input class="form-check-input" id="heatmap_show_labels" type="checkbox" value="">
                        <label class="form-check-label" for="heatmap_show_labels">Show row lables</label>
                    </div>
                </span>
                <span>
                    <button id="download_heatmap" class="btn btn-primary" style="display:none">Download Heatmap</button>
                </span>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col card">
            <div class="card-body">
                <button id="run_pca" class="btn btn-primary">Run PCA</button>
                <span id="run_pca_alert" class="alert alert-error"></span>
                <div id="pca_plot"></div>

                <span id="pca_controls" class="col" style="display:none">
                    <span>log(x+1) Transform</span>
                    <label class="switch">
                        <input id="pca_logtransform" name="pca_logtransform" type="checkbox" />
                        <span class="slider"></span>
                    </label>

                    <span for="pca_zscore">Z-Score Normalization</span>
                    <label class="switch">
                        <input id="pca_zscore" name="pca_zscore" type="checkbox" >
                        <span class="slider"></span>
                    </label>

                    <button id="download_pca" class="btn btn-primary">Download PCA</button>
                </span>
            </div>
        </div>
    </div>


</div>


<!-- temporary inlining of Vue.JS dev version -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
    Vue.prototype.filter_data_list = [
        {values: function () {
                         // Grand maximum across both datasets within each row
                         let maxes = spreadsheets.map(function (spreadsheet) {
                                return maximums(spreadsheet.data);
                         });
                         return maxes[0].map( function(row, i) {
                            return Math.max(maxes[0][i], maxes[1][i]);
                        });
                    },
                name: "Maximum value",
                independent: true,
                key:"max_value"},
        {values: function () {
                    // Grand means across both datasets within each row
                    // TODO: better support for missing values (different numbers missing in each spreadsheet)
                    let means = spreadsheets.map(function (spreadsheet) {
                        return means(spreadsheet.data);
                    });
                    let a = spreadsheets[0].data[0].length;
                    let b = spreadsheets[1].data[0].length;
                    return means[0].map( function(row, i) {
                        return (means[0][i]*a + means[1][i]*b) / (a + b);
                    });
                },
                name: "Mean value",
                independent: true,
                key: "mean_value"},
        {values: function () { return spreadsheets[0].ps; },
                name: "Nitecap p Primary",
                independent: false,
                key: "nitecap_p0"},
        {values: function () { return spreadsheets[0].qs; },
                name: "Nitecap q Primary",
                independent: false,
                key: "nitecap_q0"},
        {values: function () { return spreadsheets[0].jtk_ps; },
                name: "JTK p Primary",
                independent: false,
                key: "jtk_p0"},
        {values: function () { return spreadsheets[0].jtk_qs; },
                name: "JTK q Primary",
                independent: false,
                key: "jtk_q0"},
        {values: function () { return spreadsheets[0].anova_ps; },
                name: "ANOVA p Primary",
                independent: false,
                key: "anova_p0"},
        {values: function () { return spreadsheets[0].anova_qs; },
                name: "ANOVA q Primary",
                independent: false,
                key: "anova_q0"},
        {values: function () { return spreadsheets[0].amplitudes; },
                name: "Amplitude Primary",
                independent: false,
                key: "amplitude0"},
        {values: function () { return spreadsheets[0].peak_times; },
                name: "Peak time Primary",
                independent: false,
                key: "peaktime0"},
        {values:function () { return two_way_anova_ps; },
                  name: "Two-way ANOVA p",
                  independent: false,
                  key: "two_way_anova_p"},
        {values:function () { return two_way_anova_qs; },
                  name: "Two-way ANOVA q",
                  independent: false,
                  key: "two_way_anova_q"},
        {values:function () { return phase_ps; },
                  name: "Phase difference p",
                  independent: false,
                  key: "phase_difference_q"},
        {values:function () { return phase_qs; },
                  name: "Phase difference q",
                  independent: false,
                  key: "phase_difference_p"},
        {values:function () { return amplitude_ps; },
                  name: "Amplitude difference p",
                  independent: false,
                  key: "amplitude_difference_p"},
        {values:function () { return amplitude_qs; },
                  name: "Amplitude difference q",
                  independent: false,
                key: "amplitude_difference_q"}
    ];

    let app = new Vue({
        el: "#vue-app",
        data: {
            filters: [],
            last_used_filters: []
        },
        methods: {
            resetFilters: function(){
                this.filters = this.last_used_filters.slice();
            },
            addFilter: function(){
                this.filters.push( ['max_value', '',''] );
            },
            applyFilters: function() {
                // Copy the filters that we last ran
                this.last_used_filters = this.filters.slice();

                let filtered_out = labels.map( function (x) {return false;} );

                // Apply all filters
                this.filters.forEach(function(filter) {
                    var filter_value = filter[0];

                    var lower_bound = parseInt(filter[1]);
                    var upper_bound = parseInt(filter[2]);

                    if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                    if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                    let values = filter_data.get(filter_value).values();
                    filtered_out = filtered_out.map( function (x,i) {
                        return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                    });
                });

                filtered = filtered_out;

                if (hide_filtered_checkbox.checked) {
                    // Move filtered items from the sort_order to the back of the list  to hide them
                    let head = sort_order.filter( function(x) {return !filtered[x];});
                    let tail = sort_order.filter( function(x) {return filtered[x];});
                    sort_order = head.concat(tail);
                }

                computeNumSignificantBelow();

                // Update row selector display to reflect the new filtering
                rowSelector.filterRows(filtered);
            },
        }
    });

</script>
{% endblock %}
