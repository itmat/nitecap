{% extends "base.html" %}

{% block content %}


<!-- temporary inlining of Vue.JS dev version -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>
    $(document).ready(function () {
        // Handles to the error-handling modal
        nitecap_error = $("#error-modal");
        nitecap_error_message = $("#error-modal-message")

        share_token = "{{ share_token }}";
        initial_config = {{ config | tojson }};

        initial_config.original_spreadsheet_ids = {{ spreadsheet_ids | safe }};

        // If not supplied in config (eg: no config at all), order by the given spreadsheet_ids
        if ((initial_config.spreadsheet_ids || []).length === 0) {
            initial_config.spreadsheet_ids = {{ spreadsheet_ids | safe }};
        }

        $.ajax({
            url: "/spreadsheets/get_mpv_spreadsheets",
            data: JSON.stringify({'spreadsheet_ids': initial_config.original_spreadsheet_ids, 'share_token': share_token}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                onSpreadsheetLoad(response);
            },
            error: function(error) {
                console.log("Error loading spreadsheets");
                console.log(error);

                nitecap_error_message.text("Error loading spreadsheets");
                nitecap_error.modal();
            }
        });

    });

    function onSpreadsheetLoad(spreadsheets) {
        let vm = app;

        // FOR VUE
        spreadsheets.forEach(function(spreadsheet) {
            // VUE PERF NOTE
            // Vue "observes" all attributes of observed objects
            // so it will try to observe everything in the large data arrays
            // however we do not need reactivity for those arrays since they don't change
            // Here we disable adding new elements to them which causes Vue to not observe every element in the array
            // Note that the arrays themselves are still observed in the sense that doing spreadsheet.tds = <new array>
            // will propagate changes that depend on spreadsheet.tds
            Object.keys(spreadsheet).forEach(function(key){
                if (Array.isArray(spreadsheet[key])) {
                    Object.preventExtensions(spreadsheet[key]);
                }
            });
        });

        // Gather spreadsheets by id
        vm.spreadsheets_by_id = {};
        spreadsheets.forEach(function(spreadsheet) {
            Vue.set(vm.spreadsheets_by_id, spreadsheet.spreadsheet_id, spreadsheet);
        });


        vm.labels = spreadsheets[0].labels;

        // Update stats_table with the Additional Stat Columns of the spreadsheets
        spreadsheets.forEach(function(spreadsheet) {
            Object.entries(spreadsheet.stat_values).forEach(function(entry) {
                let key = entry[0];
                let value = entry[1];
                vm.$set(vm.stats, key, value);
                vm.$set(vm.stats_table, key, {
                    name: key,
                    value: key,
                    description: "Additional stat column from spreadsheets with column name " + key +" (from spreadsheet " + spreadsheet.descriptive_name +").",
                    per_spreadsheet: false,
                });
            });
        });


        function makeCoarseSlider(element, start_value, maximum) {
            element.slider({
                orientation: "horizontal",
                min: 0,
                value: start_value,
                step: 1,
                max: maximum,
                range: "min",
                slide: function (event, ui) {
                    vm.config.selected_row = ui.value;
                }
            });
        }

        makeCoarseSlider($('#coarse_slider'), 0, vm.labels.length - 1);

        // Load config values
        mergeDeep(vm.config, initial_config);
        vm.config.filters.forEach(function(filter) {
            // editing_filters needs a copy of the actually-used filters
            vm.editing_filters.push(Object.assign({},filter));
        });

        $('[data-toggle="tooltip"]').tooltip();

        vm.share_token = share_token;
    }
</script>

{% raw %}

<div id="vue-app">
    <div class="page-header">
        <h1>Spreadsheet Viewer</h1>
    </div>

    <div v-show="spreadsheets.length > 0">
        <div class="row">
            <p class="col-lg-12 h3">
                <span v-if="spreadsheets.length === 1">
                    {{spreadsheets[0].descriptive_name}}
                </span>
                <span v-if="spreadsheets.length >= 2">
                    {{spreadsheets[0].descriptive_name}} vs. {{spreadsheets[1].descriptive_name}}
                </span>

                <button class="btn btn-secondary btn-sm" id='share_spreadsheet' v-on:click="triggerDownloadPopup">
                    Download
                </button>
                <a v-if="share_token.length > 0"
                    class="btn btn-secondary btn-sm"
                    v-bind:href="'/spreadsheets/copy_share/'+share_token">
                        Copy to Account
                </a>
                <a v-if="spreadsheets.length === 1"
                    v-bind:href="'/spreadsheets/collect_data/'+spreadsheets[0].spreadsheet_id">
                    <i class="fas fa-edit" data-toggle="tooltip" data-placement="top" title="Edit"></i>
                </a>

                <a id='share_spreadsheet' href="#" v-on:click="onShare">
                    <i class="fas fa-share-square" data-toggle="tooltip" data-placement="top" title="Share"></i>
                </a>
            </p>
        </div>

        <div class='row justify-content-center'>
            <span class='col-auto'>
                <div class='row'>
                    <div class="col">
                        <div class="input-group mb-2">
                            <input class="form-control form-control-sm" type="text" name="row_search"
                                   placeholder="Search for row by label" v-model="search_value"
                                   v-on:keyup.enter="searchRows"/>
                            <div class="input-group-append">
                                <button type="button" class="btn btn-secondary btn-sm"
                                        v-on:click="searchRows">
                                    Search
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class='row'>
                    <div class='col-auto'>
                        <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
                        <row-selector v-bind:sort-order="sort_order"
                                      v-bind:filtered="filtered"
                                      v-bind:num-rows="21"
                                      v-bind:q-values="label_q"
                                      v-bind:selected-row="config.selected_row"
                                      v-bind:labels="labels"
                                      v-bind:label-max-length="35"
                                      v-bind:select-row="selectRow"
                                      v-cloak>
                        </row-selector>
                        <div class="form-check">
                            <input class="form-check-input" id="hide_filtered" type="checkbox" v-model="config.hide_filtered_rows">
                            <label class="form-check-label" for="hide_filtered">Hide filtered rows</label>
                        </div>
                    </div>
                </div>
            </span>
            <div class='col-auto'>
                <span id="scatter_plot" style="width:625px;height:525px;vertical-align: top"></span>
                <div class='p-3 float-right'>
                    <button class="btn btn-primary" v-on:click="downloadPlot">Download Plot</button>
                </div>

                <div class='p-3 float-right'>
                    <button class="btn btn-primary btn-sm" v-on:click="shiftSpreadsheets" v-if="spreadsheets.length > 1">Reorder Spreadsheets</button>
                </div>
                <form class="form-group">
                    <div class="form-inline">
                        <label for="plot_style_select">Plot style</label>
                        <select id="plot_style_select" value="bars_points_std" class="form-control form-control-sm" v-model="config.plot.style">
                            <option value="points">Points</option>
                            <option value="mean">Mean only</option>
                            <option value="mean_points">Points and Mean</option>
                            <option value="bars_std">Bars and Standard Deviations</option>
                            <option value="bars_points_std">Bars, Points, and Standard Deviations</option>
                            <option value="std">Standard Deviations</option>
                            <option value="std_points">Standard Deviations and Points</option>
                            <option value="SEM">SEM</option>
                            <option value="SEM_points">SEM and Points</option>
                        </select>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" id="include_zero_checkbox" type="checkbox" v-model="config.plot.include_zero">
                        <label class="form-check-label" for="include_zero_checkbox">Include zero</label>
                    </div>
                </form>
            </div>

            <div class="col-auto">
                <div class="card">
                    <div class="card-header">
                        Statistics
                        <a id="statsHelp" class="text-primary help-pointer ml-3"
                           data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                           title="Statistics Help"
                           data-content="Displays statistics about the selected row. JTK values are calculated on first page load and may a take a minute.">
                            <i class="fas fa-info-circle"></i>
                        </a>
                    </div>
                    <div class="card-body" id="statistics-list">
                        <table class="table table-sm">
                            <thead>
                                <tr v-if="spreadsheets.length > 1">
                                    <th scope="col"></th>
                                    <th scope="col" v-for="name in descriptive_names">{{name}}</th>
                                </tr>
                            </thead>
                            <tbody v-if="spreadsheets !== null" class="stats-box">
                                <template v-for="(stat, stat_id) in useable_stats">
                                    <tr>
                                        <td v-bind:rowspan="typeof stat.value === 'string' ? 1 : 2">
                                            {{stat.name}}
                                            <a class="text-primary help-pointer float-right ml-1"
                                                data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                                v-bind:title="stat.name"
                                                v-bind:data-content="stat.description">
                                                <i class="fas fa-info-circle"></i>
                                            </a>
                                        </td>

                                        <template v-if="typeof stat.value === 'string'">
                                            <template v-if="stat.per_spreadsheet">
                                                <template v-for="(spreadsheet, i) in spreadsheets">
                                                    <td v-if="spreadsheet[stat.value] != null"
                                                        v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                        v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                        v-bind:title="String(spreadsheet[stat.value][row_index])">
                                                        {{util.formatStatsEntry(spreadsheet[stat.value][row_index])}}
                                                    </td>
                                                    <td v-else>
                                                        loading
                                                    </td>
                                                </template>
                                            </template>
                                            <template v-else>
                                                <td v-if="stats[stat.value] != null"
                                                    v-bind:title="String(stats[stat.value][row_index])"
                                                    v-on:click="config.sort_by = {stat_id:stat_id}"
                                                    v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:colspan="spreadsheets.length">
                                                    {{util.formatStatsEntry(stats[stat.value][row_index])}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>

                                        <template v-else>
                                            <template v-if="stat.per_spreadsheet">
                                                <template v-for="(spreadsheet, i) in spreadsheets">
                                                    <td v-if="spreadsheet[stat.value.p] != null"
                                                        v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                        v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                        v-bind:title="String(spreadsheet[stat.value.p][row_index])">
                                                        p: {{util.formatStatsEntry(spreadsheet[stat.value.p][row_index])}}
                                                    </td>
                                                    <td v-else>
                                                        loading
                                                    </td>
                                                </template>
                                            </template>
                                            <template v-else>
                                                <td v-if="stats[stat.value.p] != null"
                                                    v-bind:title="String(stats[stat.value.p][row_index])"
                                                    v-on:click="config.sort_by = {stat_id:stat_id}"
                                                    v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:colspan="spreadsheets.length">
                                                    p: {{util.formatStatsEntry(stats[stat.value.p][row_index])}}
                                                </td>
                                                <td v-else v-bind:colspan="spreadsheets.length">
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                    </tr>

                                    <tr v-if="typeof stat.value !== 'string'">
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="(spreadsheet, i) in spreadsheets">
                                                <td v-if="spreadsheet[stat.value.q] != null"
                                                    v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                    v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:title="String(spreadsheet[stat.value.q][row_index])">
                                                    q: {{util.formatStatsEntry(spreadsheet[stat.value.q][row_index])}}
                                                </td>
                                                <td v-else>
                                                    loading
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value.q] != null"
                                                v-bind:title="String(stats[stat.value.q][row_index])"
                                                v-on:click="config.sort_by = {stat_id:stat_id}"
                                                v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                v-bind:colspan="spreadsheets.length">
                                                q: {{util.formatStatsEntry(stats[stat.value.q][row_index])}}
                                            </td>
                                            <td v-else v-bind:colspan="spreadsheets.length">
                                                loading
                                            </td>
                                        </template>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

        </div>

        <div class="row">
            <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
        </div>

        <div class="row">
            <div class="col">
                <div id="coarse_slider" class="coarse-slider"></div>
            </div>
        </div>

        <div class="row">
            <span class="form-group col-lg-5">
                Number of selected rows:
                <input type="number" v-model.number="num_below"></input>
            </span>
            <span class="form-group col-lg-5">
                Cutoff:
                <input v-model.lazy.number="cutoff"></input>
            </span>
        </div>




        <div class="card">

            <div class="card-header">
                <ul class="nav nav-tabs" id="toolTabs" role="tablist">
                    <li class="nav-item">
                        <a class="nav-link activate" id="filters-tab" data-toggle="tab" href="#filters" aria-controls="home" aria-selected="True">Filters</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="pathways-tab" data-toggle="tab" href="#pathways" aria-controls="pathways" aria-selected="false">Pathways</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="comparisons-tab" data-toggle="tab" href="#comparisons" aria-controls="comparisons" aria-selected="false">Comparisons</a>
                    </li>
                </ul>
            </div>

            <div class="tab-content card-body" id="toolTabContent">
                <div class="tab-pane fade show active" id="filters" role="tabpanel" aria-labelledby="filters-tab" v-on:keyup.enter="applyFilters">
                    <div class="col-auto">
                        <div id="filter_list">
                            <div v-for="(filter, index) in editing_filters" class="row"
                                :key="filter.id">
                                <div class='col form-inline filter_item'>
                                    <input class="form-control form-control-sm m-1 filter-lower-bound" style="width: 85px"
                                         v-bind:aria-label="'Lower bound for filter ' + index"
                                         v-model="filter.lower_bound"
                                         type="number" step="any">
                                    </input>

                                    &le;

                                    <select class="form-control form-control-sm m-1 filter_value_selector"
                                            v-bind:aria-label="'Filter selector for filter ' + index"
                                            v-model="filter.variable">
                                        <option v-for="filter_data in filter_data_list"
                                                v-bind:value="filter_data.key">
                                                {{filter_data.name}}
                                        </option>
                                    </select>

                                    &le;

                                    <input class="form-control form-control-sm m-1 filter-upper-bound" style="width: 85px"
                                         v-bind:aria-label="'Upper bound for filter ' + index"
                                         v-model="filter.upper_bound"
                                         type="number" step="any">
                                    </input>

                                    <button class="btn btn-default" v-bind:aria-label="'Remove filter ' + index" title="Remove filter"
                                            v-on:click="editing_filters = editing_filters.filter(function(x,j) {return j !== index;})">
                                        <span class="far fa-minus-square"> </span>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <button id="applyFilters" type="button" class="btn btn-primary" v-on:click="applyFilters">Apply filters</button>
                        <button id="add_filter_button" class="btn btn-default" aria-label="Add filter"
                            v-on:click="addFilter">
                            <span class="far fa-plus-square" title="Add filter" data-toggle="tooltip" data-placement="top"></span>
                        </button>
                        <button id="reset_filters_button" class="btn btn-default" aria-label="Reset filters"
                            v-on:click="resetFilters">
                            <span class="fas fa-undo" title="Reset filters" data-toggle="tooltip" data-placement="top"></span>
                        </button>
                        <a id="filtersHelp" class="text-primary help-pointer ml-3"
                           data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                           title="Filter Help"
                           data-content="Keep only rows matching the criteria provided. Rerunning the q-values computes q-values using only the unfiltered genes. This is statistically invalid to do if filtering on most criteria (eg: if filtering p-values or q-values, one should not rerun the q-values). Instead, only rerun q-values when filtering exclusively on time-unaware criteria (such as max value).">
                            <i class="fas fa-info-circle"></i>
                        </a>
                        <!--<button id="rerun_qvalues" type="button" class="btn btn-primary mb-4">Rerun q-values</button>-->
                    </div>
                </div>

                <div class="tab-pane fade" id="pathways" role="tabpanel" aria-labelledby="pathways-tab">
                    <pathway-analysis
                        v-bind:selected_rows="selected_rows"
                        v-bind:ids="spreadsheets[0] ? spreadsheets[0].ids : []"
                        v-bind:id_labels="spreadsheets[0] ? spreadsheets[0].id_col_labels : []"
                        v-bind:background_rows="background_rows"
                        >
                    </pathway-analysis>
                </div>
                <div class="tab-pane fade" id="comparisons" role="tabpanel" aria-labelledby="comparison-tab">
                    <div class="form-group">
                        <label for="first_compare_selector">
                        First group for comparison:
                        </label>
                        <select id="first_compare_selector" v-model="comparison_box.first_group">
                            <option v-for="(group, i) in groups" v-bind:value="i" v-bind:key="group.name">
                                {{ group.name }}
                            </option>
                        </select>

                        <div>
                            <label for="second_compare_selector">
                            Second group for comparison:
                            </label>
                            <select id="second_compare_selector" v-model="comparison_box.second_group">
                                <option v-for="(group, i) in groups" v-bind:value="i" v-bind:key="group.name">
                                    {{ group.name }}
                                </option>
                            </select>
                        </div>

                        <button type="button" class="btn btn-primary" v-on:click="createComparison">
                            Create Comparison
                        </button>
                        <a id="comapreHelp" class="text-primary help-pointer ml-3"
                           data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                           title="Compare Help"
                           data-content="Create comparisons of specific conditions. Adds a log Fold Change statistic to statistic panel sorting by fold change between the two selected conditions. A psuedo-count is added to both values to prevent division by zero and to give more accurate estimates of effect sizes.">
                            <i class="fas fa-info-circle"></i>
                        </a>

                        <template v-for="(comparison, i) in comparisons">
                            <h6>{{comparison.name}}</h6>
                                <label v-bind:for="'comparison_pseudo_count_input'+i">Pseudo Count:</label>
                                <input v-bind:id="'comparison_pseudo_count_input'+i"
                                       type="number"
                                        v-model.lazy.number="comparison.pseudo_count">
                                </input>
                        </template>
                    </div>
                </div>

            </div>
        </div>
    </div>
    <div v-show="spreadsheets.length == 0">
        <p> Loading... </p>
    </div>

        <!--
        <div class='col-auto'>
            <div class="card">
                <div class="card-header">
                    Adjusted Fold Change
                    <a id="FCHelp" class="text-primary help-pointer ml-3"
                       data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                       title="Adjusted Fold Change Help"
                       data-content="Display plots related to analyzing the behavior of various possible pseudo-counts and their effect upon the adjusted fold change. Adjusted fold change is defined as (mean1 + C) / (mean2 + C) where C is the pseudo-count, and mean1 and mean2 are the means of the two conditions being compared.">
                        <i class="fas fa-info-circle"></i>
                    </a>
                </div>
                <div class="card-body">
                    <span id="fc_plot" style="width:625px;height:525px;vertical-align: top"></span>
                    <div class='p-3 float-right'>
                        <button class="btn btn-primary" v-on:click="redrawFCPlot">Run FC Plot</button>
                    </div>
                    <div class="form-inline">
                        <label for="plot_style_select">Plot style</label>
                        <select id="plot_style_select" class="form-control form-control-sm w-auto" v-model="fc_plot.config.style">
                            <option value="mva">MvA</option>
                            <option value="rank">Rank-Rank</option>
                        </select>

                    </div>
                    <div class="form-inline">
                        <label for="select-afc-comparison">Comparison</label>
                        <select id="select-afc-comparison" class="form-control form-control-sm w-auto" v-model="fc_plot.config.comparison">
                            <option value="null">None</option>
                            <option v-for="comparison in comparisons" v-bind:value="comparison.name" v-bind:key="comparison.name">{{comparison.name}}</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        -->



    <!-- MODALS -->
    <div id="share_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">SHARE this spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="share_url">Copy this URL and offer it to anyone with whom you'd like to share your
                        spreadsheet data:</label>
                    <textarea id="share_url" class="form-control" rows="6"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
      </div>
    </div>

    <div id="download_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">Download spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-include-data" v-model:value="download.include_data"></input>
                        <label class="form-check-label" for="download-include-data">
                            Include data
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-just-selected-rows" v-model:value="download.just_selected_rows"></input>
                        <label class="form-check-label" for="download-just-selected-rows">
                            Inlucde only top {{config.selected_row+1}} rows
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-drop-filtered" v-model:value="download.drop_filtered_rows"></input>
                        <label class="form-check-label" for="download-drop-filtered">
                            Drop filtered-out rows
                        </label>
                    </div>
                    <div v-if="spreadsheets.length > 1">
                        <div v-for="(spreadsheet, i) in spreadsheets" class="form-group">
                            <label v-bind:for="'suffix'+i">Suffix {{i+1}}</label>
                            <input type="text" class="form-control" v-bind:id="'suffix'+i" v-model="download.suffixes[i]"> </input>
                        </div>
                    </div>
                    Statistics
                    <div class="form-check" v-for="(stat, stat_name) in useable_stats">
                        <input class="form-check-input" type="checkbox" v-bind:id="'download-'+stat_name" v-model:value="download.stats[stat_name]"></input>
                        <label class="form-check-label" v-bind:for="'download-'+stat_name">
                            {{stat.name}} statistics
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal" v-on:click="downloadSpreadsheet">Download</button>
            </div>
        </div>
      </div>
    </div>

</div>

{% endraw %} <!-- TODO remove these raw tags when we are no longer using templating at all -->

<script src="{{url_for('static', filename='js/row_selector.js')}}"></script>
<script src="{{url_for('static', filename='js/pathway.js')}}"></script>
<script src="{{url_for('static', filename='js/pathway_component.js')}}"></script>

<script>
    Vue.prototype.util = {
        formatNum: formatNum,
        formatStatsEntry: function(entry){
            if(typeof entry === 'string') {
                return entry;
            } else {
                return  formatNum(entry, 4);
            }
        },
    };

    let stats_table = {
        ANOVA: {name: "ANOVA",
         value: {p: "anova_p",
                 q: "anova_q"},
         description: "1-Way ANOVA on primary dataset. If there are no replicates on timepoints, ANOVA cannot be run.",
         per_spreadsheet: true,
         num_spreadsheets: 'any'},
    };

    let filter_data_list_base = [
        {values: function () {
                         // Grand maximum across both datasets within each row
                         if (app.spreadsheets.length === 0) { return []; }
                         let maxes = app.spreadsheets.map(function (spreadsheet) {
                                return maximums(spreadsheet.data);
                         });
                         return maxes[0].map( function(row, i) {
                            return Math.max.apply(null, maxes.map(function(max){return max[i];}));
                        });
                    },
                name: "Maximum value",
                independent: true,
                key:"max_value"},
        {values: function () {
                    // Grand means across both datasets within each row
                    // skipping over NaN/null values
                     if (app.spreadsheets.length === 0) { return []; }
                    let sums_ = app.spreadsheets.map(function(spreadsheet) {
                        let summed_rows = sums(spreadsheet.data);
                        return summed_rows;
                    });
                    let total_sums = sums(sums_, 0);

                    let nonnans = app.spreadsheets.map(function(spreadsheet) {
                        return numValids(spreadsheet.data);
                    });
                    let total_nonnans = sums(nonnans, 0);

                    let divide = function(a,b) { return a/b; };

                    let means = total_sums.map(function(sum, i) {
                        return sum / total_nonnans[i];
                    });
                    return means;
                },
                name: "Mean value",
                independent: true,
                key: "mean_value"},
        {values: function () {
                 if (app.spreadsheets.length === 0) { return []; }
                let missing = app.spreadsheets.map( function(spreadsheet) {
                     return numNaNTimepoints(spreadsheet.data, spreadsheet.x_values);
                });
                return maximums(missing, axis=0);
            },
            name: "Missing Timepoints",
            independent: true, // TODO: is this actually right?
            key: "missing_timepoints"},
    ];

    let app = new Vue({
        el: "#vue-app",
        data: {
            editing_filters: [],
            spreadsheets_by_id: {}, // spreadsheets by ID
            config: {
                spreadsheet_ids: [],
                original_spreadsheet_ids: [],
                selected_row: 0,
                sort_by: {stat_id: 'ANOVA', spreadsheet_num: 0},
                filters: [],
                hide_filtered_rows: false,
                plot: {
                    style: "bars_points_std",
                    include_zero: false,
                },
            },


            search_value: '',

            stats_table: stats_table,

            stats_vars_order: ['p', 'q', 'AFC'], // Order in which to display stats sub-variables

            stats: {
            },

            download: {
                include_data: true,
                just_selected_rows: false,
                drop_filtered_rows: false,
                suffixes: [],
                stats: {},
            },

            labels: [],

            comparisons: [],

            plot: {
                first_render: true,
            },

            share_token: '', // If from a share, the token used

            fc_plot: {
                config: {
                    pseudo_count: 1,
                    comparison: null,
                    style: "mva",
                },
                first_render: true,
            },

            comparison_box: {
                first_group: '',
                second_group: '',
            },
        },

        methods: {
            resetFilters: function(){
                this.editing_filters = [];
                this.config.filters.forEach(function(filter){
                    // make editing_filters a copy of the last-used filters
                    app.editing_filters.push(Object.assign({},filter));
                });
            },

            addFilter: function(){
                let new_id = 0; // Make filter keys
                if (this.editing_filters.length > 0){
                    new_id  = Math.max.apply(null, this.editing_filters.map( function(filter) {
                        return filter.id;
                    }))  + 1;
                }
                this.editing_filters.push( {variable: 'max_value', lower_bound:'', upper_bound:'', id: new_id} );
            },

            applyFilters: function() {
                // Copy the filters that we last ran
                // config.filters are the ones we actually filter on
                // needs to be deep copy so we json-ify it and back
                this.config.filters = JSON.parse(JSON.stringify(this.editing_filters));
            },

            redrawPlot: function() {
                let vm = this;
                // Update the Plotly plots of the feature profiles
                let traces = [];
                let colors = Plotly.d3.scale.category10();
                vm.spreadsheets.forEach(function (spreadsheet, idx) {
                    let row_index = vm.sort_order[vm.config.selected_row];
                    raw_y_values = spreadsheet.data[row_index];
                    if (raw_y_values === undefined) {
                        console.log("Could not find the y-values for row " + row_index);
                        return;
                    }

                    plot_x_values = spreadsheet.group_assignments;
                    plot_x_labels = vm.possible_assignments;
                    plot_x_label_values = plot_x_labels.map(function(x,i) {return i;});

                    let stats = rowStatsByTimepoint(raw_y_values, plot_x_values);

                    // Pick a color for this spreadsheet using Plotly's defaults from d3
                    let spreadsheet_color = colors(idx);
                    let marker_settings = {size: 12, symbol: 'circle-open'};

                    // Default values for the different plot styles to override
                    let trace = {
                        x: plot_x_values, y: raw_y_values,
                        mode: 'markers',
                        marker: marker_settings,
                        name: vm.descriptive_names[idx],
                        type: 'scatter',
                        'marker': {color: spreadsheet_color},
                        'line': {color: spreadsheet_color},
                        showlegend: false,
                        name: ' ',
                    };

                    // Pick data and styling based off the plot_style_select value
                    let plot_style = vm.config.plot.style;
                    if (plot_style === "basketweave") {
                        // Make pairs of points that are adjacent in time to each other, for each dataset
                        column_pairs = [];
                        plot_x_values.forEach( function(x,i) {
                            for(let j = i+1; j < plot_x_values.length; j++) {
                                if (Math.abs(plot_x_values[j] - x) === 1) {
                                    column_pairs.push([i,j]);
                                }
                            }
                        });

                        paired_y_values = [];
                        for (let i in column_pairs) {
                            paired_y_values.push(raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null);
                        }

                        paired_x_values = [];
                        for (let i in column_pairs) {
                            paired_x_values.push(plot_x_values[column_pairs[i][0]], plot_x_values[column_pairs[i][1]], null);
                        }

                        trace.mode = 'lines+markers';
                        trace.x = paired_x_values;
                        trace.y = paired_y_values;
                    } else if (plot_style === "points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                    } else if (plot_style === "mean") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                    } else if (plot_style === "mean_points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                        traces.push({ // The mean value trace
                            x: stats.means.map( function (x,i) {return i;} ), // Just 0,1,2,3...
                            y: stats.means,
                            type: "scatter",
                            mode: "lines",
                            showlegend: false,
                            'line': {color: spreadsheet_color}
                        });
                    } else if (plot_style === "std") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                    } else if (plot_style === "std_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            showlegend: false,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style === "SEM") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                    } else if (plot_style === "SEM_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            showlegend: false,
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style === "bars_points_std") {
                        trace.text = spreadsheet.column_headers;
                        let bar_trace = {
                            type: 'bar',
                            x: stats.means.map(function(x,i) { return i;} ),
                            y: stats.means,
                            error_y: {type: 'data', array:stats.stds, visible:true},
                            showlegend: false,
                            name: 'mean',
                        };
                        traces.push(bar_trace);
                        trace.marker.color = 'black';
                    } else if (plot_style === "bars_std") {
                        let bar_trace = {
                            type: 'bar',
                            x: stats.means.map(function(x,i) { return i;} ),
                            y: stats.means,
                            error_y: {type: 'data', array:stats.stds, visible:true},
                            name: 'mean',
                        };
                        trace = bar_trace;
                    }
                    traces.push(trace);

                });

                let layout = {
                    hovermode: 'closest',
                    title: app.labels[app.sort_order[app.config.selected_row]],
                    legend: { orientation: 'h', y: -0.2 },
                    xaxis: {
                        ticktext: plot_x_labels,
                        tickvals: plot_x_label_values,
                        automargin: true,
                    },
                    yaxis: {
                        rangemode: vm.config.plot.include_zero ? 'tozero' : '',
                    }
                };

                if (vm.plot.first_render) {
                    Plotly.newPlot('scatter_plot', traces, layout);
                    vm.plot.first_render = false;
                } else {
                    Plotly.react('scatter_plot', traces, layout);
                }
            },

            downloadPlot: function() {
                let gd = document.getElementById('scatter_plot');
                Plotly.downloadImage(gd, {format: 'svg', filename: 'plot_' + (app.config.selected_row+1)});
            },


            selectRow: function(row) {
                this.config.selected_row = row;
            },

            onRowChange: function () {
                this.redrawPlot();

                $('#coarse_slider').slider('value', this.config.selected_row);
            },

            searchRows: function() {
                let search_value = this.search_value.toLowerCase().trim();

                // Pull out row indexes matching our search_value
                let matching_rows = app.labels.map( function(unused, index) {
                    let label = app.labels[app.sort_order[index]];
                    if (label.toLowerCase().indexOf(search_value) !== -1) {
                        return index;
                    }
                }).filter(isFinite);


                if (matching_rows.length === 0) {
                    console.log("Unfortunately no matching row found.");
                    // TODO: display something to the user
                    return;
                }

                // Find matches in rows past the current selection
                let matches_after = matching_rows.filter( function (i) {
                    return i > app.config.selected_row;
                } );

                let row = null;
                if (matches_after.length > 0) {
                    // First look for matches that are *after* our config.selected_row
                    // so that multiple button presses will cycle the selection through all matches
                    row = matches_after[0];
                } else {
                    // If that fails, grab the first matching row
                    row = matching_rows[0];
                }

                app.config.selected_row = row;
            },

            onShare: function() {
                // Open Modal to share the spreadsheet
                let vm = this;
                $.ajax({
                    url: "{{url_for('spreadsheets.share')}}",
                    data: JSON.stringify({'spreadsheet_ids': vm.config.original_spreadsheet_ids, 'config': vm.config}),
                    dataType: "json",
                    contentType: "application/json",
                    type: 'POST',
                    success: function (response) {
                        let url = "{{url_for('spreadsheets.share', _external=True)}}/" + response['share'];
                        $("#share_url").val(url);
                        $('#share_popup').modal()
                    },
                    error: function (request) {
                        error_message = $.parseJSON(request.responseText).error;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    }
                });
            },

            triggerDownloadPopup: function() {
                // Fill in default suffix values if they don't yet have any
                if (this.download.suffixes.length === 0) {
                    this.download.suffixes = this.descriptive_names;
                }
                $("#download_popup").modal();
            },

            downloadSpreadsheet: function() {
                let vm = this;

                let download_rows = null;
                if (vm.download.just_selected_rows) {
                    download_rows = vm.sort_order.slice(0,vm.config.selected_row+1);
                } else {
                    // All rows 0,1,2,...
                    download_rows = app.labels.map(function(x,i) { return i;} );
                }

                if (vm.download.drop_filtered_rows) {
                    download_rows = download_rows.filter(function(x) {
                        return !vm.filtered[x];
                    });
                }

                let download_columns = [];
                let download_compare_columns = [];
                // Gather which statistic columns have been selected
                for (let stat_name in vm.stats_table) {
                    if (vm.download.stats[stat_name] === true) {
                        let stat = vm.stats_table[stat_name];
                        let column_list = download_columns;
                        if ((stat.num_spreadsheets === "multi") &&
                            (vm.spreadsheets.length > 1)) {
                            column_list = download_compare_columns;
                        }

                        if (typeof stat.value === 'string') {
                            // Name of stat
                            column_list.push(stat.value)
                        } else {
                            // Object containing p,q
                            column_list.push(stat.value.p, stat.value.q);
                        }

                        if (stat.sort_value !== undefined) {
                            column_list.push(stat.sort_value)
                        }
                        if (stat.secondary_sort_value !== undefined) {
                            column_list.push(stat.secondary_sort_value)
                        }
                    }
                }
                // Remove any duplicates (like sort_value == value)
                download_columns = Array.from(new Set(download_columns));
                download_compare_columns = Array.from(new Set(download_compare_columns));

                // Order the suffixes correctly (in case spreadsheets have been rearranged)
                let suffixes = vm.config.original_spreadsheet_ids.map(function(id) {
                    let new_index = vm.config.spreadsheet_ids.indexOf(id);
                    return vm.download.suffixes[new_index];
                });

                $.ajax({
                    url: "/spreadsheets/download",
                    data: JSON.stringify({
                        'spreadsheet_ids': vm.config.original_spreadsheet_ids,
                        'share_token': share_token,
                        'config': {
                            rows: download_rows,
                            columns: download_columns,
                            compare_columns: download_compare_columns,
                            suffixes: suffixes,
                            include_data: vm.download.include_data,
                        },
                    }),
                    dataType:"text",
                    contentType: "application/json",
                    type: "POST",
                    success: function (response) {
                        // Create a URL for it
                        let blob = new Blob([response]);
                        let url = URL.createObjectURL(blob);

                        // Trigger downloading of the URL by making an <a href ...> to it and clicking it
                        let anchor = document.createElement("a");
                        anchor.href = url;
                        anchor.download = "spreadsheet.txt";
                        document.body.appendChild(anchor);
                        anchor.click();
                        document.body.removeChild(anchor);

                        // Cleanup after 5mins
                        setTimeout(function () { URL.revokeObjectURL(url) }, 5*60*1000);
                    },
                    error: function(request) {
                        error_message = $.parseJSON(request.responseText).err;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    },
                });
            },

            shiftSpreadsheets: function () {
                // Shifts through the spreadsheets in order
                let spreadsheets = this.config.spreadsheet_ids;
                let first = spreadsheets[0];
                let tail = spreadsheets.slice(1);
                spreadsheets = tail.concat(first);
                this.config.spreadsheet_ids = spreadsheets;
            },

            redrawFCPlot: function() {
                let vm = this;
                let spreadsheet = vm.spreadsheets[0];
                let pseudo_count = vm.fc_config.plot.pseudo_count;
                let plot_style = vm.fc_config.plot.style;

                // For now, we just compare the groups 0 and 1 whatever they are
                let compute_mean = function(group) {
                    return spreadsheet.data.map( function(row) {
                        let sum = 0;
                        let count = 0
                        row.forEach(function(x,i) {
                            if (spreadsheet.group_assignments[i] === group) {
                                sum += x;
                                count += 1;
                            }
                        });
                        return sum / count;
                    });
                };
                let means1 = compute_mean(0);
                let means2 = compute_mean(1);

                let log_means  = means1.map(function(x,i) {
                    return Math.log2((means1[i] + means2[i])/2);
                });
                let log_afc = means1.map(function(x,i) { // Log2 adjusted fold change using given pseudo_count
                    return Math.log2((means1[i] + pseudo_count) / (means2[i] + pseudo_count));
                });

                let traces;
                let layout;
                if (plot_style === "mva") {
                     traces = [{
                        x: log_means,
                        y: log_afc,
                        type: 'scattergl',
                        mode: 'markers',
                        name: "MvA",
                        marker: {color: 'black', size:3},
                        text: spreadsheet.labels,
                    }];

                    layout = {
                        hovermode: 'closest',
                        title: "MvA",
                        xaxis: {
                            title: "log2((mean1 + mean2)/2)",
                        },
                        yaxis: {
                            title: "log2((mean1+C)/(mean2+C))",
                        }
                    };
                } else if (plot_style === "rank") {
                    let C = 1;
                    let log_ratios = means1.map(function(x,i) {
                        return Math.log2((means1[i]+C) / (means2[i]+C));
                    });

                    let ranks = rankArray(log_ratios.map(Math.abs), -1);
                    let ranks_AFC = rankArray(log_afc.map(Math.abs), -1);
                    traces = [{
                        x: ranks.map(Math.log10),
                        y: ranks_AFC.map(Math.log10),
                        name: "Rank-Rank",
                        type: 'scattergl',
                        mode: 'markers',
                        marker: {color: 'black', size:3},
                        text: spreadsheet.labels,
                    }];

                    layout = {
                        hovermode: 'closest',
                        title: "Rank-Rank",
                        xaxis: {
                            title: "log10 Ranks (C="+C+")",
                        },
                        yaxis: {
                            title: "log10 Ranks (C=" + pseudo_count + ")",
                        }
                    };
                }


                if (vm.fc_plot.first_render) {
                    Plotly.newPlot('fc_plot', traces, layout);
                    vm.fc_plot.first_render = false;
                } else {
                    Plotly.react('fc_plot', traces, layout);
                }
            },

            createComparison: function() {
                let vm = this;
                let spreadsheet = vm.spreadsheets[0];
                let first_group = vm.groups[vm.comparison_box.first_group];
                let second_group = vm.groups[vm.comparison_box.second_group];
                let comparison_name = first_group.name + ' v ' + second_group.name;

                // TODO: should we use THIS pseudo-count or another one?
                let pseudo_count = 1;

                function column_in_group(col_index, group) {
                    let in_group = true;
                    group.variables.forEach(function(variable) {
                        if (spreadsheet.group_membership[variable.variable][col_index] != variable.number) {
                            in_group = false;
                        }
                    });
                    return in_group;
                }

                let compute_mean = function(group) {
                    return spreadsheet.data.map( function(row) {
                        let sum = 0;
                        let count = 0
                        row.forEach(function(x,i) {
                            if (column_in_group(i, group)) {
                                sum += x;
                                count += 1;
                            }
                        });
                        return sum / count;
                    });
                };
                let means1 = compute_mean(first_group);
                let means2 = compute_mean(second_group);

                function compute_log_afc(pseudo_count) {
                    let log_afc = means1.map(function(x,i) { // Log2 adjusted fold change using given pseudo_count
                        return Math.log2((means1[i] + pseudo_count) / (means2[i] + pseudo_count));
                    });
                    return log_afc;
                };
                let log_afc = compute_log_afc(pseudo_count);

                // TODO: this needs to create a NEW fold-change for each comparison run
                vm.$set(vm.stats, comparison_name + " AFC", log_afc);

                vm.$set(vm.stats_table, comparison_name + " AFC", {
                     name: comparison_name,
                     value: comparison_name + " AFC",
                     description: "Comparison of group '" + first_group.name + "' and '" + second_group.name + "'",
                     per_spreadsheet: false,
                     num_spreadsheets: 'any',
                });

                let comparison = {
                    name: comparison_name,
                    log_AFC: log_afc,
                    pseudo_count: 1,
                    means1: means1,
                    means2: means2,
                };
                vm.comparisons.push(comparison);

                // Must recalculate the statistic if we update psuedo_count
                // I don't see any way to make log_AFC a computed property since it is created dynamically, so we watch instead
                vm.$watch(function(){return comparison.pseudo_count},
                          function(pseudo_count, old) {
                            comparison.log_AFC = compute_log_afc(pseudo_count);
                            // TODO: this is a kinda hacky approach, since we're doubling up the fold-change information
                            vm.stats[comparison_name + " AFC"] = comparison.log_AFC;
                          });
            },
        },

        computed: {
            spreadsheets: function() {
                // Spreadsheets in the order they are displayed
                let vm = this;
                return vm.config.spreadsheet_ids.map(function(id) { return vm.spreadsheets_by_id[id]; } )
            },

            row_index: function() {
                if (this.sort_order !== null) {
                    return this.sort_order[this.config.selected_row];
                } else {
                    return this.config.selected_row;
                }

            },

            num_below: {
                get: function () {
                    return this.num_significant_below[this.config.selected_row];
                },
                set: function (val) {
                    val = parseInt(val);
                    if (val === null || this.num_significant_below === null) {
                        this.config.selected_row = 0;
                    }

                    let idx = this.num_significant_below.indexOf(val);
                    if (idx !== -1) {
                        this.config.selected_row = idx;
                    } else {
                        if (idx > Math.max(null, this.num_significant_below)) {
                            this.config.selected_row = this.num_siginificant_below.length;
                        } else {
                            this.config.selected_row = 0;
                        }
                    }
                }
            },

            sort_by: function() {
                return {
                    stat: this.stats_table[this.config.sort_by.stat_id],
                    stat_id: this.config.sort_by.stat_id,
                    spreadsheet_num: this.config.sort_by.spreadsheet_num,
                };
            },


            sort_function: function () {
                // We sort by the value specified in config.sort_by
                // We also have a 'secondary sort value' which is used purely as a null/not-null check
                // So if secondary sort value is null then we will sort the value to the end as if the main value were null
                // This solves the problem where q-values are null and being sorted to the front of the list particulary
                // from filters re-running q-values (which nulls them if filtered) and then being viewed without that filter

                // display_value is the value array that should be monotonic in the sort order
                // which are convenient for the user to look at.
                // In particular, Nitecap sorts by the nitecap statistic but users want to see the q-value
                // and other methods sort by p-value but users want q-value
                let vm = this;
                let variable = null;
                let secondary_variable = null;
                let display_variable = null;

                if (this.sort_by.stat.sort_value !== undefined) {
                    variable = this.sort_by.stat.sort_value;
                    if (this.sort_by.stat.secondary_sort_value !== undefined) {
                        secondary_variable = this.sort_by.stat.secondary_sort_value;
                    } else {
                        secondary_variable = variable;
                    }
                    display_variable = secondary_variable;
                } else if (typeof this.sort_by.stat.value === 'string') {
                    variable = this.sort_by.stat.value;
                    secondary_variable = variable;
                    display_variable = variable;
                } else {
                    variable = this.sort_by.stat.value.p;
                    secondary_variable = this.sort_by.stat.value.q;
                    display_variable = secondary_variable;
                }

                let sort_direction = 1;
                if (this.sort_by.stat.sort_direction !== undefined) {
                    sort_direction = this.sort_by.stat.sort_direction;
                }

                let value = null;
                let secondary_value = null;
                let display_value = null;
                if (vm.sort_by.spreadsheet_num !== undefined) {
                    if (vm.spreadsheets.length > 0) {
                        value = vm.spreadsheets[vm.sort_by.spreadsheet_num][variable];
                        secondary_value = vm.spreadsheets[vm.sort_by.spreadsheet_num][secondary_variable];
                        display_value = vm.spreadsheets[vm.sort_by.spreadsheet_num][display_variable];
                    }
                } else {
                    value = vm.stats[variable];
                    secondary_value = vm.stats[secondary_variable];
                    display_value = vm.stats[display_variable];
                }

                if (display_value !== null && vm.spreadsheets.length > 0) {
                    display_value = display_value.map( function(x,i) {
                        return secondary_value[i] && display_value[i];
                    });
                }


                let sorter = function (i,j) {
                    let a = secondary_value[i] && value[i];
                    let b = secondary_value[j] && value[j];
                    return compare(a ? a * sort_direction : a, // multiply by +/- 1 but not if null
                                   b ? b * sort_direction : b,
                                   i, j);
                };

                if ((value === null) || (secondary_value === null)) {
                    // Don't sort, the values we are sorting by haven't loaded yet
                    // display_value will just be the index
                    sorter = function(i,j) { return i - j; };
                    display_value = app.labels.map(function(x,i) {return i+1;});
                }

                return {"func": sorter, "value": value, "display_value":display_value, "sort_direction": sort_direction};
            },

            sort_order: function () {
                let vm = this;
                if (this.labels.length == 0) { return []; } // No spreadsheets yet

                let sort_order =  this.labels.map( function(x,i) {return i;} );
                sort_order = sort_order.sort(this.sort_function.func);

                if (this.config.hide_filtered_rows) {
                    // Move filtered items from the sort_order to the back of the list  to hide them
                    let head = sort_order.filter( function(x) {return !vm.filtered[x];});
                    let tail = sort_order.filter( function(x) {return vm.filtered[x];});
                    sort_order = head.concat(tail);
                }

                return sort_order;
            },

            label_q: function () {
                let value = this.sort_by.stat.value;

                if (typeof value === 'string') {
                    // No inherent q-value for this sort value
                    // drop the "Q:" label
                    return null;
                }

                if (this.sort_by.spreadsheet_num !== undefined) {
                    let sp = this.spreadsheets[this.sort_by.spreadsheet_num];
                    let vq = value.q;
                    let vals = sp ? sp[vq]: [];
                    return vals;
                } else {
                    return this.stats[value.q];
                }
            },

            filtered: function () {
                let vm = this;
                let filtered_out = this.labels.map( function (x) {return false;} );
                if (filtered_out.length == 0){  return filtered_out; }

                // Apply all filters
                this.config.filters.forEach(function(filter) {
                    let filter_value = filter.variable;

                    let lower_bound = parseFloat(filter.lower_bound);
                    let upper_bound = parseFloat(filter.upper_bound);

                    if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                    if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                    let idx = vm.filter_data_list.map(function(filter) {return filter.key;} ).indexOf(filter_value);
                    let values = vm.filter_data_list[idx].values();
                    if (values === null || values === undefined) { return; } // Haven't loaded values yet, can't filter by them

                    filtered_out = filtered_out.map( function (x,i) {
                        return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                    });
                });

                return filtered_out;
            },

            num_significant_below: function() {
                // Recompute the number of signifcant items below a cutoff
                // discards filtered out rows
                let num_significant_below = new Array(this.labels.length);
                let ctr = 0;
                this.labels.forEach(function(label, index) {
                    if (!app.filtered[app.sort_order[index]]) {
                        ctr++;
                    }

                    num_significant_below[index] = ctr;
                });
                return num_significant_below;
            },

            selected_rows: function() {
                // List of indices of the rows that are selected
                // I.e. unfiltered, and below the significance cutoff
                let vm = this;

                return vm.sort_order.filter( function(row_num,rank) {
                    return (rank <= vm.config.selected_row) & (!vm.filtered[row_num]);
                } );
            },

            background_rows: function() {
                let vm = this;
                if (vm.spreadsheets.length == 0) { return []; }
                return vm.spreadsheets[0].labels.map(function(x,i) { return i; }).filter( function(i) {return !vm.filtered[i];});
            },

            background_ids: function() {
                let vm = this;
                if (vm.spreadsheets.length == 0) { return []; }
                return vm.spreadsheets[0].labels.filter( function(label, i) {return !vm.spreadsheets[0].filtered[i];});
            },

            useable_stats: function () {
                // Only the stats from stats_table that apply to this context
                // i.e. the ones we have enough spreadsheets for
                let vm = this;
                let stats = {};
                for (key in this.stats_table) {
                    let stat = this.stats_table[key]
                    if ((stat.num_spreadsheets == 'multi')
                            && (vm.spreadsheets.length < 2)) {
                        continue; // Need 2 or more spreadsheets
                    }
                    stats[key] = stat;
                }
                return stats;
            },

            filter_data_list: function () {
                // List of filters including the 'special' ones declared in filters_data_list_base
                // and also those derived from the statistics in stats_table
                let vm = this;

                // Make a filter for each stat
                let stat_filters = [];
                for (key in vm.useable_stats) {
                    let stat = vm.useable_stats[key];
                    if (stat.per_spreadsheet) {
                        let just_one = vm.spreadsheets.length === 1;
                        vm.spreadsheets.forEach( function(spreadsheet, idx) {
                            if (typeof stat.value === 'string') {
                                let name = stat.name + ' ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value];},
                                     independent: false,
                                     key: name
                                });
                            } else {
                                let name = stat.name + ' p ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.p];},
                                     independent: false,
                                     key: name
                                });

                                name = stat.name + ' q ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.q];},
                                     independent: false,
                                     key: name
                                });
                            }
                        });
                    } else {
                        if (typeof stat.value === 'string') {
                            stat_filters.push({
                                 name: stat.name,
                                 values: function () {return vm.stats[stat.value];},
                                 independent: false,
                                 key: stat.name
                            });
                        } else {
                            stat_filters.push({
                                 name: stat.name + ' p',
                                 values: function () {return vm.stats[stat.value.p];},
                                 independent: false,
                                 key: stat.name + ' p',
                            });

                            stat_filters.push({
                                 name: stat.name + ' q',
                                 values: function () {return vm.stats[stat.value.q];},
                                 independent: false,
                                 key: stat.name + ' q',
                            });
                        }
                    }

                }

                // Return all filters, including the 'base' ones and the ones derived from our statistics
                return filter_data_list_base.concat(stat_filters);
            },


            descriptive_names: function() {
                // Descriptive names for spreadsheets
                // They are given descriptive names already but we want to isolate the part that is 'variable' between them
                // for easier display
                let names = this.spreadsheets.map( function(x) {return x.descriptive_name;});

                if (names.length < 2) {
                    // Can't simplify anything if there is only one!
                    return names;
                }

                let split_names = names.map( function(x) { return x.split(" ");});

                // Find the common prefix for all the names
                // eg names "Tom Dataset WT" and "Tom Dataset KO"
                // have prefix ["Tom", "Dataset"]
                let prefix = split_names[0];
                split_names.forEach(function(split_name) {
                    let no_mismatch_yet = true;
                    prefix = prefix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                });

                // Same as above, but find the common suffix for all the names
                let suffix = split_names[0].slice(0).reverse();
                split_names.forEach(function(split_name) {
                    split_name.reverse();
                    let no_mismatch_yet = true;
                    suffix = suffix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                    split_name.reverse(); // put it back
                });
                suffix = suffix.reverse();

                // Re-build the names with the prefix and suffix removed
                names = split_names.map( function(split_name) {
                    return split_name.slice(prefix.length, split_name.length - suffix.length).join(" ");
                });
                return names;
            },

            cutoff: {
                get: function() {
                    if (this.spreadsheets.length == 0) { return 0; }
                    return this.sort_function.display_value[this.sort_order[this.config.selected_row]];
                },
                set: function(value) {
                    let app = this;
                    let sort_values = app.sort_function.display_value;
                    let i = 0;
                    for(; i < sort_values.length; i++) {
                        let v = sort_values[app.sort_order[i]];
                        if ((app.sort_function.sort_direction * v) > (app.sort_function.sort_direction * value)) {
                            break;
                        }
                    }
                    app.config.selected_row = Math.max(i-1, 0);
                },
            },

            possible_assignments: function() {
                // All possible group combinations from the categories
                return this.spreadsheets[0].possible_assignments;
            },

            groups: function () {
                // List of possible groups to consider
                // Eg: "WT Female" or just "WT" including both male and female
                // And stores their "variables" i.e. what values they require for each variable
                // So eg: for "WT Female" want [{variable: "Genotype", value: "WT", number: 0}, {variable: "Gender", value: "Female", number: 0}]
                // where number is the index of the value inside that variable (eg: "Genotype" is ["WT", "KO"] then WT has number 0, KO number)
                let vm = this;
                if (vm.spreadsheets.length == 0) {  return []; }

                let categories = vm.spreadsheets[0].categories;
                let groups = [];
                categories.forEach(function(category) {
                    // Create the 'top-level' groups for this category
                    // I.e. Genotype = "WT" (gender unspecified)
                    let values = category.values.map(function(value, idx) {
                        return {
                            name: value.name,
                            variables: [{variable: category.variable, value: value, number: idx}],
                        };
                    });
                    let new_groups = values; // The groups we are adding from this iteration

                    values.forEach(function(value, idx) {
                        // Now add lower-level groups for this category
                        // Eg: if we already have the top-level group Gender=Female, then we add
                        //  a group that is Gender=Female, Genotype=WT
                        // We generate these based off all the groups already added
                        let with_new_value = groups.map( function(group) {
                            return {
                                name: group.name + " " + value.name,
                                variables: group.variables.concat([{variable: category.variable, value: value, number: idx}]),
                            };
                        } );
                        new_groups = new_groups.concat(with_new_value);
                    });
                    groups = groups.concat(new_groups);
                });
                return groups;
            },
        },

        watch: {
            row_index: "onRowChange",

            "config.plot": {
                handler: "redrawPlot",
                deep: true
            },

            "fc_plot.config": {
                handler: "redrawFCPlot",
                deep: true
            },
        },
    });
</script>
{% endblock %}
