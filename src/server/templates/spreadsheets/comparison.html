{% extends "base.html" %}

{% block head %}
    <meta name="description" content="{{' '.join(descriptive_names)}} - Nitecap spreadsheet of circadian data">
    <title>{{' '.join(descriptive_names)}} - Nitecap</title>
{% endblock %}

{% block content %}

{% if ENV == 'development' %}
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
{% else %}
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
{% endif %}

<script>

    VERSION = 35;
    FONT_SIZE = 16;
    $(document).ready(function () {
        // Handles to the error-handling modal
        nitecap_error = $("#error-modal");
        nitecap_error_message = $("#error-modal-message")

        share_token = "{{ share_token }}";
        initial_config = {{ config | tojson }};

        user_id = {{user_id| safe}};
        logged_in = !{{user_is_visitor| tojson}};

        initial_config.original_spreadsheet_ids = {{ spreadsheet_ids | safe }};

        // If not supplied in config (eg: no config at all), order by the given spreadsheet_ids
        if ((initial_config.spreadsheet_ids || []).length === 0) {
            initial_config.spreadsheet_ids = {{ spreadsheet_ids | safe }};
        }

        NOTIFICATION_API_ENDPOINT = "{{NOTIFICATION_API_ENDPOINT}}";

        $.ajax({
            url: "/spreadsheets/get_spreadsheets",
            data: JSON.stringify({'spreadsheet_ids': initial_config.original_spreadsheet_ids, 'share_token': share_token}),
            dataType: "json",
            contentType: "application/json",
            type: 'POST',
            success: function(response) {
                onSpreadsheetLoad(response);
            },
            error: function(error) {
                console.log("Error loading spreadsheets");
                console.log(error);

                nitecap_error_message.text("Error loading spreadsheets");
                nitecap_error.modal();
            }
        });

    });

    function onSpreadsheetLoad(spreadsheets) {
        let vm = app;

        // FOR VUE
        spreadsheets.forEach(function(spreadsheet) {
            spreadsheet.upside_p = null;
            spreadsheet.upside_q = null;

            // VUE PERF NOTE
            // Vue "observes" all attributes of observed objects
            // so it will try to observe everything in the large data arrays
            // however we do not need reactivity for those arrays since they don't change
            // Here we disable adding new elements to them which causes Vue to not observe every element in the array
            // Note that the arrays themselves are still observed in the sense that doing spreadsheet.tds = <new array>
            // will propagate changes that depend on spreadsheet.tds
            Object.keys(spreadsheet).forEach(function(key){
                if (Array.isArray(spreadsheet[key])) {
                    Object.preventExtensions(spreadsheet[key]);
                }
            });
        });

        // Gather spreadsheets by id
        vm.spreadsheets_by_id = {};
        spreadsheets.forEach(function(spreadsheet) {
            Vue.set(vm.spreadsheets_by_id, spreadsheet.spreadsheet_id, spreadsheet);
        });

        vm.labels = spreadsheets[0].labels;
        vm.timepoints_per_cycle = spreadsheets[0].timepoints_per_cycle;
        vm.num_days = (Math.max.apply(null, spreadsheets[0].x_values) + 1) / spreadsheets[0].timepoints_per_cycle;

        // Update stats_table with the Additional Stat Columns of the spreadsheets
        spreadsheets.forEach(function(spreadsheet) {
            Object.entries(spreadsheet.stat_values).forEach(function(entry) {
                let key = entry[0];
                let value = entry[1];
                // set the stat to the spreadsheet so it is accessible as a normal stat
                // note this will not be reactive, but it should also be static so no problem
                let mangled_stat_name = '__stat__' + key
                spreadsheet[mangled_stat_name] = spreadsheet.stat_values[key];
                if (vm.stats[key] === undefined) {
                    // Add stat just for this spreadsheet
                    vm.$set(vm.stats, key, value);
                    vm.$set(vm.stats_table, key, {
                        name: key,
                        value: key,
                        description: "Additional stat column from spreadsheets with column name " + key +" (from spreadsheet " + spreadsheet.descriptive_name +").",
                        per_spreadsheet: false,
                    });
                } else {
                    // Expand existing stat to be multi-spreadsheet
                    vm.$set(vm.stats, key, value);
                    vm.$set(vm.stats_table, key, {
                        name: key,
                        value: mangled_stat_name,
                        description: "Additional stat column from spreadsheets with column name " + key,
                        per_spreadsheet: true,
                        num_spreadsheets: 'any',
                    });
                }
            });
        });


        function makeCoarseSlider(element, start_value, maximum) {
            element.slider({
                orientation: "horizontal",
                min: 0,
                value: start_value,
                step: 1,
                max: maximum,
                range: "min",
                slide: function (event, ui) {
                    vm.config.selected_row = ui.value;
                }
            });
        }

        makeCoarseSlider($('#coarse_slider'), 0, vm.labels.length - 1);

        // Load config values
        mergeDeep(vm.config, initial_config);
        vm.config.filters.forEach(function(filter) {
            // editing_filters needs a copy of the actually-used filters
            vm.editing_filters.push(Object.assign({},filter));
        });

        spreadsheets.forEach(function(spreadsheet) {
            Vue.set(spreadsheet, "analyses", {});
            vm.runAnalysis("LS", spreadsheet, "ls");
            vm.runAnalysis("ARS", spreadsheet, "arser");
            vm.runAnalysis("JTK", spreadsheet, "jtk");
            vm.runAnalysis("Cosinor", spreadsheet, "cosinor");
            vm.runAnalysis("ANOVA", spreadsheet, "one_way_anova");
            vm.runAnalysis("RAIN", spreadsheet, "rain");
            vm.runAnalysis("Wave properties", spreadsheet, "jtk", {"computeWaveProperties": true});
        });


        // Load the Upside values
        if (spreadsheets.length > 1) {
            function upside() {
                $.ajax({
                    url: "/spreadsheets/get_upside",
                    data: JSON.stringify({'spreadsheet_ids': initial_config.original_spreadsheet_ids, 'share_token':share_token}),
                    dataType: 'text json',
                    contentType: 'application/json',
                    type: 'POST',
                    success: function(response) {
                        if ((response.status == 'waiting') || (response.status == 'running')) {
                            // Must requery the status after a bit
                            setTimeout(upside, 5*1000);
                            return;
                        }

                        // See VUE PERF NOTE
                        // Make all arrays non-traversed by Vue for performance
                        Object.keys(response).forEach(function(key) {
                            Object.preventExtensions(response[key]);
                        });

                        upside_p = response['upside_p'];
                        upside_q = response['upside_q'];

                        initial_config.original_spreadsheet_ids.forEach(function(spreadsheet_id, idx) {
                            let spreadsheet = vm.spreadsheets_by_id[spreadsheet_id];
                            Object.preventExtensions(upside_p[idx]); // See VUE PERF NOTE
                            Object.preventExtensions(upside_q[idx]); // these aren't covered by above since are one level deeper
                            spreadsheet.upside_p = upside_p[idx];
                            spreadsheet.upside_q = upside_q[idx];
                        });

                        // Load stats that are per-comparison not per-spreadsheet
                        app.stats.two_way_anova_p = response['two_way_anova_p'];
                        app.stats.two_way_anova_q = response['two_way_anova_q'];
                        app.stats.main_effect_p = response['main_effect_p'];
                        app.stats.main_effect_q = response['main_effect_q'];
                        app.stats.phase_p = response['phase_p'];
                        app.stats.phase_q = response['phase_q'];
                        app.stats.amplitude_p = response['amplitude_p'];
                        app.stats.amplitude_q = response['amplitude_q'];
                    },

                    error: function(error) {
                        console.log("Error loading upside values");
                        console.log(error);

                        nitecap_error_message.text("Error loading comparison statistics");
                        nitecap_error.modal();
                    }
                });
            }
            upside();
        }

        $('[data-toggle="tooltip"]').tooltip();

        vm.share_token = share_token;
        vm.logged_in = logged_in;

        vm.stats.index = Object.freeze(spreadsheets[0].ids.map( (x,i) => i));

        vm.connectToNotificationApi();
    }
</script>

{% raw %}

<div id="vue-app">

    <div v-show="(spreadsheets.length > 0) && (labels.length > 0)">
        <div class="row">
            <p class="col-lg-12 h3">
                <span v-if="spreadsheets.length === 1">
                    {{spreadsheets[0].descriptive_name}}
                </span>
                <span v-if="spreadsheets.length >= 2">
                    {{spreadsheets[0].descriptive_name}} vs. {{spreadsheets[1].descriptive_name}}
                </span>

                <button class="btn btn-secondary btn-sm" id='download_spreadsheet' v-on:click="triggerDownloadPopup">
                    Download
                </button>

                <button v-if="spreadsheets.length === 1 && share_token === ''" class="btn btn-secondary btn-sm" id='comparison_button' v-on:click="triggerComparisonPopup">
                   Compare
                </button>

                <a v-if="share_token !== '' && logged_in"
                    class="btn btn-secondary btn-sm"
                    v-bind:href="'/spreadsheets/copy_share/'+share_token">
                        Copy to Account
                </a>
                <a v-if="spreadsheets.length === 1 && share_token === ''"
                    v-bind:href="'/spreadsheets/collect_data/'+spreadsheets[0].spreadsheet_id">
                    <i class="fas fa-edit" data-toggle="tooltip" data-placement="top" title="Edit"></i>
                </a>

                <a v-if="share_token === ''" id='share_spreadsheet' href="#" v-on:click="onShare">
                    <i class="fas fa-share-square" data-toggle="tooltip" data-placement="top" title="Share"></i>
                </a>
            </p>
        </div>

        <div class='row justify-content-center'>
            <span class='col-auto'>
                <div class='row'>
                    <div class='col'>
                        <span class="selector-info align-middle"><i class="fas fa-arrow-left"></i> Less Significant</span>
                        <row-selector v-bind:sort-order="sort_order"
                                      v-bind:filtered="filtered"
                                      v-bind:num-rows="21"
                                      v-bind:q-values="label_q"
                                      v-bind:selected-row="config.selected_row"
                                      v-bind:labels="labels"
                                      v-bind:label-max-length="35"
                                      v-bind:select-row="selectRow"
                                      v-cloak>
                        </row-selector>
                    </div>
                </div>
                <div class='row'>
                    <div class="col">
                        <div class="input-group mb-2">
                            <input class="form-control form-control-sm" type="text" name="row_search"
                                   placeholder="Search for row by label" v-model="search_value"
                                   v-on:keyup.enter="searchRows"/>
                            <div class="input-group-append">
                                <button type="button" class="btn btn-secondary btn-sm"
                                        v-on:click="searchRows">
                                    Search
                                </button>
                            </div>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" id="hide_filtered" type="checkbox" v-model="config.hide_filtered_rows">
                            <label class="form-check-label" for="hide_filtered">Hide filtered rows</label>
                        </div>
                    </div>
                </div>
            </span>
            <div class='col-auto'>
                <span id="scatter_plot" style="width:625px;height:525px;vertical-align: top"></span>
                <div class='p-1 float-right'>
                    <div class="dropdown">
                        <button class="btn btn-primary btn-sm dropdown-toggle" id="downloadPlotbutton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                            Download Plot
                        </button>
                        <div class="dropdown-menu" aria-labelledby="downloadPlotButton">
                            <button class="dropdown-item" v-on:click="downloadPlot('png')">PNG</button>
                            <button class="dropdown-item" v-on:click="downloadPlot('svg')">SVG</button>
                        </div>
                    </div>
                </div>

                <div class='p-1 float-right'>
                    <button class="btn btn-primary btn-sm" v-on:click="shiftSpreadsheets" v-if="spreadsheets.length > 1">Reorder Spreadsheets</button>
                </div>
                <form class="form-group">
                    <div class="form-inline">
                        <label for="plot_style_select">Plot style</label>
                        <select id="plot_style_select" value="basketweave" class="form-control form-control-sm" v-model="config.plot.style">
                            <option value="basketweave">Basketweave</option>
                            <option value="points">Points</option>
                            <option value="mean">Mean only</option>
                            <option value="mean_points">Points and Mean</option>
                            <option value="std">Standard Deviations</option>
                            <option value="std_points">Standard Deviations and Points</option>
                            <option value="SEM">SEM</option>
                            <option value="SEM_points">SEM and Points</option>
                            <option value="repeated_measures">Repated Measures</option>
                            <option value="cosinor">Cosinor</option>
                        </select>
                    </div>
                    <div class="form-inline">
                        <label for="plot_x_label_style">Plot x-axis labels</label>
                        <select id="plot_x_label_style" class="form-control form-control-sm" v-model="config.plot.x_label_style">
                            <option value="daytime" selected>Day and time</option>
                            <option value="time">Time of day</option>
                            <option value="infer">Inferred labels</option>
                            <option value="infer_wrapped">Inferred labels wrapping</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="form-check" id="fold_days_box" v-if="num_days > 1">
                        <input class="form-check-input" id="fold_days_checkbox" type="checkbox" v-model="config.plot.fold_days">
                        <label class="form-check-label" for="fold_days_checkbox">Overlay cycles</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" id="include_zero_checkbox" type="checkbox" v-model="config.plot.include_zero">
                        <label class="form-check-label" for="include_zero_checkbox">Include zero</label>
                    </div>
                </form>
            </div>

            <div class="col-auto">
                <div class="card">
                    <div class="card-header">
                        Stats: sort by
                        <select class="form-select form-select-sm" aria-label="Sorting method"
                            v-model="config.sort_by.stat_id">
                            <option value="none" key="none"> None </option>
                            <option v-for="(stat, stat_id) in useable_stats"
                                v-bind:value="stat_id"
                                v-bind:key="stat_id">
                                {{stat.name }} {{stat.stat_id}}
                            </option>
                        </select>
                        <select class="form-select form-select-sm" aria-label="Sorting spreadsheet"
                            v-model="config.sort_by.spreadsheet_num"
                            v-bind:disabled="!sort_by.stat.per_spreadsheet"
                            v-show="spreadsheets.length > 1"
                            >
                            <option v-for="number in [0,1]"
                                v-bind:value="number">
                                {{descriptive_names[number]}}
                            </option>
                        </select>
                        <a id="statsHelp" class="text-primary help-pointer ml-3"
                           data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                           title="Statistics Help"
                           data-content="Displays statistics about the selected row. Some values (like JTK/ARS/LS) are take time to be computed and may require a few minutes. Choose what statistics to sort by from the drop downs here or by clicking on a statistic below.">
                            <i class="fas fa-info-circle"></i>
                        </a>
                    </div>
                    <div class="card-body pt-0 pb-0" id="statistics-list">
                        <table class="table table-sm">
                            <thead>
                                <tr v-if="spreadsheets.length > 1">
                                    <th scope="col"></th>
                                    <th scope="col" v-for="name in descriptive_names">{{name}}</th>
                                </tr>
                            </thead>
                            <tbody v-if="spreadsheets !== null" class="stats-box">
                                <template v-for="(stat, stat_id) in useable_stats">
                                    <tr>
                                        <td v-bind:rowspan="typeof stat.value === 'string' ? 1 : 2">
                                            {{stat.name}}
                                            <a class="text-primary help-pointer float-right ml-1"
                                                data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                                v-bind:title="stat.name"
                                                v-bind:data-content="stat.description">
                                                <i class="fas fa-info-circle"></i>
                                            </a>
                                        </td>

                                        <template v-if="typeof stat.value === 'string'">
                                            <template v-if="stat.per_spreadsheet">
                                                <template v-for="(spreadsheet, i) in spreadsheets">
                                                    <td v-if="spreadsheet[stat.value] != null"
                                                        v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                        v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                        v-bind:title="String(spreadsheet[stat.value][row_index])">
                                                        {{util.formatStatsEntry(spreadsheet[stat.value][row_index])}}
                                                    </td>
                                                    <td v-else>
                                                        {{getStatStatusDisplay(stat_id, i)}}
                                                    </td>
                                                </template>
                                            </template>
                                            <template v-else>
                                                <td v-if="stats[stat.value] != null"
                                                    v-bind:title="String(stats[stat.value][row_index])"
                                                    v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num:0}"
                                                    v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:colspan="spreadsheets.length">
                                                    {{util.formatStatsEntry(stats[stat.value][row_index])}}
                                                </td>
                                                <td v-else>
                                                    {{getStatStatusDisplay(stat_id)}}
                                                </td>
                                            </template>
                                        </template>

                                        <template v-else>
                                            <template v-if="stat.per_spreadsheet">
                                                <template v-for="(spreadsheet, i) in spreadsheets">
                                                    <td v-if="spreadsheet[stat.value.p] != null"
                                                        v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                        v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                        v-bind:title="String(spreadsheet[stat.value.p][row_index])">
                                                        p: {{util.formatStatsEntry(spreadsheet[stat.value.p][row_index])}}
                                                    </td>
                                                    <td v-else>
                                                        {{getStatStatusDisplay(stat_id, i)}}
                                                    </td>
                                                </template>
                                            </template>
                                            <template v-else>
                                                <td v-if="stats[stat.value.p] != null"
                                                    v-bind:title="String(stats[stat.value.p][row_index])"
                                                    v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num:0}"
                                                    v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:colspan="spreadsheets.length">
                                                    p: {{util.formatStatsEntry(stats[stat.value.p][row_index])}}
                                                </td>
                                                <td v-else v-bind:colspan="spreadsheets.length">
                                                    {{getStatStatusDisplay(stat_id)}}
                                                </td>
                                            </template>
                                        </template>
                                    </tr>

                                    <tr v-if="typeof stat.value !== 'string'">
                                        <template v-if="stat.per_spreadsheet">
                                            <template v-for="(spreadsheet, i) in spreadsheets">
                                                <td v-if="spreadsheet[stat.value.q] != null"
                                                    v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num: i}"
                                                    v-bind:class="stat === sort_by.stat && i == sort_by.spreadsheet_num ? 'selected-stat-cell' : 'stat-cell'"
                                                    v-bind:title="String(spreadsheet[stat.value.q][row_index])">
                                                    q: {{util.formatStatsEntry(spreadsheet[stat.value.q][row_index])}}
                                                </td>
                                                <td v-else>
                                                    {{getStatStatusDisplay(stat_id, i)}}
                                                </td>
                                            </template>
                                        </template>
                                        <template v-else>
                                            <td v-if="stats[stat.value.q] != null"
                                                v-bind:title="String(stats[stat.value.q][row_index])"
                                                v-on:click="config.sort_by = {stat_id:stat_id, spreadsheet_num:0}"
                                                v-bind:class="stat === sort_by.stat ? 'selected-stat-cell' : 'stat-cell'"
                                                v-bind:colspan="spreadsheets.length">
                                                q: {{util.formatStatsEntry(stats[stat.value.q][row_index])}}
                                            </td>
                                            <td v-else v-bind:colspan="spreadsheets.length">
                                                {{getStatStatusDisplay(stat_id)}}
                                            </td>
                                        </template>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

        </div>

        <div class="row">
            <p style="margin:auto">Less Significant <i class="fas fa-arrow-right"></i></p>
        </div>

        <div class="row">
            <div class="col">
                <div id="coarse_slider" class="coarse-slider"></div>
            </div>
        </div>

        <div class="row">
            <span class="form-group col-lg-5">
                Number of selected rows:
                <input type="number" v-model.number="num_below"></input>
            </span>
            <span class="form-group col-lg-5">
                Cutoff:
                <input v-model.lazy.number="cutoff"></input>
            </span>
        </div>




        <div class="card">

            <div class="card-header">
                <ul class="nav nav-tabs" id="toolTabs" role="tablist">
                    <li class="nav-item">
                        <a class="nav-link activate" id="filters-tab" data-toggle="tab" href="#filters" aria-controls="home" aria-selected="True">Filters</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="pathways-tab" data-toggle="tab" href="#pathways" aria-controls="pathways" aria-selected="false">Pathways</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="heatmap-tab" data-toggle="tab" href="#heatmap" aria-controls="heatmap" aria-selected="false">Heatmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="PCA-tab" data-toggle="tab" href="#PCA" aria-controls="PCA" aria-selected="false">PCA</a>
                    </li>
                </ul>
            </div>

            <div class="tab-content card-body" id="toolTabContent">
                <div class="tab-pane fade show active" id="filters" role="tabpanel" aria-labelledby="filters-tab" v-on:keyup.enter="applyFilters">
                    <div class="col-auto">
                        <div class="row">
                            <div id="filter_list">
                                <div v-for="(filter, index) in editing_filters" class="row"
                                    :key="filter.id">
                                    <div class='col form-inline filter_item'>
                                        <input class="form-control form-control-sm m-1 filter-lower-bound" style="width: 85px"
                                            v-bind:aria-label="'Lower bound for filter ' + index"
                                            v-model="filter.lower_bound"
                                            type="number" step="any">
                                        </input>

                                        &le;

                                        <select class="form-control form-control-sm m-1 filter_value_selector"
                                                v-bind:aria-label="'Filter selector for filter ' + index"
                                                v-model="filter.variable">
                                            <option v-for="filter_data in filter_data_list"
                                                    v-bind:value="filter_data.key">
                                                    {{filter_data.name}}
                                            </option>
                                        </select>

                                        &le;

                                        <input class="form-control form-control-sm m-1 filter-upper-bound" style="width: 85px"
                                            v-bind:aria-label="'Upper bound for filter ' + index"
                                            v-model="filter.upper_bound"
                                            type="number" step="any">
                                        </input>

                                        <button class="btn btn-default" v-bind:aria-label="'Remove filter ' + index" title="Remove filter"
                                                v-on:click="editing_filters = editing_filters.filter(function(x,j) {return j !== index;})">
                                            <span class="far fa-minus-square"> </span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row my-2">
                            <button id="applyFilters" type="button" class="btn btn-primary" v-on:click="applyFilters">Apply filters</button>
                            <button id="add_filter_button" class="btn btn-default" aria-label="Add filter"
                                v-on:click="addFilter">
                                <span class="far fa-plus-square" title="Add filter" data-toggle="tooltip" data-placement="top"></span>
                            </button>
                            <button id="reset_filters_button" class="btn btn-default" aria-label="Reset filters"
                                v-on:click="resetFilters">
                                <span class="fas fa-undo" title="Reset filters" data-toggle="tooltip" data-placement="top"></span>
                            </button>
                            <a id="filtersHelp" class="text-primary help-pointer ml-3"
                            data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                            title="Filter Help"
                            data-content="Keep only rows matching the criteria provided. Rerunning the q-values computes q-values using only the unfiltered genes. This is statistically invalid to do if filtering on most criteria (eg: if filtering p-values or q-values, one should not rerun the q-values). Instead, only rerun q-values when filtering exclusively on time-unaware criteria (such as max value).">
                                <i class="fas fa-info-circle"></i>
                            </a>
                        </div>
                        <div class="row my-2">
                            <div class="form-check">
                                <input class="form-check-input" id="q_values_exclude_filtered_option" type="checkbox" v-model="config.q_values_exclude_filtered">
                                <label class="form-check-label" for="q_values_excluded_filtered_option">Recompute q-values excluding filtered genes</label>
                                <a id="rerunQHelp" class="text-primary help-pointer ml-3"
                                    data-container="body" data-toggle="popover" data-placement="top" data-trigger="click"
                                    title="Rerun q-values help"
                                    data-content="Use this if you wish to exclude filtered out rows from q-values computation, for example after filtering out low-expressed genes. Note that this should only be used after filtering for basic features like mean/max values or missing timepoints. Filtering by any circadian statistic and then applying q-values is generally unsound and leads to highly excessive false positives.">
                                    <i class="fas fa-info-circle"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-pane fade" id="pathways" role="tabpanel" aria-labelledby="pathways-tab">
                    <pathway-analysis
                        v-bind:selected_rows="selected_rows"
                        v-bind:ids="spreadsheets[0] ? spreadsheets[0].ids : []"
                        v-bind:id_labels="spreadsheets[0] ? spreadsheets[0].id_col_labels : []"
                        v-bind:background_rows="background_rows"
                        >
                    </pathway-analysis>
                </div>
                <div class="tab-pane fade" id="heatmap" role="tabpanel" aria-labelledby="heatmap-tab">
                    <heatmap-plot
                        v-bind:spreadsheets="spreadsheets"
                        v-bind:descriptive_names="descriptive_names"
                        v-bind:num_days="num_days"
                        v-bind:selected_rows="selected_rows"
                        v-bind:timepoint_labels="timepoint_labels"
                        v-bind:day_and_time_labels="day_and_time_labels"
                        v-bind:sort_by_spreadsheet="config.sort_by.spreadsheet_num || 0"
                        v-bind:labels="labels">
                    </heatmap-plot>
                </div>
                <div class="tab-pane fade" id="PCA" role="tabpanel" aria-labelledby="PCA-tab">
                    <pca-plot
                        v-bind:spreadsheets="spreadsheets"
                        v-bind:descriptive_names="descriptive_names"
                        v-bind:timepoint_labels="timepoint_labels"
                        v-bind:share_token="share_token">
                    </PCA-plot>
                </div>
            </div>
        </div>
    </div>
    <div v-show="spreadsheets.length == 0">
        <h1>Spreadsheet Viewer</h1>
        <p> Loading... </p>
    </div>
    <div v-show="(spreadsheets.length > 0) && (labels.length == 0)">
        <h1>Spreadsheet Viewer</h1>
        <p> No rows loaded. </p>
        <p v-if="spreadsheets.length == 1"> Was your spreadsheet empty? </p>
        <p v-else> Check that the ID columns of the selected spreadsheets are compatible in the two spreadsheets. There may be no overlap in the selected feature id values.</p>
    </div>


    <!-- MODALS -->
    <div id="share_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">SHARE this spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="share_url">Copy this URL and offer it to anyone with whom you'd like to share your
                        spreadsheet data:</label>
                    <textarea id="share_url" class="form-control" rows="6">{{generated_share_url}}</textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
      </div>
    </div>

    <div id="download_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">Download spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <div class="form-group">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-include-data" v-model:value="download.include_data"></input>
                        <label class="form-check-label" for="download-include-data">
                            Include data
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-just-selected-rows" v-model:value="download.just_selected_rows"></input>
                        <label class="form-check-label" for="download-just-selected-rows">
                            Include only top {{config.selected_row+1}} rows
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="download-drop-filtered" v-model:value="download.drop_filtered_rows"></input>
                        <label class="form-check-label" for="download-drop-filtered">
                            Drop filtered-out rows
                        </label>
                    </div>
                    <div v-if="spreadsheets.length > 1">
                        <div v-for="(spreadsheet, i) in spreadsheets" class="form-group">
                            <label v-bind:for="'suffix'+i">Suffix {{i+1}}</label>
                            <input type="text" class="form-control" v-bind:id="'suffix'+i" v-model="download.suffixes[i]"> </input>
                        </div>
                    </div>
                    Statistics
                    <div class="form-check" v-for="(stat, stat_name) in useable_stats">
                        <input class="form-check-input" type="checkbox" v-bind:id="'download-'+stat_name" v-model:value="download.stats[stat_name]"></input>
                        <label class="form-check-label" v-bind:for="'download-'+stat_name">
                            {{stat.name}} statistics
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal" v-on:click="downloadSpreadsheet">Download</button>
            </div>
        </div>
      </div>
    </div>

    <div id="comparison_popup" class="modal" tabindex="-1" role="dialog">
      <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
          <div class="modal-header bg-primary">
            <h5 class="modal-title text-white">Compare this spreadsheet</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span class="text-white" aria-hidden="true">&times;</span>
            </button>
          </div>
            <div class="modal-body">
                <p>
                    Below are listed any compatible spreadsheets for comparison that you have previously uploaded.
                    If the spreadsheet is not there, you can <a href="/spreadsheet/upload_file/">upload it</a> or check that the both it and this spreadsheet have compatible metadata (same number timepoints and number of timepoints per cycle.
                    Even if a spreadsheet is shown here, it may not be a meaningful comparison.
                    In particular, the ID columns must contain some common values in the two spreadsheets.

                <table class="table table-sm">
                    <thead>
                        <tr>
                            <th> Comparison Spreadsheet </th>
                            <th> Original Filename </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="comparison in valid_comparisons" v-bind:key="comparison.id">
                            <td>
                                <a v-bind:href="'/spreadsheets/show_spreadsheet/'+(config.spreadsheet_ids.concat([comparison.id]).join(','))">
                                    {{comparison.name}}
                                </a>
                            </td>
                            <td>
                            {{comparison.original_filename}}
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
      </div>
    </div>

</div>

{% endraw %}

<script src="{{url_for('static', filename='js/row_selector.js')}}?v=4"></script>
<script src="{{url_for('static', filename='js/PCA_plot.js')}}?v=4"></script>
<script src="{{url_for('static', filename='js/heatmap_plot.js')}}?v=4"></script>
<script src="{{url_for('static', filename='js/pathway.js')}}?v=4"></script>
<script src="{{url_for('static', filename='js/pathway_component.js')}}?v=4"></script>

<script>
    Vue.prototype.util = {
        formatNum: formatNum,
        formatStatsEntry: function(entry){
            if(typeof entry === 'string') {
                return entry;
            } else {
                return  formatNum(entry, 4);
            }
        },
    };

    let stats_table = {
        none: {
            name: "none",
            value: "index",
            description: "No sorting",
            per_spreadsheet: false,
            num_spreadsheets: 'any',
        },
        jtk: {
            name: "JTK",
            value: {
                p: "jtk_p",
                q: "jtk_q"
            },
            description: "JTK_cycle significance of rhythmicity for dataset. Computed by meta2d.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            analysis_name: 'JTK',
        },
        ars: {
            name: "ARS",
            value: {
                p: "ars_p",
                q: "ars_q"
            },
            description: "ARSER significance of rhythmicity for dataset. Requires multiple cycles with a single replicate each in order to run.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            algorithm_name: "arser",
            analysis_name: 'ARS',
        },
        ls: {
            name: "LS",
            value: {
                p: "ls_p",
                q: "ls_q"
            },
            description: "Lomb-Scargle significance of rhythmicity for dataset.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            analysis_name: 'LS',
        },
        cosinor: {
            name: "Cosinor",
            value: {
                p: "cosinor_p",
                q: "cosinor_q"
            },
            description: "Cosinor significance of rhythmicity for dataset.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            analysis_name: 'Cosinor',
        },
        anova: {
            name: "ANOVA",
            value: {
                p: "anova_p",
                q: "anova_q"
            },
            description: "1-Way ANOVA on primary dataset. Tests whether the means of the timepoints are equal. Requires either multiple replicates or more than one cycle.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            algorithm_name: "one_way_anova",
            analysis_name: 'ANOVA',
        },

        rain: {
            name: "RAIN",
            value: {
                p: "rain_p",
                q: "rain_q"
            },
            description: "RAIN...",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            analysis_name: 'RAIN',
        },

        damping: {
            name: "Damping",
            value: {
                p: "upside_p",
                q: "upside_q"
            },
            description: "Damping analysis giving significance of a decrease in variation in the secondary dataset compared to the first.",
            per_spreadsheet: true,
            num_spreadsheets: 'multi'
        },
        two_way_anova: {
            name: "Two-way ANOVA",
            value: {
                p: "two_way_anova_p",
                q: "two_way_anova_q"
            },
            description: "Two-way ANOVA test for difference in timepoint-effects across datasets. Tests whether there is a difference in the 'shape' of the curve between the two datasets, disregarding any mean-value difference.",
            per_spreadsheet: false,
            num_spreadsheets: 'multi'
        },
        main_effect_diff: {
            name: "Main Effect Diff",
            value: {
                p: "main_effect_p",
                q: "main_effect_q"
            },
            description: "Main effect test of difference between the two datasets in the two-way ANOVA. Tests whether the grand mean (averaged over all timepoints) are the  in both datasetss",
            per_spreadsheet: false,
            num_spreadsheets: 'multi'
        },
        phase_difference: {
            name: "Phase Difference",
            value: {
                p: "phase_p",
                q: "phase_q"
            },
            description: "Test for equality of phase between datasets through cosinor analysis (least squares fit). See FAQ. Requires both datasets to have significant rhythmicity (i.e. it won't be significant if one is non-rhythmic since phase cannot be determined).",
            per_spreadsheet: false,
            num_spreadsheets: 'multi'
        },
        amplitude_difference: {
            name: "Amplitude Difference",
            value: {
                p: "amplitude_p",
                q: "amplitude_q"
            },
            description: "Test for equality of amplitudes between datasets through cosinor analysis (least squares fit).",
            per_spreadsheet: false,
            num_spreadsheets: 'multi'
        },
        lag: {
            name: "JTK lag",
            value: "jtk_lag",
            description: "Time the peak value occurs at, as calculated by JTK_CYCLE. Assumes circadian period of 24 hours.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            analysis_name: 'Wave properties',
        },
        period: {
            name: "JTK period",
            value: "jtk_period",
            description: "Detected period length, as calculated by JTK_CYCLE. Assumes a nearly circadian period of around 24 hours.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            analysis_name: 'Wave properties',
        },
        amplitude: {
            name: "JTK amplitude",
            value: "jtk_amplitude",
            description: "Amplitude of the oscillation, as calculated by JTK_CYCLE.",
            per_spreadsheet: true,
            num_spreadsheets: 'any',
            sort_direction: -1,
            analysis_name: 'Wave properties',
        },
    };

    let filter_data_list_base = [
        {values: function () {
                         // Grand maximum across both datasets within each row
                         if (app.spreadsheets.length === 0) { return []; }
                         let maxes = app.spreadsheets.map(function (spreadsheet) {
                                return maximums(spreadsheet.data);
                         });
                         return maxes[0].map( function(row, i) {
                            return Math.max.apply(null, maxes.map(function(max){return max[i];}));
                        });
                    },
                name: "Maximum value",
                independent: true,
                key:"max_value"},
        {values: function () {
                    // Grand means across both datasets within each row
                    // skipping over NaN/null values
                     if (app.spreadsheets.length === 0) { return []; }
                    let sums_ = app.spreadsheets.map(function(spreadsheet) {
                        let summed_rows = sums(spreadsheet.data);
                        return summed_rows;
                    });
                    let total_sums = sums(sums_, 0);

                    let nonnans = app.spreadsheets.map(function(spreadsheet) {
                        return numValids(spreadsheet.data);
                    });
                    let total_nonnans = sums(nonnans, 0);

                    let divide = function(a,b) { return a/b; };

                    let means = total_sums.map(function(sum, i) {
                        return sum / total_nonnans[i];
                    });
                    return means;
                },
                name: "Mean value",
                independent: true,
                key: "mean_value"},
        {values: function () {
                 if (app.spreadsheets.length === 0) { return []; }
                let missing = app.spreadsheets.map( function(spreadsheet) {
                     return numNaNTimepoints(spreadsheet.data, spreadsheet.x_values);
                });
                return maximums(missing, axis=0);
            },
            name: "Missing Timepoints",
            independent: true,
            key: "missing_timepoints"},
    ];

    let app = new Vue({
        el: "#vue-app",
        data: {
            editing_filters: [],
            spreadsheets_by_id: {}, // spreadsheets by ID
            config: {
                spreadsheet_ids: [],
                original_spreadsheet_ids: [],
                selected_row: 0,
                sort_by: {stat_id: "none", spreadsheet_num: 0},
                filters: [],
                q_values_exclude_filtered: false,
                hide_filtered_rows: false,
                plot: {
                    fold_days: false,
                    style: "mean_points",
                    x_label_style: "infer",
                    include_zero: false,
                },
            },

            search_value: '',

            stats_table: stats_table,

            stats: {
                index: null,
                amplitude_p: null,
                amplitude_q: null,
                phase_p: null,
                phase_q: null,
                two_way_anova_p: null,
                two_way_anova_q: null,
                main_effect_p: null,
                main_effect_q: null,
            },

            download: {
                include_data: true,
                just_selected_rows: false,
                drop_filtered_rows: false,
                suffixes: [],
                stats: {},
            },

            labels: [],
            timepoints_per_cycle: 0,
            num_days: 0,

            valid_comparisons: [],

            plot: {
                first_render: true,
            },

            share_token: '', // If from a share, the token used
            generated_share_url: '', // If we create a share token, store it here
            logged_in: false,

            notificationApiConnection: null, // WebSocket connection to listen for analysis results
            analyses: {}, // analysisID -> analyses information map
        },

        methods: {
            resetFilters: function(){
                this.editing_filters = [];
                this.config.filters.forEach(function(filter){
                    // make editing_filters a copy of the last-used filters
                    app.editing_filters.push(Object.assign({},filter));
                });
            },

            addFilter: function(){
                let new_id = 0; // Make filter keys
                if (this.editing_filters.length > 0){
                    new_id  = Math.max.apply(null, this.editing_filters.map( function(filter) {
                        return filter.id;
                    }))  + 1;
                }
                this.editing_filters.push( {variable: 'max_value', lower_bound:'', upper_bound:'', id: new_id} );
            },

            applyFilters: function() {
                // Copy the filters that we last ran
                // config.filters are the ones we actually filter on
                // needs to be deep copy so we json-ify it and back
                this.config.filters = JSON.parse(JSON.stringify(this.editing_filters));

                if (this.config.q_values_exclude_filtered) {
                    this.rerunQValues();
                }
            },

            rerunQValues: function() {
                let vm = this;
                // Remove the filtered out objects from use in the q-value computations
                for (key in vm.useable_stats) {
                    let stat = vm.useable_stats[key];
                    if (typeof stat.value === "object") {
                        // Has both p and q values
                        // Update q from p

                        if (stat.per_spreadsheet) {
                            for(spreadsheet of vm.spreadsheets) {
                                let p = spreadsheet[stat.value.p];
                                Vue.set(spreadsheet, stat.value.q,  vm.ps_to_qs(p));
                                console.log("Updating spreadsheet ", stat.value.q);
                            }
                        } else {
                            let p = vm.stats[stat.value.p];
                            Vue.set(vm.stats, stat.value.q,  vm.ps_to_qs(p));
                            console.log("Updating ", stat.value.q);
                        }
                    }
                }

                // Set the config values of having used these filters for q-values
                // vm.config.q_value_filters = true;
            },

            redrawPlot: function() {
                let vm = this;
                // Update the Plotly plots of the feature profiles
                let traces = [];
                let colors = Plotly.d3.scale.category10();
                vm.spreadsheets.forEach(function (spreadsheet, idx) {
                    let row_index = vm.sort_order[vm.config.selected_row];
                    raw_y_values = spreadsheet.data[row_index];
                    if (raw_y_values === undefined) {
                        console.log("Could not find the y-values for row " + row_index);
                        return;
                    }

                    if (vm.config.plot.fold_days) {
                        plot_x_values = spreadsheet.x_values.map(function (x) {return x % spreadsheet.timepoints_per_cycle;});
                        // Generic Timepoint1, ... TimepointK labels (no "Day")
                        plot_x_labels = app.timepoint_labels[idx];
                        plot_x_label_values = plot_x_labels.map(function(x,i) {return i;});
                    } else {
                        plot_x_values = spreadsheet.x_values;
                        // Generic Day1 Timepoint1, ... DayN TimepointK labels
                        plot_x_labels = app.day_and_time_labels[idx];
                        plot_x_label_values = [...Array(spreadsheet.num_timepoints).keys()]; // 0,1,2...,num_timepoints-1
                    }

                    let x_label_style = vm.config.plot.x_label_style;
                    if (x_label_style === 'none') {
                        plot_x_labels = plot_x_labels.map( function (x) {return '';} );
                    } else if (x_label_style === 'time') {
                        plot_x_labels = plot_x_labels.map( function(x,i) {
                            return "Timepoint " + (i % spreadsheet.timepoints_per_cycle + 1);
                        });
                    } else if (x_label_style === 'infer') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_cycle);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t);
                            });
                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        }
                    } else if (x_label_style === 'infer_wrapped') {
                        let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_cycle);
                        if (inferred !== null) {
                            let headings = inferred.times.map(function(t) {
                                return inferred.format.make_label(t, true);
                            });

                            plot_x_labels = [];
                            plot_x_label_values = [];
                            spreadsheet.x_values.forEach( function (time,i) {
                                if (plot_x_labels[time] === undefined) {
                                    plot_x_labels[time] = headings[i];
                                    plot_x_label_values[time] = time;
                                }
                            });
                        } else {
                            plot_x_labels = plot_x_label_values.map(function(x) {
                                return app.timepoint_labels[0][x % spreadsheet.timepoints_per_cycle];
                            });
                        }
                    }

                    let stats = rowStatsByTimepoint(raw_y_values, plot_x_values);

                    // Pick a color for this spreadsheet using Plotly's defaults from d3
                    let spreadsheet_color = colors(idx);
                    let marker_settings = {size: 12, symbol: 'circle-open'};


                    // Default values for the different plot styles to override
                    let trace = {
                        x: plot_x_values, y: raw_y_values,
                        mode: 'markers',
                        marker: marker_settings,
                        name: vm.descriptive_names[idx],
                        type: 'scatter',
                        'marker': {color: spreadsheet_color},
                        'line': {color: spreadsheet_color},
                    };

                    // Pick data and styling based off the plot_style_select value
                    let plot_style = vm.config.plot.style;
                    if (plot_style === "basketweave") {
                        // Make pairs of points that are adjacent in time to each other, for each dataset
                        column_pairs = [];
                        plot_x_values.forEach( function(x,i) {
                            for(let j = i+1; j < plot_x_values.length; j++) {
                                if (Math.abs(plot_x_values[j] - x) === 1) {
                                    column_pairs.push([i,j]);
                                }
                            }
                        });

                        paired_y_values = [];
                        for (let i in column_pairs) {
                            paired_y_values.push(raw_y_values[column_pairs[i][0]], raw_y_values[column_pairs[i][1]], null);
                        }

                        paired_x_values = [];
                        for (let i in column_pairs) {
                            paired_x_values.push(plot_x_values[column_pairs[i][0]], plot_x_values[column_pairs[i][1]], null);
                        }

                        trace.mode = 'lines+markers';
                        trace.x = paired_x_values;
                        trace.y = paired_y_values;
                    } else if (plot_style === "points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                    } else if (plot_style === "mean") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                    } else if (plot_style === "mean_points") {
                        trace.x = plot_x_values;
                        trace.y = raw_y_values;
                        trace.text = spreadsheet.column_headers;
                        traces.push({ // The mean value trace
                            x: stats.means.map( function (x,i) {return i;} ), // Just 0,1,2,3...
                            y: stats.means,
                            type: "scatter",
                            mode: "lines",
                            showlegend: false,
                            'line': {color: spreadsheet_color}
                        });
                    } else if (plot_style === "std") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                    } else if (plot_style === "std_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.stds, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            showlegend: false,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style === "SEM") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                    } else if (plot_style === "SEM_points") {
                        trace.mode = "lines";
                        trace.x = stats.means.map( function (x,i) {return i;} ); // Just 0,1,2,3...
                        trace.y = stats.means;
                        trace.error_y = {type: 'data', array:stats.sems, visible:true};
                        traces.push({
                            x: plot_x_values,
                            y: raw_y_values,
                            text: spreadsheet.column_headers,
                            type: 'scatter',
                            showlegend: false,
                            mode: 'markers',
                            marker: {color: spreadsheet_color},
                        });
                    } else if (plot_style == "repeated_measures") {
                        trace.mode = "lines";
                        // Collect the data by replicate
                        // Replicates have to be ordered the same
                        // I.e. First rep is first in all timepoints
                        let data_by_trace = [];
                        let rep_counts = [];
                        let last_value = 0;
                        plot_x_values.forEach( function(x,i) {
                            // Count how many we've seen before at this time
                            if (rep_counts[x] === undefined) {
                                rep_counts[x] = 0;
                            }
                            let rep_num = rep_counts[x];
                            rep_counts[x] += 1;

                            if (data_by_trace[rep_num] === undefined) {
                                data_by_trace[rep_num] = []; // Start new trace
                            }
                            // Add this reading to the trace for the replicate
                            data_by_trace[rep_num].push(raw_y_values[i]);
                        });


                        // Skip the default trace
                        trace = {};

                        // Add one trace per replicate
                        data_by_trace.forEach( function(trace,i) {
                            traces.push({
                                x: trace.map( function(x,i) {return i;}),
                                y: trace,
                                type: 'lines',
                                showlegend: false,
                                line: {color: spreadsheet_color},
                            });
                        });
                    } else if (plot_style == "cosinor") {
                        // number of sampling points used for plotting cosinor
                        const sampling_density = 120;

                        let t = [];
                        let period = 24*spreadsheet.num_timepoints/spreadsheet.timepoints_per_cycle;
                        if (vm.config.plot.fold_days) {
                            period = 24;
                        }
                        for (let i = 0; i <= sampling_density; i++) {
                            t.push(period*i/sampling_density);
                        }

                        if (spreadsheet.cosinor_x0 !== null) {
                            let x0 = spreadsheet.cosinor_x0[row_index];
                            let x1 = spreadsheet.cosinor_x1[row_index];
                            let x2 = spreadsheet.cosinor_x2[row_index];

                            let y = t.map(t => x0 + x1*Math.cos(2*Math.PI*t/24) + x2*Math.sin(2*Math.PI*t/24));

                            // rescale to match the other plots
                            for (let i = 0; i < t.length; i++) {
                                t[i] *= spreadsheet.timepoints_per_cycle/24;
                            }

                            traces.push({
                                x: t, y,
                                mode: "lines",
                                type: "scatter",
                                line: {color: spreadsheet_color},
                                opacity: 0.2,
                                name: "Cosinor fit",
                            });
                        }
                    }

                    traces.push(trace);

                });

                let layout = {
                    hovermode: 'closest',
                    title: app.labels[app.sort_order[app.config.selected_row]],
                    legend: { orientation: 'h', y: -0.25 },
                    font: {
                        size: FONT_SIZE,
                    },
                    xaxis: {
                        ticktext: plot_x_labels,
                        tickvals: plot_x_label_values,
                        automargin: true,
                    },
                    yaxis: {
                        rangemode: vm.config.plot.include_zero ? 'tozero' : '',
                    }
                };

                if (vm.plot.first_render) {
                    Plotly.newPlot('scatter_plot', traces, layout);
                    vm.plot.first_render = false;
                } else {
                    Plotly.react('scatter_plot', traces, layout);
                }
            },

            downloadPlot: function(format) {
                let gd = document.getElementById('scatter_plot');
                Plotly.downloadImage(gd, {format: format, filename: 'plot_' + (app.config.selected_row+1)});
            },


            selectRow: function(row) {
                this.config.selected_row = Math.min(Math.max(row, 0), this.labels.length-1);
            },

            onRowChange: function () {
                this.redrawPlot();

                $('#coarse_slider').slider('value', this.config.selected_row);
            },

            searchRows: function() {
                let search_value = this.search_value.toLowerCase().trim();

                // Pull out row indexes matching our search_value
                let matching_rows = app.labels.map( function(unused, index) {
                    let label = app.labels[app.sort_order[index]];
                    if (label.toLowerCase().indexOf(search_value) !== -1) {
                        return index;
                    }
                }).filter(isFinite);


                if (matching_rows.length === 0) {
                    console.log("Unfortunately no matching row found.");
                    // TODO: display something to the user
                    return;
                }

                // Find matches in rows past the current selection
                let matches_after = matching_rows.filter( function (i) {
                    return i > app.config.selected_row;
                } );

                let row = null;
                if (matches_after.length > 0) {
                    // First look for matches that are *after* our config.selected_row
                    // so that multiple button presses will cycle the selection through all matches
                    row = matches_after[0];
                } else {
                    // If that fails, grab the first matching row
                    row = matching_rows[0];
                }

                app.config.selected_row = row;
            },

            onShare: function() {
                if (!app.logged_in) {
                    nitecap_error_message.text("You must log in or register an account to create a shareable URL.");
                    nitecap_error.modal();
                }

                // Open Modal to share the spreadsheet
                let vm = this;
                $.ajax({
                    url: "{{url_for('spreadsheets.share')}}",
                    data: JSON.stringify({'spreadsheet_ids': vm.config.original_spreadsheet_ids, 'config': vm.config}),
                    dataType: "json",
                    contentType: "application/json",
                    type: 'POST',
                    success: function (response) {
                        vm.generated_share_url = "{{url_for('spreadsheets.share', _external=True)}}/" + response['share'];
                        $('#share_popup').modal()
                    },
                    error: function (request) {
                        error_message = $.parseJSON(request.responseText).error;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    }
                });
            },

            triggerDownloadPopup: function() {
                // Fill in default suffix values if they don't yet have any
                if (this.download.suffixes.length === 0) {
                    this.download.suffixes = this.descriptive_names;
                }
                $("#download_popup").modal();
            },

            triggerComparisonPopup: function() {
                // Open Modal to compare the spreadsheet
                let vm = this;
                $.ajax({
                    url: "{{url_for('spreadsheets.get_valid_comparisons')}}",
                    data: JSON.stringify({'spreadsheet_ids': vm.config.original_spreadsheet_ids}),
                    dataType: "json",
                    contentType: "application/json",
                    type: 'POST',
                    success: function (response) {
                        vm.valid_comparisons = response;
                        $("#comparison_popup").modal();
                    },
                    error: function (request) {
                        error_message = $.parseJSON(request.responseText).error;
                        nitecap_error_message.text(error_message);
                        nitecap_error.modal();
                    }
                });
            },


            downloadSpreadsheet: function() {
                let vm = this;

                let suffixes = vm.download.suffixes.map(x => "_"+x);
                if (vm.spreadsheets.length === 1) { suffixes = ['']; }

                let download_rows = null;
                if (vm.download.just_selected_rows) {
                    download_rows = vm.sort_order.slice(0,vm.config.selected_row+1);
                } else {
                    // All rows 0,1,2,...
                    download_rows = app.labels.map(function(x,i) { return i;} );
                }

                if (vm.download.drop_filtered_rows) {
                    download_rows = download_rows.filter(function(x) {
                        return !vm.filtered[x];
                    });
                }

                let restrict = function(column) {
                    // Returns just the relevant rows of the column
                    return download_rows.map(i => column[i]);
                };

                // Assemble the data to be downloaded
                let columns = new Map();

                // First include the ID columns
                vm.spreadsheets[0].id_col_labels.forEach(function(label, i) {
                    columns.set(label, restrict(vm.spreadsheets[0].ids[i]));
                });

                // Include raw spreadsheet data if requested
                if (vm.download.include_data) {
                    vm.spreadsheets.forEach( function(spreadsheet, idx) {
                        let suffix = suffixes[idx];
                        spreadsheet.column_headers.forEach(function(column_header, i) {
                            let column_data = spreadsheet.data.map(row => row[i]);
                            columns.set(column_header + suffix, restrict(column_data));
                        });
                    });
                }

                // Gather the statistic columns which were selected
                for (let stat_name in vm.stats_table) {
                    if (vm.download.stats[stat_name] === true) {
                        let stat = vm.stats_table[stat_name];

                        if (typeof stat.value === 'string') {
                            // stat.value is the name of the stat itself
                            if (stat.per_spreadsheet) {
                                vm.spreadsheets.forEach( function(spreadsheet, idx) {
                                    let suffix = suffixes[idx];
                                    columns.set(stat.value + suffix, restrict(spreadsheet[stat.value]));
                                });
                            } else {
                                columns.set(stat.value, restrict(vm.stats[stat.value]));
                            }
                        } else {
                            // Object containing p,q
                            if (stat.per_spreadsheet) {
                                vm.spreadsheets.forEach(function(spreadsheet, idx) {
                                    let suffix = suffixes[idx];
                                    columns.set(stat.value.p + suffix, restrict(spreadsheet[stat.value.p]));
                                    columns.set(stat.value.q + suffix, restrict(spreadsheet[stat.value.q]));
                                });
                            } else {
                                columns.set(stat.value.p, restrict(vm.stats[stat.value.p]));
                                columns.set(stat.value.q, restrict(vm.stats[stat.value.q]));
                            }
                        }
                    }
                }

                let tsv = toTSV(columns);

                // Create a URL for it
                let blob = new Blob([tsv]);
                let url = URL.createObjectURL(blob);

                // Trigger downloading of the URL by making an <a href ...> to it and clicking it
                let anchor = document.createElement("a");
                anchor.href = url;
                anchor.download = "spreadsheet.txt";
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);

                // Cleanup after 5mins
                setTimeout(function () { URL.revokeObjectURL(url) }, 5*60*1000);
            },

            shiftSpreadsheets: function () {
                // Shifts through the spreadsheets in order
                let spreadsheets = this.config.spreadsheet_ids;
                let first = spreadsheets[0];
                let tail = spreadsheets.slice(1);
                spreadsheets = tail.concat(first);
                this.config.spreadsheet_ids = spreadsheets;
            },

            connectToNotificationApi: function() {
                console.log("Attempting to connect to", NOTIFICATION_API_ENDPOINT);
                let vm = this;
                if (this.notificationApiConnection) return;

                this.notificationApiConnection = new WebSocket(
                    NOTIFICATION_API_ENDPOINT
                );

                this.notificationApiConnection.onopen = () =>
                    this.notificationApiConnection.send(user_id);

                this.notificationApiConnection.onerror = (event) =>
                    console.log(
                        "An error in communication with notification API has occurred:",
                        event
                );

                this.notificationApiConnection.onclose = () => {
                    this.notificationApiConnection = null;
                    console.log("Connection with notification API closed");
                };

                this.notificationApiConnection.onmessage = this.processNotification;
            },

            fetchAnalysisResults: async function (analysisId) {
                let vm = this;
                let url_response = await fetch(`/analysis/${analysisId}/results/url`,{
                    headers: { "Authorization": share_token },
                });
                let target_url = await url_response.text();

                let response = await fetch(target_url);
                let results = await response.json();

                let analysis = Object.freeze({
                    ...this.analyses[analysisId],
                    ...results,
                    status: "COMPLETED",
                });
                Vue.set(this.analyses, analysisId, analysis);

                // Load the values
                let spreadsheet = app.spreadsheets_by_id[analysis.spreadsheetId];
                let reorder = function (list) { return list.map( (x,i) => list[spreadsheet.row_numbers[i]] ); }
                console.log("Obtained results of ", analysis.name, " for spreadsheet ", analysis.spreadsheetId);
                if(analysis.name == "Cosinor") {
                    spreadsheet.cosinor_p = Object.freeze(reorder(analysis.p));
                    spreadsheet.cosinor_q = Object.freeze(vm.ps_to_qs(spreadsheet.cosinor_p));
                    spreadsheet.cosinor_x0 = Object.freeze(reorder(analysis.x.map( row => row[0])));
                    spreadsheet.cosinor_x1 = Object.freeze(reorder(analysis.x.map( row => row[1])));
                    spreadsheet.cosinor_x2 = Object.freeze(reorder(analysis.x.map( row => row[2])));
                } else if(analysis.name == "LS") {
                    spreadsheet.ls_p = Object.freeze(reorder(analysis.p));
                    spreadsheet.ls_q = Object.freeze(vm.ps_to_qs(spreadsheet.ls_p));
                } else if(analysis.name == "ARS") {
                    spreadsheet.ars_p = Object.freeze(reorder(analysis.p));
                    spreadsheet.ars_q = Object.freeze(vm.ps_to_qs(spreadsheet.ars_p));
                } else if(analysis.name == "JTK") {
                    spreadsheet.jtk_p = Object.freeze(reorder(analysis.p));
                    spreadsheet.jtk_q = Object.freeze(vm.ps_to_qs(spreadsheet.jtk_p));
                } else if(analysis.name == "ANOVA") {
                    spreadsheet.anova_p = Object.freeze(reorder(analysis.p));
                    spreadsheet.anova_q = Object.freeze(vm.ps_to_qs(spreadsheet.anova_p));
                } else if(analysis.name == "RAIN") {
                    spreadsheet.rain_p = Object.freeze(reorder(analysis.p));
                    spreadsheet.rain_q = Object.freeze(vm.ps_to_qs(spreadsheet.rain_p));
                } else if(analysis.name == "Wave properties") {
                    spreadsheet.jtk_lag = Object.freeze(reorder(analysis.lag));
                    spreadsheet.jtk_period = Object.freeze(reorder(analysis.period));
                    spreadsheet.jtk_amplitude = Object.freeze(reorder(analysis.amplitude));
                } else {
                    console.error("Unknown analysis results found:", analysis.name, analysis);
                }
            },

            runAnalysis: async function (name, spreadsheet, algorithm, options) {
                let vm = this;
                let spreadsheetId = spreadsheet.spreadsheet_id;
                let viewId = spreadsheet.view_id;

                let response = await fetch("/analysis/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": share_token },
                    body: JSON.stringify({ algorithm, spreadsheetId, viewId, share_token: share_token, ...options, version: VERSION}),
                });

                if (!response.ok) {
                    console.error("Failed to start analysis with status", response.status);

                    // We didn't get an analysis ID in response, so we create a dummy ID
                    // just for the purposes of recording the failure so we can display "FAILED"
                    let dummy_analysis_id = "dummy_" + Math.floor(1000*Math.random());
                    Vue.set(this.analyses, dummy_analysis_id, {
                        name,
                        algorithm,
                        spreadsheetId,
                        status: "FAILED",
                        startTime: performance.now(),
                        progress: null,
                        duration: 0,
                    });
                    return;
                }

                let analysisId = await response.text();

                // // Check analysis id
                // let parameters = JSON.stringify({
                //   algorithm,
                //   spreadsheetId,
                //   userId: this.userId,
                // });

                // if (analysisId !== (await sha256(parameters)))
                //   console.error("Mismatch in analysis ID calculation");

                Vue.set(this.analyses, analysisId, {
                    name,
                    algorithm,
                    spreadsheetId,
                    status: "PENDING",
                    startTime: performance.now(),
                    progress: null,
                    duration: 0,
                });

                this.connectToNotificationApi();


                let check_and_fetch = async function() {
                    // Check whether results are done already and if so fetch them
                    if (vm.analyses[analysisId].status === "COMPLETED") {
                        return;
                    }

                    let status_result = await fetch(`/analysis/${analysisId}/status`, {
                        headers: { "Authorization": share_token },
                    });

                    let status = await status_result.text();
                    if (status === "COMPLETED") {
                        await vm.fetchAnalysisResults(analysisId);
                    } else if (status == "FAILED") {
                        vm.analyses[analysisId].status = status;
                    }
                }

                // Set a timer to automatically check status once incase we subscribe too late to the websocket connection
                window.setTimeout(check_and_fetch, 20*1000);

                // Check if the data already is done - eg it was computed on a previous run
                await check_and_fetch();
            },

            processNotification: async function (event) {
                message = JSON.parse(event.data);

                let { analysisId, spreadsheetId, ...analysisUpdate } = message;
                let analysis = this.analyses[analysisId];

                // There are several explanations for the situation when the analysis is not in our analyses collection:
                //  - the user might have refreshed the page
                //  - this update is for analysis of another spreadsheet
                //
                // Let's first fetch the information about the missing analysis:
                if (!analysis) {
                    let response = await fetch(`/analysis/${analysisId}/parameters`, {
                        headers: { "Authorization": share_token },
                    });
                    analysis = await response.json();
                }

                // Skip if this update is for analysis of another spreadsheet
                if (this.spreadsheets_by_id[analysis.spreadsheetId] === undefined) {
                    console.log("Received data from wrong spreadsheet, ignoring", analysis);
                    return;
                }

                analysis["duration"] = performance.now() - analysis.startTime; // the start time information is lost upon refresh

                Vue.set(this.analyses, analysisId, {
                    ...analysis,
                    ...analysisUpdate,
                });

                if (analysisUpdate["status"] === "COMPLETED") {
                    this.fetchAnalysisResults(analysisId);
                }
            },

            getStatStatusDisplay: function(stat_id, spreadsheet_num) {
                let stat = this.stats_table[stat_id];
                let algorithm = stat.algorithm_name || stat_id;
                if (stat.num_spreadsheets == "multi") {
                    // For now these are not run by 'analyses'
                    // TODO: update this when we put comparison stats into analyses
                    return "loading";
                } else {
                    let spreadsheet = this.spreadsheets[spreadsheet_num];
                    let spreadsheet_id = spreadsheet.spreadsheet_id;
                    // Find the appropriate analysis (if any) and format display based off that
                    for (let [id, analysis] of Object.entries(this.analyses)) {
                        if ((analysis.name === stat.analysis_name) && (analysis.spreadsheetId === spreadsheet_id)) {
                            if (analysis.status === "RUNNING") {
                                return (100*(analysis.progress.value / analysis.progress.max)).toFixed(0) + "%";
                            } else if (analysis.status === "COMPLETED") {
                                return "COMPLETE";
                            }
                            else {
                                return analysis.status;
                            }
                        }
                    }
                }
                return "Unknown";
            },

            ps_to_qs: function(ps) {
                // Given a list of p-values, compute q-values
                let vm = this;
                if (ps === null) { return null; }
                if (vm.config.q_values_exclude_filtered) {
                    ps = ps.map(function(p,i) {
                        if (vm.filtered[i]) { return NaN; }
                        return p;
                    });
                }

                return BH_FDR(ps);
            },
        },

        computed: {
            spreadsheets: function() {
                // Spreadsheets in the order they are displayed
                let vm = this;
                return vm.config.spreadsheet_ids.map(function(id) { return vm.spreadsheets_by_id[id]; } )
            },

            row_index: function() {
                if (this.sort_order !== null) {
                    return this.sort_order[this.config.selected_row];
                } else {
                    return this.config.selected_row;
                }

            },

            num_below: {
                get: function () {
                    return this.num_significant_below[this.config.selected_row];
                },
                set: function (val) {
                    val = parseInt(val);
                    if (val === null || this.num_significant_below === null) {
                        this.config.selected_row = 0;
                    }

                    let idx = this.num_significant_below.indexOf(val);
                    if (idx !== -1) {
                        this.config.selected_row = idx;
                    } else {
                        if (idx > Math.max(null, this.num_significant_below)) {
                            this.config.selected_row = this.num_siginificant_below.length;
                        } else {
                            this.config.selected_row = 0;
                        }
                    }
                }
            },

            sort_by: function() {
                return {
                    stat: this.stats_table[this.config.sort_by.stat_id],
                    stat_id: this.config.sort_by.stat_id,
                    spreadsheet_num: this.config.sort_by.spreadsheet_num,
                };
            },

            sort_function: function () {
                // We sort by the value specified in config.sort_by
                // display_value is the value array that should be monotonic in the sort order
                // which are convenient for the user to look at, i.e. q-values if available
                let vm = this;
                let variable = null;
                let display_variable = null;

                // Handle what type of variable this is:
                // 2: string identifying a stat to use - use that stat
                // 3: p/q pair, use p's but print q's
                if (typeof this.sort_by.stat.value === 'string') {
                    variable = this.sort_by.stat.value;
                    display_variable = variable;
                } else {
                    variable = this.sort_by.stat.value.p;
                    display_variable = this.sort_by.stat.value.q;
                }

                // Figure out what spreadsheet (if any) to pull data from
                let value = null;
                let display_value = null;
                if (vm.sort_by.stat.per_spreadsheet) {
                    if (vm.spreadsheets.length > 0) {
                        value = vm.spreadsheets[vm.sort_by.spreadsheet_num][variable];
                        display_value = vm.spreadsheets[vm.sort_by.spreadsheet_num][display_variable];
                    }
                } else {
                    value = vm.stats[variable];
                    display_value = vm.stats[display_variable];
                }

                let sort_direction = 1;
                if (this.sort_by.stat && this.sort_by.stat.sort_direction !== undefined) {
                    sort_direction = this.sort_by.stat.sort_direction;
                }

                let sorter = function (i,j) {
                    let a = value[i];
                    let b = value[j];
                    return compare(a ? a * sort_direction : a, // multiply by +/- 1 but not if null
                                   b ? b * sort_direction : b,
                                   i, j);
                };

                if (value === null) {
                    // Don't sort at all - eg: data hasn't loaded yet or we aren't sorting at all
                    // display_value will just be the index
                    sorter = function(i,j) { return i - j; };
                    display_value = app.labels.map(function(x,i) {return i+1;});
                }

                return {"func": sorter, "value": value, "display_value":display_value, "sort_direction": sort_direction};
            },

            sort_order: function () {
                let vm = this;
                if (this.labels.length == 0) { return []; } // No spreadsheets yet

                let sort_order =  this.labels.map( function(x,i) {return i;} );
                sort_order = sort_order.sort(this.sort_function.func);

                if (this.config.hide_filtered_rows) {
                    // Move filtered items from the sort_order to the back of the list  to hide them
                    let head = sort_order.filter( function(x) {return !vm.filtered[x];});
                    let tail = sort_order.filter( function(x) {return vm.filtered[x];});
                    sort_order = head.concat(tail);
                }

                return sort_order;
            },

            label_q: function () {
                if (this.sort_by.stat === null) {
                    // No stat selected
                    return null;
                }
                let value = this.sort_by.stat.value;

                if (typeof value === 'string') {
                    // No inherent q-value for this sort value
                    // drop the "Q:" label
                    return null;
                }

                if (this.sort_by.stat.per_spreadsheet) {
                    let sp = this.spreadsheets[this.sort_by.spreadsheet_num];
                    let vq = value.q;
                    let vals = sp ? sp[vq]: [];
                    return vals;
                } else {
                    return this.stats[value.q];
                }
            },

            filtered: function () {
                let vm = this;
                let filtered_out = this.labels.map( function (x) {return false;} );
                if (filtered_out.length == 0){  return filtered_out; }

                // Apply all filters
                this.config.filters.forEach(function(filter) {
                    let filter_value = filter.variable;

                    let lower_bound = parseFloat(filter.lower_bound);
                    let upper_bound = parseFloat(filter.upper_bound);

                    if (isNaN(lower_bound) || lower_bound === null) {lower_bound = -Infinity;}
                    if (isNaN(upper_bound) || upper_bound === null) {upper_bound = Infinity;}

                    let idx = vm.filter_data_list.map(function(filter) {return filter.key;} ).indexOf(filter_value);
                    let values = vm.filter_data_list[idx].values();
                    if (values === null || values === undefined) { return; } // Haven't loaded values yet, can't filter by them

                    filtered_out = filtered_out.map( function (x,i) {
                        return x || (values[i] < lower_bound) || (values[i] > upper_bound);
                    });
                });

                return filtered_out;
            },

            num_significant_below: function() {
                // Recompute the number of signifcant items below a cutoff
                // discards filtered out rows
                let num_significant_below = new Array(this.labels.length);
                let ctr = 0;
                let filtered = this.filtered;
                let sort_order = this.sort_order;
                this.labels.forEach(function(label, index) {
                    if (!filtered[sort_order[index]]) {
                        ctr++;
                    }

                    num_significant_below[index] = ctr;
                });
                return num_significant_below;
            },

            selected_rows: function() {
                // List of indices of the rows that are selected
                // I.e. unfiltered, and below the significance cutoff
                let vm = this;
                let filtered = vm.filtered;
                let selected_row = vm.config.selected_row;

                let selected = vm.sort_order.filter( function(row_num,rank) {
                    return (rank <= selected_row) & (!filtered[row_num]);
                } );
                return selected;
            },

            background_rows: function() {
                let vm = this;
                if (vm.spreadsheets.length == 0) { return []; }
                return vm.spreadsheets[0].labels.map(function(x,i) { return i; }).filter( function(i) {return !vm.filtered[i];});
            },

            useable_stats: function () {
                // Only the stats from stats_table that apply to this context
                // i.e. the ones we have enough spreadsheets for
                let vm = this;
                let stats = {};
                for (key in this.stats_table) {
                    if (key === 'none') { continue; }

                    let stat = this.stats_table[key]
                    if ((stat.num_spreadsheets == 'multi')
                            && (vm.spreadsheets.length < 2)) {
                        continue; // Need 2 or more spreadsheets
                    }
                    stats[key] = stat;
                }
                return stats;
            },

            filter_data_list: function () {
                // List of filters including the 'special' ones declared in filters_data_list_base
                // and also those derived from the statistics in stats_table
                let vm = this;

                // Make a filter for each stat
                let stat_filters = [];
                for (key in vm.useable_stats) {
                    let stat = vm.useable_stats[key];
                    if (stat.per_spreadsheet) {
                        let just_one = vm.spreadsheets.length === 1;
                        vm.spreadsheets.forEach( function(spreadsheet, idx) {
                            if (typeof stat.value === 'string') {
                                let name = stat.name + ' ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value];},
                                     independent: false,
                                     key: name
                                });
                            } else {
                                let name = stat.name + ' p ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.p];},
                                     independent: false,
                                     key: name
                                });

                                name = stat.name + ' q ' + (just_one ? '' : idx + 1);
                                stat_filters.push({
                                     name: name,
                                     values: function () {return spreadsheet[stat.value.q];},
                                     independent: false,
                                     key: name
                                });
                            }
                        });
                    } else {
                        if (typeof stat.value === 'string') {
                            stat_filters.push({
                                 name: stat.name,
                                 values: function () {return vm.stats[stat.value];},
                                 independent: false,
                                 key: stat.name
                            });
                        } else {
                            stat_filters.push({
                                 name: stat.name + ' p',
                                 values: function () {return vm.stats[stat.value.p];},
                                 independent: false,
                                 key: stat.name + ' p',
                            });

                            stat_filters.push({
                                 name: stat.name + ' q',
                                 values: function () {return vm.stats[stat.value.q];},
                                 independent: false,
                                 key: stat.name + ' q',
                            });
                        }
                    }

                }

                // Return all filters, including the 'base' ones and the ones derived from our statistics
                return filter_data_list_base.concat(stat_filters);
            },

            timepoint_labels: function() {
                // Labels to use for timepoints 0,1,2,...,timepoints_per_cycle-1
                // ignoring the cycle/day number
                let vm = this;

                return vm.spreadsheets.map( function(spreadsheet) {
                    // Try to infer if possible from column headers
                    let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_cycle);
                    if (inferred !== null) {
                        let headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t, true);
                        });
                        let labels = [];
                        spreadsheet.x_values.forEach( function (time,i) {
                            if (labels[time] === undefined) {
                                labels[time] = headings[i];
                            }
                        });
                        return labels;
                    }

                    // Otherwise we default to "Timepoint 1", etc.
                    let times = [...Array(spreadsheet.timepoints_per_cycle).keys()]; // 0,1,2...,num_timepoints-1
                    return times.map( function(time) {
                        return "Timepoint " + (time + 1);
                    });
                });
            },

            day_and_time_labels: function() {
                // Labels to use for Day 1 Timepoint 1, etc.
                let vm = this;

                return vm.spreadsheets.map( function(spreadsheet) {
                    let times = spreadsheet.x_values;

                    // Try to infer if possible from column headers
                    let inferred = inferColumnTimes(spreadsheet.column_headers, vm.num_days, spreadsheet.timepoints_per_cycle);
                    let headings = null;
                    if (inferred !== null) {
                        headings = inferred.times.map(function(t) {
                            return inferred.format.make_label(t);
                        });
                    } else {
                        headings = times.map( function(time) {
                            return "Day " + (Math.floor(time / spreadsheet.timepoints_per_cycle) + 1) + " Timepoint " + (time % spreadsheet.timepoints_per_cycle + 1);
                        });
                    }

                    // Return only one heading per time
                    // by dropping repeated times
                    let labels = [];
                    times.forEach( function (time,i) {
                         if (labels[time] === undefined) {
                             labels[time] = headings[i];
                         }
                    });
                    return labels;
                });
            },

            descriptive_names: function() {
                // Descriptive names for spreadsheets
                // They are given descriptive names already but we want to isolate the part that is 'variable' between them
                // for easier display
                let names = this.spreadsheets.map( function(x) {return x.descriptive_name;});

                if (names.length < 2) {
                    // Can't simplify anything if there is only one!
                    return names;
                }

                // Split on whitespace or common filename delimiteres
                let split_by = new RegExp('[\\s,._]+');
                let split_names = names.map( function(x) { return x.split(split_by);});

                // Find the common prefix for all the names
                // eg names "Tom Dataset WT" and "Tom Dataset KO"
                // have prefix ["Tom", "Dataset"]
                let prefix = split_names[0];
                split_names.forEach(function(split_name) {
                    let no_mismatch_yet = true;
                    prefix = prefix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                });

                // Same as above, but find the common suffix for all the names
                let suffix = split_names[0].slice(0).reverse();
                split_names.forEach(function(split_name) {
                    split_name.reverse();
                    let no_mismatch_yet = true;
                    suffix = suffix.filter( function(word, i) {
                        let match = word == split_name[i];
                        if (!match) { no_mismatch_yet = false; }
                        return match && no_mismatch_yet
                    });
                    split_name.reverse(); // put it back
                });
                suffix = suffix.reverse();

                // Re-build the names with the prefix and suffix removed
                names = split_names.map( function(split_name, idx) {
                    let reduced_name = split_name.slice(prefix.length, split_name.length - suffix.length).join(" ");
                    if (reduced_name === '') { return  names[idx]; }// Cut everything out, just use the original name
                    return reduced_name;
                });
                return names;
            },

            cutoff: {
                get: function() {
                    if (this.spreadsheets.length == 0) { return 0; }
                    return this.sort_function.display_value[this.sort_order[this.config.selected_row]];
                },
                set: function(value) {
                    let app = this;
                    let sort_values = app.sort_function.display_value;
                    let i = 0;
                    for(; i < sort_values.length; i++) {
                        let v = sort_values[app.sort_order[i]];
                        if ((app.sort_function.sort_direction * v) > (app.sort_function.sort_direction * value)) {
                            break;
                        }
                    }
                    app.config.selected_row = Math.max(i-1, 0);
                },
            },

        },

        watch: {
            row_index: "onRowChange",

            "sort_order": function(new_sort_order, old_sort_order) {
                // we want to preserve the row on change of sort_order
                // i.e. changing sorting shouldn't preserve the *number* of rows
                // selected but rather the gene selected. Users seem to consistently
                // get confused by the alternative even though that was how I originally
                // imagined it to be done.
                let old_row = old_sort_order[this.config.selected_row];
                if (old_row !== undefined) {
                    let selected_row_in_new = new_sort_order.indexOf(old_row);
                    this.config.selected_row = selected_row_in_new;
                }
            },

            "config.plot": {
                handler: "redrawPlot",
                deep: true
            },

            "config.q_values_exclude_filtered": "rerunQValues"
        },

        beforeUnmount: function () {
            if (this.notificationApiConnection !== null) {
                this.notificationApiConnection.close(1001);
            }
        },
    });
</script>
{% endblock %}
